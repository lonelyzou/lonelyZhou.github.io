<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试宝典之Vue原理面试篇 | 覆水行舟的博客</title><meta name="description" content="笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改  Vue 借鉴了 angular 的模板和数据绑定技术，又借鉴了 react 的组件化和虚拟 DOM 技术  首先谈谈你对 Vue 的理解 渐进式 JavaScript 框架、核心库加插件、动态创建用户界面（异步获取后台数据，数据展示在界面）  特点： MVVM 模式；代码简洁体积小，运行效率高"><meta name="keywords" content="面试 Vue"><meta name="author" content="覆水行舟"><meta name="copyright" content="覆水行舟"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://github.com/2021/02/09/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVue%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E7%AF%87/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="面试宝典之Vue原理面试篇"><meta property="og:url" content="http://github.com/2021/02/09/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVue%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E7%AF%87/"><meta property="og:site_name" content="覆水行舟的博客"><meta property="og:description" content="笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改  Vue 借鉴了 angular 的模板和数据绑定技术，又借鉴了 react 的组件化和虚拟 DOM 技术  首先谈谈你对 Vue 的理解 渐进式 JavaScript 框架、核心库加插件、动态创建用户界面（异步获取后台数据，数据展示在界面）  特点： MVVM 模式；代码简洁体积小，运行效率高"><meta property="og:image" content="https://i.loli.net/2020/08/05/iSGHdcFNJayuoKh.jpg"><meta property="article:published_time" content="2021-02-08T16:00:00.000Z"><meta property="article:modified_time" content="2021-02-08T16:00:00.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-02-09 00:00:00'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/atom.xml" title="覆水行舟的博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-Vue-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">首先谈谈你对 Vue 的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%A1%86%E6%9E%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">渐进式框架的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%BC%98%E7%82%B9"><span class="toc-text">vue优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8BMVVM"><span class="toc-text">说下MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%92%8CjQuery%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">vue和jQuery的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BVue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-text">介绍一下Vue的响应式系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%82%B9"><span class="toc-text">vue的两个核心点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">vue 的双向绑定的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">具体实现流程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE"><span class="toc-text">vue 是如何实现响应式数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96"><span class="toc-text">vue 中是如何检测数组变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%B5%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%AF%E8%83%BD%E8%A7%A6%E5%8F%91%E5%A4%9A%E6%AC%A1-get-set%EF%BC%8C%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%A7%A6%E5%8F%91%E5%A4%9A%E6%AC%A1%E5%91%A2%EF%BC%9F"><span class="toc-text">监测数组的时候可能触发多次 get&#x2F;set，那么如何防止触发多次呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-text">Vue事件绑定原理说一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E8%AF%B4%E8%AF%B4-Vue-%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E5%90%A7"><span class="toc-text">你说说 Vue 的事件绑定原理吧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E9%87%87%E7%94%A8%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93%E5%91%A2%EF%BC%9F"><span class="toc-text">vue 采用异步渲染呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-text">为什么要使用异步组件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E7%9C%9F%E5%AE%9E-DOM-%E5%88%B0%E8%99%9A%E6%8B%9F-DOM"><span class="toc-text">如何从真实 DOM 到虚拟 DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-VNode-%E6%9D%A5%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AA-DOM-%E7%BB%93%E6%9E%84"><span class="toc-text">用 VNode 来描述一个 DOM 结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#diff-%E7%AE%97%E6%B3%95"><span class="toc-text">diff 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Vue模板渲染的原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#template%E9%A2%84%E7%BC%96%E8%AF%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">template预编译是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BVue%E4%B8%AD%E7%9A%84Diff%E7%AE%97%E6%B3%95"><span class="toc-text">介绍一下Vue中的Diff算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Vue2-0%E5%92%8CVue3-0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">说说Vue2.0和Vue3.0有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%96%B0%E5%A2%9EComposition-API%EF%BC%8C%E5%AE%83%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">为什么要新增Composition API，它能解决什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%BD%E8%AF%B4Composition-API%E4%B8%8EReact-Hook%E5%BE%88%E5%83%8F%EF%BC%8C%E8%AF%B4%E8%AF%B4%E5%8C%BA%E5%88%AB"><span class="toc-text">都说Composition API与React Hook很像，说说区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSR%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">SSR有了解吗？原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Proxy-API-%E6%9B%BF%E4%BB%A3-defineProperty-API%EF%BC%9F"><span class="toc-text">为什么要用 Proxy API 替代 defineProperty API？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-0-%E7%BC%96%E8%AF%91%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">Vue3.0 编译做了哪些优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slot-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96"><span class="toc-text">slot 编译优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">Vue 性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">代码层面的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack-%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">Webpack 层面的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9A%84-Web-%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">基础的 Web 技术的优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">单页面应用和多页面应用区别及优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E6%85%A2%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">SPA首屏加载慢如何解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy-%E5%8F%AA%E4%BC%9A%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AC%AC%E4%B8%80%E5%B1%82%EF%BC%8C%E9%82%A3%E4%B9%88-Vue3-%E5%8F%88%E6%98%AF%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%8C%E8%83%BD%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%90%97%EF%BC%9F"><span class="toc-text">Vue 模版编译原理知道吗，能简单说一下吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2-x-%E5%92%8C-Vue3-x-%E6%B8%B2%E6%9F%93%E5%99%A8%E7%9A%84-diff-%E7%AE%97%E6%B3%95%E5%88%86%E5%88%AB%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-text">Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%99%9A%E6%8B%9F-Dom-%E4%BB%A5%E5%8F%8A-key-%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">再说一下虚拟 Dom 以及 key 属性的作用</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/08/05/iSGHdcFNJayuoKh.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">覆水行舟的博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">面试宝典之Vue原理面试篇</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-08T16:00:00.000Z" title="发表于 2021-02-09 00:00:00">2021-02-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-02-08T16:00:00.000Z" title="更新于 2021-02-09 00:00:00">2021-02-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95-Vue/">面试 Vue</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p>
<blockquote>
<p>Vue 借鉴了 angular 的模板和数据绑定技术，又借鉴了 react 的组件化和虚拟 DOM 技术</p>
</blockquote>
<h2 id="首先谈谈你对-Vue-的理解"><a href="#首先谈谈你对-Vue-的理解" class="headerlink" title="首先谈谈你对 Vue 的理解"></a>首先谈谈你对 Vue 的理解</h2><ul>
<li><p>渐进式 JavaScript 框架、核心库加插件、动态创建用户界面（异步获取后台数据，数据展示在界面）</p>
</li>
<li><p>特点： MVVM 模式；代码简洁体积小，运行效率高，适合移动 PC 端开发；本身只关注 UI （和 react 相似），可以轻松引入 Vue 插件或其他的第三方库进行开发。</p>
</li>
</ul>
<h2 id="渐进式框架的理解"><a href="#渐进式框架的理解" class="headerlink" title="渐进式框架的理解"></a>渐进式框架的理解</h2><ul>
<li>主张最少；</li>
<li>可以根据不同的需求选择不同的层级；</li>
</ul>
<h2 id="vue优点"><a href="#vue优点" class="headerlink" title="vue优点"></a>vue优点</h2><ul>
<li><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；</p>
</li>
<li><p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p>
</li>
<li><p>双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；</p>
</li>
<li><p>组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；</p>
</li>
<li><p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p>
</li>
<li><p>虚拟DOM：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；</p>
</li>
<li><p>运行速度更快：相比较于 react 而言，同样是操作虚拟 dom ，就性能而言， vue 存在很大的优势</p>
</li>
</ul>
<h2 id="说下MVVM"><a href="#说下MVVM" class="headerlink" title="说下MVVM"></a>说下MVVM</h2><p>全称：Model-View-ViewModel ，<br>Model 表示数据模型层。view 表示视图层， ViewModel 是 View 和 Model 层的桥梁，数据绑定到 viewModel 层并自动渲染到页面中，视图变化通知 viewModel 层更新数据。</p>
<h2 id="vue和jQuery的区别"><a href="#vue和jQuery的区别" class="headerlink" title="vue和jQuery的区别"></a>vue和jQuery的区别</h2><p>jQuery是使用选择器（ $ ）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。<br>比如需要获取label标签的内容：$(“lable”).val(); ,它还是依赖DOM元素的值。Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。</p>
<h2 id="介绍一下Vue的响应式系统"><a href="#介绍一下Vue的响应式系统" class="headerlink" title="介绍一下Vue的响应式系统"></a>介绍一下Vue的响应式系统</h2><p>vue为MVVM框架，当数据模型data变化时，页面视图会得到响应更新，其原理对data的getter/setter方法进行拦截（Object.defineProperty或者Proxy），利用发布订阅的设计模式，在getter方法中进行订阅，在setter方法中发布通知，让所有订阅者完成响应。</p>
<h2 id="vue的两个核心点"><a href="#vue的两个核心点" class="headerlink" title="vue的两个核心点"></a>vue的两个核心点</h2><p>数据驱动、组件系统</p>
<p>数据驱动： ViewModel，保证数据和视图的一致性。<br><br>组件系统： 应用类UI可以看作全部是由组件树构成的。</p>
<h2 id="vue-的双向绑定的原理"><a href="#vue-的双向绑定的原理" class="headerlink" title="vue 的双向绑定的原理"></a>vue 的双向绑定的原理</h2><p>数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。<br><br>通过ES5提供的Object.defineProperty()方法来劫持(监视)各个属性的setter,getter，在数据变动的时发布消息给订阅者，触发相应的监听回调。并且，由于是在不同的数据上触发同步，可以精确的将变更发送发送给绑定的视图，而不是对所有的数据都执行一次检测。</p>
<h3 id="具体实现流程："><a href="#具体实现流程：" class="headerlink" title="具体实现流程："></a>具体实现流程：</h3><ol>
<li>实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者</li>
<li>实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图</li>
<li>接着，我们还需要实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</li>
</ol>
<h2 id="vue-是如何实现响应式数据"><a href="#vue-是如何实现响应式数据" class="headerlink" title="vue 是如何实现响应式数据"></a>vue 是如何实现响应式数据</h2><p>Vue2：Object.definProperty 重新定义 data 中所有的属性， Object.definProperty 可以使数据的获取与设置增加一个拦截的功能，拦截属性的获取，进行依赖收集。拦截属性的更新操作，进行通知。具体的过程：首先 Vue 使用 initData 初始化用户传入的参数，然后使用 new Observer 对数据进行观测，如果数据是一个对象类型就会调用 this.walk（value） 对对象进行处理，内部使用 defineReactive 循环对象属性定义响应式变化，核心就是使用 Object.definProperty 重新定义数据。</p>
<p>vue3: Proxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。</p>
<p>d) Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<h2 id="vue-中是如何检测数组变化"><a href="#vue-中是如何检测数组变化" class="headerlink" title="vue 中是如何检测数组变化"></a>vue 中是如何检测数组变化</h2><p>数组就是使用 object.defineProperty 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的， pop 、 push 、 shift 、 unshift 、 splice 、 sort 、 reverse 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解。</p>
<p>使用了函数劫持的方式，重写了数组的方法，Vue 将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法。</p>
<p>这样当调用数组 api 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p>
<h2 id="监测数组的时候可能触发多次-get-set，那么如何防止触发多次呢？"><a href="#监测数组的时候可能触发多次-get-set，那么如何防止触发多次呢？" class="headerlink" title="监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？"></a>监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？</h2><p>我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。</p>
<h2 id="Vue事件绑定原理说一下"><a href="#Vue事件绑定原理说一下" class="headerlink" title="Vue事件绑定原理说一下"></a>Vue事件绑定原理说一下</h2><p>每一个Vue实例都是一个Event Bus，当子组件被创建的时候，父组件将事件传递给子组件，子组件初始化的时候是有$on方法将事件注册到内部，在需要的时候使用$emit触发函数，而对于原生native事件，使用addEventListener绑定到真实的DOM元素上。</p>
<h2 id="你说说-Vue-的事件绑定原理吧"><a href="#你说说-Vue-的事件绑定原理吧" class="headerlink" title="你说说 Vue 的事件绑定原理吧"></a>你说说 Vue 的事件绑定原理吧</h2><p>原生 DOM 的绑定：Vue 在创建真实 DOM 时会调用 createElm ，默认会调用 invokeCreateHooks 。会遍历当前平台下相对的属性处理代码，其中就有 updateDOMLListeners 方法，内部会传入 add（） 方法。</p>
<p>原生事件绑定是通过 addEventListener 绑定给真实元素的,组件事件绑定是通过 Vue 自定义的$on 实现的。</p>
<h2 id="vue-采用异步渲染呢？"><a href="#vue-采用异步渲染呢？" class="headerlink" title="vue 采用异步渲染呢？"></a>vue 采用异步渲染呢？</h2><p>Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 nextTick 。dep.notify（） 通知 watcher 进行更新， subs[i].update 依次调用 watcher 的 update ， queueWatcher 将 watcher 去重放入队列， nextTick（ flushSchedulerQueue ）在下一 tick 中刷新 watcher 队列（异步）。</p>
<h2 id="为什么要使用异步组件？"><a href="#为什么要使用异步组件？" class="headerlink" title="为什么要使用异步组件？"></a>为什么要使用异步组件？</h2><ol>
<li>节省打包出的结果，异步组件分开打包，采用 jsonp 的方式进行加载，有效解决文件过大的问题。</li>
<li>核心就是包组件定义变成一个函数，依赖 import（） 语法，可以实现文件的分割加载。</li>
</ol>
<h2 id="如何从真实-DOM-到虚拟-DOM"><a href="#如何从真实-DOM-到虚拟-DOM" class="headerlink" title="如何从真实 DOM 到虚拟 DOM"></a>如何从真实 DOM 到虚拟 DOM</h2><p>涉及到 Vue 中的模板编译原理，主要过程：</p>
<ol>
<li><p>将模板转换成 ast 树， ast 用对象来描述真实的 JS 语法（将真实 DOM 转换成虚拟 DOM）</p>
</li>
<li><p>优化树</p>
</li>
<li><p>将 ast 树生成代码</p>
</li>
</ol>
<h2 id="用-VNode-来描述一个-DOM-结构"><a href="#用-VNode-来描述一个-DOM-结构" class="headerlink" title="用 VNode 来描述一个 DOM 结构"></a>用 VNode 来描述一个 DOM 结构</h2><p>虚拟节点就是用一个对象来描述一个真实的 DOM 元素。首先将 template （真实 DOM）先转成 ast ， ast 树通过 codegen 生成 render 函数， render 函数里的 _c 方法将它转为虚拟 dom</p>
<h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><p>时间复杂度： 个树的完全 diff 算法是一个时间复杂度为 O(n*3） ，vue 进行优化转化成 O(n) 。理解：</p>
<p>最小量更新， key 很重要。这个可以是这个节点的唯一标识，告诉 diff 算法，在更改前后它们是同一个 DOM 节点</p>
<p>扩展 v-for 为什么要有 key ，没有 key 会暴力复用，举例子的话随便说一个比如移动节点或者增加节点（修改 DOM），加 key 只会移动减少操作 DOM。<br>只有是同一个虚拟节点才会进行精细化比较，否则就是暴力删除旧的，插入新的。</p>
<p>只进行同层比较，不会进行跨层比较。</p>
<p>diff 算法的优化策略：四种命中查找，四个指针</p>
<p>旧前与新前（先比开头，后插入和删除节点的这种情况）</p>
<p>旧后与新后（比结尾，前插入或删除的情况）</p>
<p>旧前与新后（头与尾比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧后之后）</p>
<p>旧后与新前（尾与头比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧前之前）</p>
<h2 id="Vue模板渲染的原理是什么？"><a href="#Vue模板渲染的原理是什么？" class="headerlink" title="Vue模板渲染的原理是什么？"></a>Vue模板渲染的原理是什么？</h2><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。<br>模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p>
<p>parse阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。<br>optimize阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。<br>generate阶段：将最终的AST转化为render函数字符串。</p>
<h2 id="template预编译是什么？"><a href="#template预编译是什么？" class="headerlink" title="template预编译是什么？"></a>template预编译是什么？</h2><p>对于 Vue 组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后在也不会进行编译。因此，编译对组件的 runtime 是一种性能损耗。<br>而模板编译的目的仅仅是将template转化为render function，这个过程，正好可以在项目构建的过程中完成，这样可以让实际组件在 runtime 时直接跳过模板渲染，进而提升性能，这个在项目构建的编译template的过程，就是预编译。<br>那template和jsx的有什么分别？<br>对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。<br>在 webpack 中，我们使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。<br>与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。<br>所以，template和jsx的都是render的一种表现形式，不同的是：<br>JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。<br>说一下什么是Virtual DOM<br>Virtual DOM 是 DOM 节点在 JavaScript 中的一种抽象数据结构，之所以需要虚拟DOM，是因为浏览器中操作DOM的代价比较昂贵，频繁操作DOM会产生性能问题。虚拟DOM的作用是在每一次响应式数据发生变化引起页面重渲染时，Vue对比更新前后的虚拟DOM，匹配找出尽可能少的需要更新的真实DOM，从而达到提升性能的目的。</p>
<h2 id="介绍一下Vue中的Diff算法"><a href="#介绍一下Vue中的Diff算法" class="headerlink" title="介绍一下Vue中的Diff算法"></a>介绍一下Vue中的Diff算法</h2><p>在新老虚拟DOM对比时</p>
<p>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换<br>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)<br>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。<br>匹配时，找到相同的子节点，递归比较子节点</p>
<p>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n^3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p>
<h2 id="说说Vue2-0和Vue3-0有什么区别"><a href="#说说Vue2-0和Vue3-0有什么区别" class="headerlink" title="说说Vue2.0和Vue3.0有什么区别"></a>说说Vue2.0和Vue3.0有什么区别</h2><p>重构响应式系统，使用Proxy替换Object.defineProperty，使用Proxy优势：</p>
<p>可直接监听数组类型的数据变化<br>监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升<br>可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行<br>直接实现对象属性的新增/删除</p>
<p>新增Composition API，更好的逻辑复用和代码组织<br>重构 Virtual DOM</p>
<p>模板编译时的优化，将一些静态节点编译成常量<br>slot优化，将slot编译为lazy函数，将slot的渲染的决定权交给子组件<br>模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）</p>
<p>代码结构调整，更便于Tree shaking，使得体积更小<br>使用Typescript替换Flow</p>
<h2 id="为什么要新增Composition-API，它能解决什么问题"><a href="#为什么要新增Composition-API，它能解决什么问题" class="headerlink" title="为什么要新增Composition API，它能解决什么问题"></a>为什么要新增Composition API，它能解决什么问题</h2><p>Vue2.0中，随着功能的增加，组件变得越来越复杂，越来越难维护，而难以维护的根本原因是Vue的API设计迫使开发者使用watch，computed，methods选项组织代码，而不是实际的业务逻辑。<br>另外Vue2.0缺少一种较为简洁的低成本的机制来完成逻辑复用，虽然可以minxis完成逻辑复用，但是当mixin变多的时候，会使得难以找到对应的data、computed或者method来源于哪个mixin，使得类型推断难以进行。<br>所以Composition API的出现，主要是也是为了解决Option API带来的问题，第一个是代码组织问题，Compostion API可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性，也就是说当下一个开发者接触这一段不是他自己写的代码时，他可以更好的利用代码的组织反推出实际的业务逻辑，或者根据业务逻辑更好的理解代码。<br>第二个是实现代码的逻辑提取与复用，当然mixin也可以实现逻辑提取与复用，但是像前面所说的，多个mixin作用在同一个组件时，很难看出property是来源于哪个mixin，来源不清楚，另外，多个mixin的property存在变量命名冲突的风险。而Composition API刚好解决了这两个问题。</p>
<h2 id="都说Composition-API与React-Hook很像，说说区别"><a href="#都说Composition-API与React-Hook很像，说说区别" class="headerlink" title="都说Composition API与React Hook很像，说说区别"></a>都说Composition API与React Hook很像，说说区别</h2><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p>
<p>不能在循环、条件、嵌套函数中调用Hook<br>必须确保总是在你的React函数的顶层调用Hook<br>useEffect、useMemo等函数必须手动确定依赖关系</p>
<p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p>
<p>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢<br>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用<br>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</p>
<p>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p>
<h2 id="SSR有了解吗？原理是什么？"><a href="#SSR有了解吗？原理是什么？" class="headerlink" title="SSR有了解吗？原理是什么？"></a>SSR有了解吗？原理是什么？</h2><p>在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且在服务器内部将Vue组件渲染成HTML，并且将数据、HTML一并返回给客户端，这个在服务器将数据和组件转化为HTML的过程，叫做服务端渲染SSR。<br>而当客户端拿到服务器渲染的HTML和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者Vuex内部即可。除了数据意外，HTML也结构已经有了，客户端在渲染组件的时候，也只需要将HTML的DOM节点映射到Virtual DOM即可，不需要重新创建DOM节点，这个将数据和HTML同步的过程，又叫做客户端激活。<br>使用SSR的好处：</p>
<p>有利于SEO：其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行JavaScript的，这种不支持执行JavaScript的爬虫抓取到的非SSR的页面会是一个空的HTML页面，而有了SSR以后，这些爬虫就可以获取到完整的HTML结构的数据，进而收录到搜索引擎中。</p>
<p>白屏时间更短：相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。</p>
<h2 id="为什么要用-Proxy-API-替代-defineProperty-API？"><a href="#为什么要用-Proxy-API-替代-defineProperty-API？" class="headerlink" title="为什么要用 Proxy API 替代 defineProperty API？"></a>为什么要用 Proxy API 替代 defineProperty API？</h2><p>a) defineProperty 的局限性的最大原因是它只能针对单例属性做监听，Vue2.x中对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。<br>这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因。<br>b) 在Vue 中使用下标的方式直接修改属性的值或者添加一个预先不存在的对<br>象属性是无法做到 setter 监听的，这是 defineProperty 的局限性。<br>c) Proxy 的监听是针对一个对象的，那么对这个对象的所有操作会进入监听<br>操作，这就完全可以代理所有属性，将会带来很大的性能提升和更优的代<br>码。<br>d) Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访<br>问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进<br>行过滤和改写。</p>
<ol start="2">
<li>响应式是惰性的<br>a) 在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的<br>变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对<br>象数据都变成响应式的，这无疑会有很大的性能消耗。<br>b) 在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变<br>化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正<br>访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减<br>少性能消耗。</li>
</ol>
<h2 id="Vue3-0-编译做了哪些优化？"><a href="#Vue3-0-编译做了哪些优化？" class="headerlink" title="Vue3.0 编译做了哪些优化？"></a>Vue3.0 编译做了哪些优化？</h2><p>a) 生成 block tree<br>i. Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部<br>需要遍历该组件的整个 vnode 树。<br>ii. Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了 Block<br>tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个<br>区块内部的节点结构是固定的。每个区块只需要追踪自身包含的动态节<br>点。</p>
<h2 id="slot-编译优化"><a href="#slot-编译优化" class="headerlink" title="slot 编译优化"></a>slot 编译优化</h2><p>i. Vue.js 2.x 中，如果有一个组件传入了 slot，那么每次父组件更新的时候，<br>会强制使子组件 update，造成性能的浪费。<br>ii. Vue.js 3.0 优化了 slot 的生成，使得非动态 slot 中属性的更新只会触发子<br>组件的更新。动态 slot 指的是在 slot 上面使用 v-if，v-for，动态 slot 名字<br>等会导致 slot 产生运行时动态变化但是又无法被子组件 track 的操作。</p>
<h2 id="Vue-性能优化"><a href="#Vue-性能优化" class="headerlink" title="Vue 性能优化"></a>Vue 性能优化</h2><h3 id="代码层面的优化"><a href="#代码层面的优化" class="headerlink" title="代码层面的优化"></a>代码层面的优化</h3><ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch 区分使用场景</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>长列表性能优化</li>
<li>事件的销毁</li>
<li>图片资源懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>优化无限列表性能</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
<h3 id="Webpack-层面的优化"><a href="#Webpack-层面的优化" class="headerlink" title="Webpack 层面的优化"></a>Webpack 层面的优化</h3><ul>
<li>Webpack 对图片进行压缩</li>
<li>减少 ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 CSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>Vue 项目的编译优化</li>
</ul>
<h3 id="基础的-Web-技术的优化"><a href="#基础的-Web-技术的优化" class="headerlink" title="基础的 Web 技术的优化"></a>基础的 Web 技术的优化</h3><ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
<h2 id="单页面应用和多页面应用区别及优缺点"><a href="#单页面应用和多页面应用区别及优缺点" class="headerlink" title="单页面应用和多页面应用区别及优缺点"></a>单页面应用和多页面应用区别及优缺点</h2><p>答：单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。</p>
<p>多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新</p>
<p>单页面的优点：用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。</p>
<p>单页面缺点：不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。</p>
<h2 id="SPA首屏加载慢如何解决"><a href="#SPA首屏加载慢如何解决" class="headerlink" title="SPA首屏加载慢如何解决"></a>SPA首屏加载慢如何解决</h2><p>答：安装动态懒加载所需插件；使用CDN资源。</p>
<h2 id="Proxy-只会代理对象的第一层，那么-Vue3-又是怎样处理这个问题的呢？"><a href="#Proxy-只会代理对象的第一层，那么-Vue3-又是怎样处理这个问题的呢？" class="headerlink" title="Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？"></a>Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？</h2><p>判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测。</p>
<h2 id="Vue-模版编译原理知道吗，能简单说一下吗？"><a href="#Vue-模版编译原理知道吗，能简单说一下吗？" class="headerlink" title="Vue 模版编译原理知道吗，能简单说一下吗？"></a>Vue 模版编译原理知道吗，能简单说一下吗？</h2><p>简单说，Vue 的编译过程就是将 template 转化为 render 函数的过程。会经历以下阶段：</p>
<p>生成 AST 树</p>
<p>优化</p>
<p>codegen</p>
<p>首先解析模版，生成 AST 语法树(一种用 JavaScript 对象的形式来描述整个模板)。使用大量的正则表达式对模板进行解析，</p>
<p>遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p>
<p>Vue 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 DOM 也不会变化。</p>
<p>那么优化过程就是深度遍历 AST 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p>
<p>编译的最后一步是将优化后的 AST 树转换为可执行的代码。</p>
<h2 id="Vue2-x-和-Vue3-x-渲染器的-diff-算法分别说一下"><a href="#Vue2-x-和-Vue3-x-渲染器的-diff-算法分别说一下" class="headerlink" title="Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下"></a>Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下</h2><p>简单来说，diff 算法有以下过程</p>
<p>同级比较，再比较子节点</p>
<p>先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)</p>
<p>比较都有子节点的情况(核心 diff)</p>
<p>递归比较子节点</p>
<p>正常 Diff 两个树的时间复杂度是 O(n^3)，但实际情况下我们很少会进行跨层级的移动 DOM，所以 Vue 将 Diff 进行了优化，从 O(n^3) -&gt; O(n)，</p>
<p>只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。</p>
<p>Vue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。</p>
<p>相比 React 的 Diff 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p>
<p>Vue3.x 借鉴了 ivi 算法和 inferno 算法</p>
<p>在创建 VNode 时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，</p>
<p>使得性能上较 Vue2.x 有了提升。</p>
<p>该算法中还运用了动态规划的思想求解最长递归子序列。</p>
<h2 id="再说一下虚拟-Dom-以及-key-属性的作用"><a href="#再说一下虚拟-Dom-以及-key-属性的作用" class="headerlink" title="再说一下虚拟 Dom 以及 key 属性的作用"></a>再说一下虚拟 Dom 以及 key 属性的作用</h2><p>由于在浏览器中操作 DOM 是很昂贵的。频繁的操作 DOM，会产生一定的性能问题。这就是虚拟 Dom 的产生原因。</p>
<p>Vue2 的 Virtual DOM 借鉴了开源库 snabbdom 的实现。</p>
<p>Virtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点。是对真实 DOM 的一层抽象。(也就是源码中的 VNode 类，它定义在 src/core/vdom/vnode.js 中。)</p>
<p>VirtualDOM 映射到真实 DOM 要经历 VNode 的 create、diff、patch 等阶段。</p>
<p>「key 的作用是尽可能的复用 DOM 元素。」</p>
<p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。</p>
<p>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key 也就是 children 中节点的唯一标识。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://lonelyzou.github.io/">覆水行舟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://lonelyzou.github.io/">https://lonelyzou.github.io/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归覆水行舟所有，如有转载，请註明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95-Vue/">面试 Vue</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/08/05/iSGHdcFNJayuoKh.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/02/09/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVue%E8%B7%AF%E7%94%B1&amp;vuex%E9%9D%A2%E8%AF%95%E7%AF%87/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/08/05/QFz9sfR7Du4KLJd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试宝典之Vue路由&amp;vuex面试篇</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/06/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8BWebpack%E4%BC%98%E5%8C%96/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/08/05/QFz9sfR7Du4KLJd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端工程化之Webpack优化</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/03/05/面试宝典之VueAPI面试篇 /" title="面试宝典之VueAPI面试篇"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/05/QFz9sfR7Du4KLJd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-05</div><div class="relatedPosts_title">面试宝典之VueAPI面试篇</div></div></a></div><div class="relatedPosts_item"><a href="/2021/02/09/面试宝典之Vue路由&vuex面试篇/" title="面试宝典之Vue路由&vuex面试篇"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/08/05/QFz9sfR7Du4KLJd.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-09</div><div class="relatedPosts_title">面试宝典之Vue路由&vuex面试篇</div></div></a></div></div></div></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/08/05/iSGHdcFNJayuoKh.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 覆水行舟</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script defer="defer" id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script></div></body></html>