<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>覆水行舟的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2021-02-08T16:00:00.000Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>覆水行舟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS之面试重点篇</title>
    <link href="http://github.com/2021/02/09/CSS%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E7%AF%87/"/>
    <id>http://github.com/2021/02/09/CSS%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E7%AF%87/</id>
    <published>2021-02-08T16:00:00.000Z</published>
    <updated>2021-02-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对CSS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://juejin.cn/post/6844903842635579405">【面试篇】寒冬求职之你必须要懂的Web安全</a></p></li><li><p><a href="https://zoumiaojiang.com/article/common-web-security/#xss">常见 Web 安全攻防总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对CSS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h2&gt;&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="CSS 面试" scheme="http://github.com/categories/CSS-%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="CSS 面试" scheme="http://github.com/tags/CSS-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CSS之基础篇</title>
    <link href="http://github.com/2021/02/09/CSS%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://github.com/2021/02/09/CSS%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2021-02-08T16:00:00.000Z</published>
    <updated>2021-02-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对CSS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="DIV-CSS-布局的优缺点"><a href="#DIV-CSS-布局的优缺点" class="headerlink" title="DIV + CSS 布局的优缺点"></a>DIV + CSS 布局的优缺点</h2><p>优点：</p><ul><li>代码精简，且结构与样式分离，易于维护</li><li>代码量减少了，减少了大量的带宽，页面加载的也更快，提升了用户的体验</li><li>对 SEO 搜索引擎更加友好，且 H5 又新增了许多语义化标签更是如此</li><li>允许更多炫酷的页面效果，丰富了页面</li><li>符合 W3C 标准，保证网站不会因为网络应用的升级而被淘汰</li></ul><p>缺点：</p><p>不同浏览器对 Web 标准默认值不同，所以更容易出现对浏览器的兼容性问题。</p><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>基本原理是通过媒体查询（@media）检测不同的设备屏幕尺寸做处理。</p><p>好处：对某些数据的修改就能自动更新视图，让开发者不需要操作 DOM，有更多的时间去思考完成业务逻辑。</p><h2 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h2><p>文档流：将窗体自上而下分成一行一行，并在每行中按从左至右一次排放元素，成为文档流，也就普通流。</p><p>脱离文档流：脱离文档流的元素，将不再在文档流占据空间，而是漂浮在文档流上方。</p><p><code>float: left/right</code>：使用之后会脱离，但是其他盒子会环绕该元素的周围。</p><p><code>position: absolute/fixed：absolute</code> 为绝对定位，脱离文档流之后还是会相对于该元素的父类（做了 <code>relative/absolute</code> 定位的父类）进行偏移。而 <code>fixed</code> 就是完全脱离文档流，相对于 <code>HTML</code> （整个浏览器窗口）的形式展示。</p><h2 id="块级格式化上下文（BFC）"><a href="#块级格式化上下文（BFC）" class="headerlink" title="块级格式化上下文（BFC）"></a>块级格式化上下文（BFC）</h2><p>BFC 布局规则 是指页面上一个隔离的独立容器，容器内部的子元素不会影响到外面的元素，反之外面的元素也不会影响容器里面的元素。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>在 BFC 中，盒子从顶端开始垂直地一个接一个地排列</li><li>盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠</li></ul><h3 id="外边距问题"><a href="#外边距问题" class="headerlink" title="外边距问题"></a>外边距问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;width:100px; height:100px; margin-bottom:100px;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div style=<span class="string">&quot;width:100px; height:100px; margin-top:200px;&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这段代码产生的页面中，它们的边距是 200px，需要通过 BFC 解决边距问题。</p><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h3><ol><li><p>清除元素内部浮动。<code>overflow: hidden</code></p></li><li><p>解决外边距合并问题。创建 2 个不同 <code>BFC</code>，就不会发生 <code>margin</code> 重叠</p><h3 id="产生-BFC-的条件："><a href="#产生-BFC-的条件：" class="headerlink" title="产生 BFC 的条件："></a>产生 BFC 的条件：</h3></li><li><p>根元素 <code>html</code></p></li><li><p><code>float: left/right</code></p></li><li><p><code>position: absolute/fixed</code></p></li><li><p><code>display: inline-block/flex/grid</code></p></li><li><p><code>overflow: hidden</code></p></li></ol><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><ul><li><code>box-sizing: content-box</code>。标准盒子，总宽度等于：<code>width + padding + border + margin</code>。</li><li><code>box-sizing: border-box</code>。<code>IE</code> 盒子，总宽度等于：<code>width + margin</code>。<code>IE</code> 盒子的 <code>width</code> 包含了 <code>width、padding</code> 和 <code>border</code> 属性。</li></ul><h2 id="link-和-import-区别"><a href="#link-和-import-区别" class="headerlink" title="link 和 @import 区别"></a>link 和 @import 区别</h2><p>CSS 引入方式有：</p><ul><li>内联：<code>style</code> 属性（<code>style=&quot;color: red&quot;</code>）</li><li>内嵌：<code>style</code> 标签（<code>&lt;style&gt;&lt;/style&gt;</code>）</li><li>外链：<code>link</code> 标签（<code>&lt;link href=&quot;index.css&quot;</code>&gt;</li><li>导入：<code>@import</code>（<code>@import url(&#39;index.css&#39;</code>) 或者 @import ‘index.css’）</li></ul><h3 id="link-和-import-区别："><a href="#link-和-import-区别：" class="headerlink" title="link 和 @import 区别："></a>link 和 @import 区别：</h3><ul><li><code>link</code> 是 <code>XHTML</code> 标签，除了加载 <code>CSS</code> 外，还可以定义 <code>RSS</code> 等其他事务；<code>@import</code> 属于 <code>CSS</code> 范畴，只能加载 <code>CSS</code>。</li><li><code>link</code> 引用 <code>CSS</code> 时，在页面载入时同时加载；<code>@import</code> 需要页面网页完全载入以后加载。</li><li><code>link</code> 是 <code>XHTML</code> 标签，无兼容问题；<code>@import</code> 是在 <code>CSS2.1</code> 提出的，低版本的浏览器不支持。</li><li><code>link</code> 支持使用 <code>Javascript</code> 控制 <code>DOM</code> 去改变样式；而 <code>@import</code> 不支持。</li></ul><h2 id="渐进增减和优雅降级"><a href="#渐进增减和优雅降级" class="headerlink" title="渐进增减和优雅降级"></a>渐进增减和优雅降级</h2><p>关键的区别是他们所侧重的内容，以及这种不同造成的工作流程的差异。</p><ul><li>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li><li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li></ul><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul><li>优雅降级是从复杂的现状开始，并试图减少用户体验的供给<br>渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要</li><li>降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</li></ul><h2 id="CSS-实现垂直居中"><a href="#CSS-实现垂直居中" class="headerlink" title="CSS 实现垂直居中"></a>CSS 实现垂直居中</h2><ol><li><p>方法一：Flex 布局（子元素是块级元素）</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-center&#123;</span><br><span class="line">  margin: auto;</span><br><span class="line">  background-color: greenyellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二：Flex 布局</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-center&#123;</span><br><span class="line">  background-color: greenyellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法三：绝对定位实现（定位元素定宽定高）</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-center&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">0</span>;</span><br><span class="line">  right: <span class="number">0</span>;</span><br><span class="line">  bottom: <span class="number">0</span>;</span><br><span class="line">  top: <span class="number">0</span>;</span><br><span class="line">  margin: auto;</span><br><span class="line">  width: <span class="number">50</span>px;</span><br><span class="line">  height: <span class="number">50</span>px;</span><br><span class="line">  background-color: greenyellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法四：使用 transform</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父盒子设置：display: relative</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子盒子 div 设置：</span></span><br><span class="line">div &#123;</span><br><span class="line">  transform: translate(<span class="number">-50</span>%, <span class="number">-50</span>%);</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: <span class="number">50</span>%;</span><br><span class="line">  left: <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h2><p>垂直居中分为水平居中、和垂直居中、完全居中（水平垂直都居中）</p></li></ol><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ol><li>行内元素可以通过在其父节点声明 text-align: center; 来实现,适用于内联、内联块、内联表、内联 Flex</li><li>块级元素可以通过 margin: 0 auto; + 宽度width<br>(在现代浏览器中实现水平居中，可以使用 display: flex; justify-content: center;不过，在 IE8-9 这样的不支持弹性盒布局的旧式浏览器中，上述代码并不会生效。此时要实现在父元素中居中，可使用 margin: 0 auto)<ul><li>节点不是块级元素需声明 display:block</li><li>若节点宽度已隐式声明则无需显式声明 width</li></ul></li><li>绝对定位 absolute+移动 transform 的方式</li><li>绝对定位 absolute+margin 负边距的方案</li><li>display:flex + justify-content:center</li></ol><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ol><li>子元素是单行文本的话直接 line-height 等于父节点的高度</li><li>display:flex + align-items:center</li><li>绝对定位 absolute+移动 transform 的方式</li><li>绝对定位 absolute+margin 负边距的方案</li></ol><h3 id="水平和垂直居中"><a href="#水平和垂直居中" class="headerlink" title="水平和垂直居中"></a>水平和垂直居中</h3><p>元素的宽度和高度 固定</p><p>绝对定位在 50%处，然后通过 margin 调整位置，浏览器兼容性良好</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;child&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.parent &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">50</span>%;</span><br><span class="line">  top: <span class="number">50</span>%;</span><br><span class="line">  margin: <span class="number">-50</span>px <span class="number">0</span> <span class="number">0</span> <span class="number">-50</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.child &#123;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">0</span>;</span><br><span class="line">  top: <span class="number">0</span>;</span><br><span class="line">  right: <span class="number">0</span>;</span><br><span class="line">  bottom: <span class="number">0</span>;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的宽度和高度 未知</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">50</span>%;</span><br><span class="line">  top: <span class="number">50</span>%;</span><br><span class="line">  <span class="comment">/* margin: -50px 0 0 -50px; */</span></span><br><span class="line">  transform: translate(<span class="number">-50</span>%, <span class="number">-50</span>%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强大的 flex 布局结合 margin</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  div &#123;</span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS-单位"><a href="#CSS-单位" class="headerlink" title="CSS 单位"></a>CSS 单位</h2><h3 id="1-px"><a href="#1-px" class="headerlink" title="1. px"></a>1. px</h3><p>px 是像素（pixel）的缩写，相对长度单位，是网页设计常用的基本基本单位，它是相对于显示器屏幕分辨率而言的。</p><h3 id="2-em"><a href="#2-em" class="headerlink" title="2. em"></a>2. em</h3><p>em 是相对长度单位，相对于对象内文本的字体尺寸（参考物是父元素的 font-size。</p><p>如果当前父元素的字体元素未设置，则相对于浏览器的默认字体尺寸设置。</p><h3 id="3-rem"><a href="#3-rem" class="headerlink" title="3. rem"></a>3. rem</h3><p>rem 是相对于 HTML 根元素的字体大小（font-size）来计算的长度单位。</p><p>如果你没有设置 HTML 字体大小，那么以浏览器默认为主，一般为 16px。</p><h3 id="4-vw-vh"><a href="#4-vw-vh" class="headerlink" title="4. vw/vh"></a>4. vw/vh</h3><p>vw 和 vh 是相对于 viewport - 相对视口的宽度或者高度而定的。</p><p>一般来说：1vw = npx / 100，即浏览器宽度为 200px 的时候，1vw = 200px / 100，即 1vw = 2px。</p><h2 id="CSS-设置隐藏元素"><a href="#CSS-设置隐藏元素" class="headerlink" title="CSS 设置隐藏元素"></a>CSS 设置隐藏元素</h2><ul><li><code>display: none</code>：彻底消失，会导致浏览器回流和重绘，不能再触发点击事件。</li><li><code>visibility: hidden</code>：元素隐藏，空间仍保留，会导致重绘，但是不能再触发点击事件。</li><li><code>opacity: 0</code>：设置为透明，相当于它还在那里，但是你看不到，可以触发点击事件。</li></ul><h2 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h2><p>CSS 选择器及样式优先级：</p><ul><li>在属性后面使用 !important 会覆盖页面任意位置定义的元素样式</li><li>作为 style 属性写在元素内的样式（行内样式）</li><li>id 选择器</li><li>类选择器 | 伪类选择器 | 属性选择器（后面样式覆盖前面样式）</li><li>标签选择器</li><li>通配符选择器</li><li>浏览器自定义样式</li></ul><h2 id="CSS-匹配规则"><a href="#CSS-匹配规则" class="headerlink" title="CSS 匹配规则"></a>CSS 匹配规则</h2><blockquote><p>CSS 选择器的解析是从右向左解析的。</p></blockquote><p>若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。</p><p>若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。</p><p>两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p><h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>层叠上下文（stacking context），是 HTML 中一个三维的概念。在 CSS2.1 规范中，每个盒模型的位置是三维的，分别是平面画布上的 X 轴，Y 轴以及表示层叠的 Z 轴。</p><p>一般情况下，元素在页面上沿 X 轴 Y 轴平铺，我们察觉不到它们在 Z 轴上的层叠关系。</p><p>而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。</p><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ul><li>根层叠上下文（HTML）</li><li>position</li><li>CSS3 属性<ul><li>flex</li><li>transform</li><li>opacity</li><li>filter</li><li>will-change</li><li>-webkit-overflow-scrolling</li></ul></li></ul><h3 id="层叠等级"><a href="#层叠等级" class="headerlink" title="层叠等级"></a>层叠等级</h3><p>层叠等级：层叠上下文在 Z 轴上的排序</p><p>在同一层叠上下文中，层叠等级才有意义<br>z-index 的优先级最高</p><h2 id="dispaly-和-position"><a href="#dispaly-和-position" class="headerlink" title="dispaly 和 position"></a>dispaly 和 position</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>inline</code>：（默认）内联</li><li><code>none</code>：隐藏</li><li><code>block</code>：块显示</li><li><code>table</code>：表格显示</li><li><code>inline-block</code>：内联块<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>static</code>：默认位置。不需要特别声明，不常用。</li><li><code>relative</code>：相对定位。相对于元素默认的位置进行定位，设置 <code>top/left/right/bottom</code> 后的元素仍占据空间。</li><li><code>absolute</code>：绝对定位。如果父元素设置了 <code>position: absolute/relative</code>，那么这个设置成立。它会根据上一个设置了 <code>absolute/relative</code> 的元素进行偏移。</li><li><code>fixed</code>：固定定位。相对于整个浏览器窗口进行定位，无论页面怎么滚动。</li><li><code>sticky</code>：黏性定位。屏幕范围内该元素位置不受影响，超出范围后，会变成 <code>fixed</code>，根据设置的 <code>left/top</code> 等属性成固定的效果。</li></ul><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><ul><li>RGBA 和透明度</li><li><code>background-image</code>、<code>background-origin(content-box/padding-box/border-box)</code>、<code>background-size</code>、<code>background-repeat</code></li><li><code>word-wrap</code>：对长的不可分割单词换行，例如 <code>word-wrap：break-word</code></li><li>文字阴影：<code>text-shadow: 5px 5px 5px #FF0000</code>;，对应水平阴影，垂直阴影，模糊距离，阴影颜色</li><li><code>font-face</code> 属性：定义自己的字体</li><li>圆角（边框半径）：<code>border-radius</code> 属性用于创建圆角</li><li>边框图片：<code>border-image: url(border.png) 30 30 round</code></li><li>盒阴影：<code>box-shadow: 10px 10px 5px #888888</code></li><li>媒体查询：定义两套 <code>CSS</code>，当浏览器的尺寸变化时会采用不同的属性<h3 id="Flexbox-弹性盒布局模型"><a href="#Flexbox-弹性盒布局模型" class="headerlink" title="Flexbox 弹性盒布局模型"></a>Flexbox 弹性盒布局模型</h3></li></ul><p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。</p><p>在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。</p><p>弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。</p><p>试用场景：弹性布局适合于移动前端开发，在 Android 和 IOS 上也完美支持。</p><h2 id="CSS-优化"><a href="#CSS-优化" class="headerlink" title="CSS 优化"></a>CSS 优化</h2><ul><li>避免过度约束</li><li>避免后代选择符</li><li>避免链式选择符</li><li>使用紧凑的语法</li><li>避免不必要的命名空间</li><li>避免不必要的重复</li><li>最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么</li><li>避免 !important，可以选择其他选择器</li><li>尽可能的精简规则，你可以合并不同类里的重复规则</li></ul><h2 id="CSS-的-style-标签位置"><a href="#CSS-的-style-标签位置" class="headerlink" title="CSS 的 style 标签位置"></a>CSS 的 style 标签位置</h2><p>页面加载自上而下，当然是先加载样式。</p><p>写在 body 标签后由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在 Windows 的 IE 下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对CSS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;DIV-CSS-布局的优缺点&quot;&gt;&lt;a href=&quot;#DIV-CSS-布局的优缺点&quot; class=&quot;headerlink&quot; title=&quot;DIV + C
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://github.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://github.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化之Webpack优化</title>
    <link href="http://github.com/2021/02/06/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8BWebpack%E4%BC%98%E5%8C%96/"/>
    <id>http://github.com/2021/02/06/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8BWebpack%E4%BC%98%E5%8C%96/</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-02-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="Webpack优化"><a href="#Webpack优化" class="headerlink" title="Webpack优化"></a>Webpack优化</h2><p>Webpack 的优化瓶颈，主要是 2 个方面：</p><p>Webpack 的构建过程太花时间<br>Webpack 打包的结果体积太大</p><h2 id="针对-Webpack-本身构建优化"><a href="#针对-Webpack-本身构建优化" class="headerlink" title="针对 Webpack 本身构建优化"></a>针对 Webpack 本身构建优化</h2><h3 id="优化-resolve-modules-配置"><a href="#优化-resolve-modules-配置" class="headerlink" title="优化 resolve.modules 配置"></a>优化 resolve.modules 配置</h3><p><code>resolve.modules</code> 用于配置<code> Webpack</code> 去哪些目录下寻找第三方模块，默认是 <code>[&#39;node_modules&#39;]</code>。</p><p>但是，它会先去当前目录的 <code>./node_modules</code> 查找，没有的话再去 <code>../node_modules</code>，最后到根目录 —— 即 <code>npm</code> 查找包的规则。</p><p>所以可以直接指定项目根目录，这样代码就不需要一层一层查找。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  modules: [path.resolve(__dirname, <span class="string">&#x27;node_modules&#x27;</span>)],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化-resolve-extensions-配置"><a href="#优化-resolve-extensions-配置" class="headerlink" title="优化 resolve.extensions 配置"></a>优化 resolve.extensions 配置</h3><p>在导入没带文件后缀的路径时，<code>Webpack</code> 会自动带上后缀去尝试询问文件是否存在，而 <code>resolve.extensions</code> 用于配置尝试后缀列表；默认为 <code>extensions:[&#39;js&#39;, &#39;json&#39;]</code>。</p><p>当遇到 <code>require(&#39;./data&#39;)</code> 时 <code>Webpack</code> 会先尝试寻找 <code>data.js</code>，没有再去找 <code>data.json</code>；如果列表越长，或者正确的后缀越往后，尝试的次数就会越多。</p><p>所以在配置时为提升构建优化需遵守：</p><ul><li>频率出现高的文件后缀优先放在前面。</li><li>列表尽可能的少，例如只有 3 个：js、jsx、json。</li><li>书写导入语句时，尽量写上后缀名。</li></ul><h3 id="优化-resolve-include-exclude-配置"><a href="#优化-resolve-include-exclude-配置" class="headerlink" title="优化 resolve.include/exclude 配置"></a>优化 resolve.include/exclude 配置</h3><p>以 <code>babel-loader</code> 为例，可以通过 <code>include</code> 和 <code>exclude</code> 帮助我们避免 <code>node_modules</code> 这类庞大文件夹。</p><p>即通过 <code>include</code> 告诉 <code>Webpack</code> 哪些我们是需要检测的，通过 <code>exclude</code> 告诉 <code>Webpack</code> 哪些我们是不需要检测的（例如已经收拾过的静态资源）</p><h2 id="通过-Loader-和-Plugin-优化"><a href="#通过-Loader-和-Plugin-优化" class="headerlink" title="通过 Loader 和 Plugin 优化"></a>通过 Loader 和 Plugin 优化</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li><p>cache-loader</p><p>在 babel-loader 开启 cache 后，将 loader 的编译结果写进硬盘缓存，再次构建如果文件没有发生变化则会直接拉取缓存。</p></li><li><p>uglifyjs-webpack-plugin</p><p>通过这个插件也可以解决缓存问题。</p></li></ul><blockquote><p>注：具体的要根据当前的 Webpack 版本，Loader 和 Plugin 表示 Webpack 每次更新都会淘汰一批没有跟进维护的 Loader 和 Plugin。就跟大佬还在持续学习，你几年没学习之后，遇到金融危机被淘汰的风险就高了。</p></blockquote><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。</p><p>文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？</p><p><code>Happypack</code> 可以将任务分解成多个子进程去并发执行，大大提升打包效率。</p><p>除此之外 <code>thread-loader</code> 和 <code>Happypack</code> 一样，但是配置比较简单。</p><blockquote><p>  <code>Happypack</code> 已经不维护了。</p></blockquote><h3 id="多进程压缩"><a href="#多进程压缩" class="headerlink" title="多进程压缩"></a>多进程压缩</h3><p>因为自带的 <code>UglifyjsWebpackPlugin</code> 压缩插件是单线程运行的，而 <code>TerserWebpackPlugin</code> 可以并发运行压缩功能（多进程）。</p><p>所以通过 <code>TerserWebpackPlugin</code> 代替自带的 <code>UglifyjsWebpackPlugin</code> 插件。</p><h3 id="静态资源分离"><a href="#静态资源分离" class="headerlink" title="静态资源分离"></a>静态资源分离</h3><p>通过 <code>DllPlugin</code> 或者 <code>Externals</code> 进行静态依赖包的分离。</p><p>由于 <code>CommonsChunkPlugin</code> 每次构建会重新构建一次 <code>vendor</code>，所以出于效率考虑，使用<code>DllPlugin</code>将第三方库单独打包到一个文件中，只有依赖自身发生版本变化时才会重新打包。</p><h3 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h3><p>在 <code>Webpack </code>中，到底什么是代码分离？代码分离允许你把代码拆分到多个文件中。如果使用得当，你的应用性能会提高很多。因为浏览器能缓存你的代码。</p><p>每当你做出一次修改，包含修改的文件需要被所有访问你网站的人重新下载。但你并不会经常修改应用的依赖库。</p><p>如果你能把那些依赖库拆分到完全分离的文件中，即使业务逻辑发生了更改，访问者也不需要再次下载依赖库，直接使用之前的缓存就可以了。</p><p>由于有了 <code>SplitChunksPlugin</code>，你可以把应用中的特定部分移至不同文件。如果一个模块在不止一个 chunk 中被使用，那么利用代码分离，该模块就可以在它们之间很好地被共享。</p><h3 id="打包资源压缩"><a href="#打包资源压缩" class="headerlink" title="打包资源压缩"></a>打包资源压缩</h3><ul><li>JS 压缩：<code>UglifyjsWebpackPlugin</code></li><li>HTML 压缩：<code>HtmlWebpackPlugin</code></li><li>CSS 压缩：<code>MiniCssExtractPlugin</code></li><li>图片压缩：<code>image-webpack-loader</code></li><li>Gzip 压缩：不包括图片</li></ul><h2 id="其他优化点"><a href="#其他优化点" class="headerlink" title="其他优化点"></a>其他优化点</h2><h3 id="1-Tree-Shaking"><a href="#1-Tree-Shaking" class="headerlink" title="1. Tree Shaking"></a>1. Tree Shaking</h3><p>通过 ES6 的<code>import/export</code>来检查未引用代码，以及 <code>sideEffects</code> 来标记无副作用代码，最后用 <code>UglifyJSPlugin</code> 来做 <code>Tree Shaking</code>，从而删除冗余代码。</p><h3 id="2-Scope-Hoisting"><a href="#2-Scope-Hoisting" class="headerlink" title="2. Scope Hoisting"></a>2. Scope Hoisting</h3><p><code>Scope Hoisting</code> 是 <code>Webpack3</code> 的新功能，直译为 「<code>作用域提升」</code>，它可以让 <code>Webpack</code> 打包出来的 <code>「代码文件更小」</code>，<code>「运行速度更快」</code>。</p><p>熟悉 <code>JavaScript </code>都应该知道 <code>「函数提升」</code> 和 <code>「变量提升」</code> ，<code>JavaScript</code> 会把函数和变量声明提升到当前作用域的顶部。</p><p><code>「作用域提升」</code> 也类似于此，<code>Webpack</code> 会把引入的 <code>js</code> 文件 <code>“提升到”</code> 它的引入者顶部。</p><p><code>Scope Hoisting</code> 的实现原理其实很简单：分析出模块之间的依赖关系，尽可能将打散的模块合并到一个函数中，前提是不能造成代码冗余。因此「只有那些被引用了一次的模块才能被合并」。</p><p>由于 <code>Scope Hoisting</code> 需要分析出模块之间的依赖关系，因此源码<code>「必须采用 ES6 模块化语句」</code>，不然它将无法生效。原因和 <code>Tree Shaking </code>中介绍的类似。</p><h3 id="3-按需加载"><a href="#3-按需加载" class="headerlink" title="3. 按需加载"></a>3. 按需加载</h3><p>什么是 代码分割（<code>code splitting</code>）？</p><p>代码分割是指：将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程。</p><p>在 <code>Webpack</code> 构建时，会避免加载已声明要异步加载的代码，异步代码会被单独分离出一个文件，当代码实际调用时被加载至页面。</p><p>代码分割技术的核心是 <code>异步加载资源</code>。</p><p>可喜的是，浏览器允许我们这么做，<code>W3C stage 3</code> 规范： <code>whatwg/loader</code> 对其进行了定义：你可以通过 <code>import()</code> 关键字让浏览器在程序执行时异步加载相关资源。</p><p>在 <code>Vue</code> 中，可以直接使用 <code>import()</code> 关键字做到这一点，而在 <code>React</code> 中，你需要使用 <code>react-loadable</code> 去完成同样的事。</p><h2 id="优化体验"><a href="#优化体验" class="headerlink" title="优化体验"></a>优化体验</h2><ul><li><p><code>progress-bar-webpack-plugin</code>：在终端底部，将会有一个构建的进度条，可以让你清晰的看见构建的执行进度。</p></li><li><p><code>webpack-build-notifier</code>：在构建完成时，能够像微信、Lark 这样的 APP 弹出消息的方式，提示构建已经完成。</p></li><li><p><code>webpack-dashboard</code>：对 <code>Webpack</code> 原始的构建输出不满意的话，也可以使用这样一款 Plugin 来优化你的输出界面。</p></li><li><p><code>speed-measure-webpack-plugin</code>：该插件可以测量各个插件和 <code>loader</code> 所花费的时间。</p></li><li><p><code>webpack-bundle-analyzer</code>：可视化分析。通过矩阵树图的方式将包内各个模块的大小和依赖关系呈现出来。</p></li><li><p><code>webpack-chart</code></p></li><li><p><code>webpack-analyse</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ul><ul><li><p><a href="https://juejin.cn/post/6844903924806189070#heading-0">Webpack优化——将你的构建效率提速翻倍</a></p></li><li><p><a href="http://louiszhai.github.io/2019/01/04/webpack4/">使用webpack4提升180%编译速度</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;Webpack优化&quot;&gt;&lt;a href=&quot;#Webpack优化&quot; class=&quot;headerlink&quot; title=&quot;Webpack优化&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://github.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="前端工程化" scheme="http://github.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之HTTP</title>
    <link href="http://github.com/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BHTTP/"/>
    <id>http://github.com/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BHTTP/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="HTTP-发展史"><a href="#HTTP-发展史" class="headerlink" title="HTTP 发展史"></a>HTTP 发展史</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>传输体积很小的文件，没有 HTTP 请求头和请求体，服务器也不返回头信息。</p><p>HTTP/0.9 并没有考虑太过复杂的内容，仅仅是用来传输体积很小的文件。</p><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>核心诉求是支持多种类型的文件下载。加入了请求头和响应头支持多种不同类型的数据。以及状态码、Cache 机制、用户代理等。</p><p>应对 HTTP/0.9 出现的问题，进行了支持多类型文件下载等内容的优化。<br><br>HTTP/1.0 定义了三种请求方法：GET，POST 和 HEAD 方法。</p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><ol><li>改进了 <code>HTTP/1.0</code> 版本每次 <code>HTTP</code> 通信都需要建立 <code>TCP</code> 连接、传输 <code>HTTP</code> 数据再断开 <code>TCP</code> 连接的尴尬局面，支持持续连接。只要浏览器或者服务器没有明确断开连接，那么该 <code>TCP</code> 连接会一直保持（默认开启 <code>keep-alive</code>）。</li><li>如果 <code>TCP</code> 通道中某个请求因为某些原因没有及时返回，会阻塞后面所有请求（队头阻塞），所以 <code>HTTP/1.1 </code>通过管线化来解决队头阻塞的问题。</li><li><code>HTTP/1.0</code> 每个域名绑定唯一 <code>IP</code> 地址，一个服务器只能支持一个域名。<code>HTTP/1.1</code> 请求头增加 <code>Host</code> 字段，表示当前域名地址，服务器可以根据不同的 <code>Host</code> 值做不同的处理。这样一台物理主机就可以绑定多个虚拟主机，每个虚拟主机都有自己单独的域名。</li><li><code>HTTP/1.0</code> 需要在响应头设置完整的数据大小来接收数据，但是随着服务器端发展，很多页面动态生成，不知道传输数据的最终大小。<code>HTTP/1.1</code> 引入 <code>Chunk transfer</code> 机制来解决这个问题，服务器将数据分割成任意大小的数据块，每个数据块发送时附带上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志，从而支持了动态内容。</li><li>客户端 <code>Cookie</code>、安全机制。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>HTTP/1.1</code> 默认开启 <code>Connection: keep-alive</code>，让一个 <code>TCP </code>连接能重复发送/接收多次 <code>HTTP </code>请求。</li><li><code>HTTP/1.1</code>新增了六种请求方法：<code>OPTIONS</code>、<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>、<code>TRACE</code> 和 <code>CONNECT</code> 方法。</li></ul><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><ol><li>一个域名只使用一个 TCP 长连接和消除队头阻塞问题</li><li>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。HTTP/2.0 实现了一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</li><li>队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>头部压缩：HTTP/2 压缩消息头，减少了传输数据的大小</li><li>多路复用：即多个请求都通过一个 TCP 连接并发地完成</li><li>设置请求优先级</li><li>服务器推送：服务端能够主动把资源推送给客户端</li></ul><h3 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP/3.0"></a>HTTP/3.0</h3><ol><li>实现了类似 TCP 的流量控制、传输可靠性的功能。</li><li>集成了 TLS 加密功能。</li><li>实现了 HTTP/2 中的多路复用功能。</li><li>实现了快速握手功能。</li></ol><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="什么是http？"><a href="#什么是http？" class="headerlink" title="什么是http？"></a>什么是http？</h3><blockquote><p>超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP）</p></blockquote><p>Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器等一系列运作流程。而协议是指规则的约定。可以说，Web 是建立在 HTTP 协议上通信的。</p><p>HTTP 最初的目的是为了让研究者共享知识信息，所以它的主要作用就是文档传输，它是一种用于传输文档的协议。用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><h3 id="HTTP的优点："><a href="#HTTP的优点：" class="headerlink" title="HTTP的优点："></a>HTTP的优点：</h3><ol><li><strong><em>灵活可扩展</em></strong>，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</li><li><strong><em>可靠传输</em></strong>。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</li><li><strong><em>请求-应答</em></strong>。也就是一发一收、有来有回，当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</li><li><strong><em>无状态</em></strong>。这里的状态是指通信过程的上下文信息，而每次 HTTP 请求都是独立、无关的，默认不需要保留状态信息。</li></ol><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><ol><li><strong><em>无状态</em></strong>。在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 HTTP 的缺点了。</li><li><strong><em>明文传输</em></strong>。协议里的报文（主要指的是头部）不使用二进制数据，而是文本形式。</li><li><strong><em>队头阻塞问题</em></strong>。当 HTTP 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态。</li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="什么是https"><a href="#什么是https" class="headerlink" title="什么是https"></a>什么是https</h3><blockquote><p>https的SSL加密是在传输层实现的。</p></blockquote><p>以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p><p>简单来说 HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，比 HTTP 协议的安全性更高。</p><p>最后一个字母 S 指的是 SSL/TLS 协议，它位于 HTTP 协议与 TCP/IP 协议中间。</p><h3 id="https协议的工作原理"><a href="#https协议的工作原理" class="headerlink" title="https协议的工作原理"></a>https协议的工作原理</h3><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><ul><li>浏览器请求 URL，找到服务器，向服务器发送请求。服务器将自己的证书（包含服务器公钥）、对称加密算法种类以及其他相关信息返回给浏览器。</li><li>浏览器检查 CA 证书是否可依赖，确认证书有效。</li><li>如果不是，给服务器发警告，询问是否可以继续使用。</li><li>如果是，浏览器使用公钥加密一个随机对称秘钥，包含加密的 URL 一起发送给服务器。</li><li>服务器用自己的私钥解密浏览器发送的钥匙，然后用这把对称加密的钥匙给浏览器请求的 URL 连接解密。</li><li>服务器用浏览器发送的对称钥匙给请求的网页加密，浏览器使用相同的钥匙就可以解密网页。</li></ul><h3 id="https协议的优点"><a href="#https协议的优点" class="headerlink" title="https协议的优点"></a>https协议的优点</h3><ol><li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li><li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li></ol><h3 id="https协议的缺点"><a href="#https协议的缺点" class="headerlink" title="https协议的缺点"></a>https协议的缺点</h3><ol><li>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</li><li>https缓存不如http高效，会增加数据开销。</li><li>SSL证书也需要钱，功能越强大的证书费用越高。</li><li>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</li></ol><h2 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h2><p>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</p><p>主要的区别如下：</p><ol><li><strong><em>概念对比</em></strong>。HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</li><li><strong><em>费用对比</em></strong>。 HTTPS 协议需要 CA 证书，费用较高。</li><li><strong><em>连接方式和端口</em></strong>。使用不同的连接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li><li><strong><em>安全性对比</em></strong>。 HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ol><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><ul><li>GET：获取资源</li><li>HEAD：获取资源的元信息</li><li>POST：提交/上传 数据</li><li>PUT：修改数据</li><li>DELETE：删除资源（几乎用不到）</li><li>CONNECT：建立连接渠道，用于代理服务器</li><li>OPTIONS：列出可对资源实施的请求方法，用来跨域请求</li><li>TRACE：追踪请求-响应的传输路径</li></ul><h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><p>GET 和 POST 方法没有实质区别，只是报文格式不同。</p><p>GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议。</p><p>无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。</p><ul><li>GET 获取资源；POST 提交/上传 数据。</li><li>GET 请求长度在浏览器中有限制，而 POST 并没有。</li><li>GET 请求会被浏览器主动保留下来（历史记录），而 POST 默认不会。</li><li>get和post在缓存方面的区别：<ul><li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li><li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li></ul></li></ul><h3 id="【误】GET-请求传参长度有限制"><a href="#【误】GET-请求传参长度有限制" class="headerlink" title="【误】GET 请求传参长度有限制"></a>【误】GET 请求传参长度有限制</h3><p>【误】我们经常说 GET 请求参数的大小存在限制，而 POST 请求的参数大小是无限制的。</p><p>其实这是有问题的，实际上 HTTP 协议从来没规定 GET/POST 的请求长度限制是多少。</p><p>对 GET 请求参数的限制来源于浏览器或者 Web 服务器，是它们限制了这个长度。</p><p>不同的浏览器和 Web 服务器，限制的最大长度不一样。</p><h3 id="【误】POST-方法比-GET-方法安全"><a href="#【误】POST-方法比-GET-方法安全" class="headerlink" title="【误】POST 方法比 GET 方法安全"></a>【误】POST 方法比 GET 方法安全</h3><p>返回目录</p><p>【误】POST 比 GET 安全，是因为数据在地址栏 URL 看不见。</p><p>从传输角度来说，都是 HTTP 在网络上的明文传输，可以通过抓包工具完整获取的。</p><p>如果想安全，那就用 HTTPS 吧。</p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p><code>HTTP</code> 的 <code>keep-alive</code> 也称为 <code>HTTP</code> 长连接。</p><p>它通过重用一个 TCP 连接来发送/接收多个 HTTP 请求，来减少创建/关闭多个 TCP 连接的开销。</p><p>在 HTTP/1.0 协议中，如果请求头中包含：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>则代表开启 keep-alive，而服务端的返回报文头中，也会包含相同的内容。</p><p>在 HTTP/1.1 协议中，默认开启 keep-alive，除非显式地关闭它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>当然，除此之外我们也可以设置断开的时间等：</p><p>Keep-Alive: timeout=5, max=100<br>这个就表示这个 TCP 通道可以保持 5 秒，max=100 表示这个长连接最多接收 100 次请求就断开。</p><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><h3 id="HTTP-状态码为-3-位数，被归为-5-类："><a href="#HTTP-状态码为-3-位数，被归为-5-类：" class="headerlink" title="HTTP 状态码为 3 位数，被归为 5 类："></a>HTTP 状态码为 3 位数，被归为 5 类：</h3><p>1XX：表示目前是协议处理的中间状态，还需要后续操作。<br>2XX：表示成功状态。<br>3XX：重定向状态，资源位置发生变动，需要重新请求。<br>4XX：请求报文有误。<br>5XX：服务器端发生错误。</p><h3 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h3><ul><li>101 Switching Protocols：在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码为 101。<h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3></li><li>200 OK：请求成功状态码，响应体中含有数据。</li><li>204 No Content：含义同 200，但是响应报文不含实体的主体部分。</li><li>206 Partial Content：表示部分内容请求成功。使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段 Content-Range。<h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3></li><li>301 Move Permanently：永久重定向。HTTP 升级 HTTPS，之前站点再也不用，那就是 301。</li><li>302 Found：临时重定向。当前站点暂时不可用，那就是 302，后续可能换回来。</li><li>304 Not Modified：当命中协商缓存时会返回这个状态码。<h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3></li><li>400 Bad Request：请求无效。通常为前后端数据格式不一致或者其他原因。</li><li>403 Forbidden：服务器已经得到请求，但是拒绝执行，比如没权限、法律禁止等。</li><li>404 Not Found：资源未找到，服务器不存在对应的资源。<h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h3></li><li>500 Internal Server Error：服务器报错，有些时候可以在 Response 看到后端 PHP 等技术的报错信息等。</li><li>502 Bad Gateway：服务器正常，但是访问出错。</li><li>503 Service Unavailable：服务器繁忙或者停机维护，暂时无法处理请求。</li></ul><h2 id="解决通讯安全问题"><a href="#解决通讯安全问题" class="headerlink" title="解决通讯安全问题"></a>解决通讯安全问题</h2><ol><li>对称加密： 可以理解为对原始数据的可逆变换</li><li>非对称加密: 有两个秘钥：一个公钥、一个私钥，客户端和服务器使用的是两个不同的秘钥</li><li>对称加密 + 非对称加密： HTTPS 就是采用这种对称加密和非对称加密两者并用的混合加密机制</li><li>第三方认证： 在 HTTPS 中，为了解决无法验证公钥正确性的问题，使用数字证书认证机构（CA）及其颁发的数字证书来解决这个问题。</li><li>第三方认证安全性</li></ol><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS（Domain Name System，域名系统），最初，由于 IP 地址长且难记，通过 IP 访问网站不方便。</p><p>所以后来通过发明了 DNS 服务器，这个时候我们访问网站输入网站域名，DNS 服务器就解析我们的域名为 IP。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>查询 <a href="http://www.baidu.com/">www.baidu.com</a></li><li>访问客户端 DNS 缓存：浏览器缓存 -&gt; 系统缓存（host） -&gt; 路由器缓存</li><li>访问 ISP DNS 服务器（ISP，互联网服务提供商，有联通电信移动等。如果你是电信网络，则进入电信的 DNS 缓存服务器，以下简称本地），如果本地服务器有，则直接返回；如果没有，让本地 DNS 服务器去逐个咨询查找。</li><li>本地去咨询 DNS 根服务器，DNS 根服务器发现是 .com 区域 管理的，告诉本地去咨询它。</li><li>本地去咨询 .com 顶级域服务器，.com 域服务器告诉本地去咨询 baidu.com 主区域 的服务器。</li><li>本地去咨询 baidu.com 主域名服务器，baidu.com 域服务器查找到对应的 IP 地址，返回给本地。</li><li>本地 DNS 云服务器通知用户对方 IP 地址，同时缓存这个 IP 地址，下次就直接访问了。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;HTTP-发展史&quot;&gt;&lt;a href=&quot;#HTTP-发展史&quot; class=&quot;headerlink&quot; title=&quot;HTTP 发展史&quot;&gt;&lt;/a&gt;HTT
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://github.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://github.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="http://github.com/2021/02/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>http://github.com/2021/02/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><h3 id="Babel-原理"><a href="#Babel-原理" class="headerlink" title="Babel 原理"></a>Babel 原理</h3><p>大多数 <code>JavaScript Parser</code> 遵循 <code>estree</code> 规范，<code>Babel</code> 最初基于 <code>acorn</code> 项目（轻量级现代 <code>JavaScript</code> 解析器）</p><p><code>Babel</code> 大概分为三大部分：</p><ul><li>解析：将代码转换成 <code>AST</code><ul><li>词法分析：将代码（字符串）分割为 <code>token</code> 流，即语法单元成的数组</li><li>语法分析：分析 <code>token</code> 流（上面生成的数组）并生成 <code>AST</code></li></ul></li><li>转换：访问 <code>AST</code> 的节点进行变换操作生产新的 <code>AST</code>，<br><code>Taro</code> 就是利用 <code>babel</code> 完成的小程序语法转换</li><li>生成：以新的 <code>AST</code> 为基础生成代码</li></ul><h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><blockquote><p>抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。</p></blockquote><p>它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p><p>之所以说语法是 “抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p><h3 id="面试点"><a href="#面试点" class="headerlink" title="面试点"></a>面试点</h3><ul><li>面试官：了解过 <code>Babel</code> 吗？</li><li>俺：大概知道将 <code>ES6+</code> 代码，先通过词法分析和语法分析之后解析为 <code>AST</code>，然后将这份 <code>AST</code> 转换为我们需要形式的 <code>AST</code>，最后将这个 <code>AST</code> 再转换成 <code>ES5</code> 或者期望格式的内容。</li><li>面试官：写过 <code>Babel</code> 插件吗？</li><li>俺：没有。</li></ul><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><ul><li>是什么：本质是一个模块打包器，其工作是将每个模块打包成相应的 bundle</li><li>核心概念：mode、entry、output、loader、plugin</li><li>构建流程：初始化、编译、输出，插件（Plugin）随时监听 Webpack 广播并在某些时候调用 API 改变运行结果。</li><li>entry：指定打包⼊口⽂文件。原本是 string，即一个入口对一个打包文件、object 多对一，array 多对多</li><li>output：打包后的文件位置</li><li>loader：翻译官，对不同资源进行处理，从右向左执行</li><li>plugin：插件，扩展 Webpack 的功能，监听 Webpack 的生命周期，调用 API 改变输出结果。</li><li>resolve：配置 Webpack 如何寻找模块所对应的文件。<code>resolve.modules/extensions/include/exclude</code></li></ul><h2 id="Webpack-性能优化"><a href="#Webpack-性能优化" class="headerlink" title="Webpack 性能优化"></a>Webpack 性能优化</h2><ul><li>resolve.modules：用于配置 Webpack 去哪些目录下寻找第三方模块（node_modules）</li><li>resolve.extensions：在导入没带文件后缀的路径时，Webpack 会自动带上后缀去尝试询问文件是否存在，而 <code>resolve.extensions</code> 用于配置尝试后缀列表；默认为 <code>extensions:[&#39;js&#39;, &#39;json&#39;]</code></li><li><code>resolve.include/exclude</code>：以 <code>babel-loader</code> 为例，可以通过 include 和 exclude 帮助我们避免 node_modules 这类庞大文件夹]</li><li>缓存：<code>cache-loader</code> 和 <code>uglifyjs-webpack-plugin</code>，将编译结果写进硬盘缓存，下次文件如果没有变化则直接拉取缓存</li><li>多进程：<code>Happypack</code> 和 <code>thread-loader</code>，将任务分解成多个子进程去并发执行，提高打包效率</li><li>多进程压缩：<code>Webpack</code> 自带的 <code>UglifyJSWebpackPlugin</code> 压缩插件是单线程运行的，而 <code>TerserWebpackPlugin</code> 可以并行执行（多线程）</li><li>静态资源分离：<code>CommonsChunkPlugins</code> 每次构建都会重新构建 vendor，出于效率问题使用 DllPlugin 可以将第三方库单独打包到一个文件中，只有依赖自身发生版本变化才会重新打包</li><li>打包资源压缩：</li><li>JS 压缩：<code>UglifyJSWebpackPlugin</code> 和 <code>TerserWebpackPlugin</code></li><li>HTML 压缩：<code>HtmlWebpackPlugin</code></li><li>CSS 压缩：<code>MiniCssExtractPlugin</code></li><li>图片压缩：<code>ImageWebpackPlugin</code></li><li>Gzip 压缩：不包括图片</li><li>Tree Shaking</li><li>Scope Hoisiting</li><li>按需加载<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ul><ul><li><p><a href="https://juejin.cn/post/6844903842635579405">【面试篇】寒冬求职之你必须要懂的Web安全</a></p></li><li><p><a href="https://zoumiaojiang.com/article/common-web-security/#xss">常见 Web 安全攻防总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;Babel&quot;&gt;&lt;a href=&quot;#Babel&quot; class=&quot;headerlink&quot; title=&quot;Babel&quot;&gt;&lt;/a&gt;Babel&lt;/h2&gt;&lt;h
      
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://github.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="前端工程化" scheme="http://github.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化之Webpack</title>
    <link href="http://github.com/2021/02/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8BWebpack/"/>
    <id>http://github.com/2021/02/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8BWebpack/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="Webpack-是什么"><a href="#Webpack-是什么" class="headerlink" title="Webpack 是什么"></a>Webpack 是什么</h2><p>Webpack 是一个现代 JavaScript 应用程序的静态模块打包器（module bundler）。</p><p>当 Webpack 处理应用程序时，它会递归地构建一个依赖关系图（dependency graph），其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p><p>所以，它的本质是一个模块打包器，其工作是将每个模块打包成相应的 bundle。</p><h2 id="Webpack-核心概念"><a href="#Webpack-核心概念" class="headerlink" title="Webpack 核心概念"></a>Webpack 核心概念</h2><ul><li>mode：模式。对应有开发模式、生产模式等</li><li>entry：入口</li><li>output：出口</li><li>loader：模块转换器，用于把模块原内容按照需求转换成新内容。Webpack 对于 .jpg、.txt 等内容无法处理，就需要 file-loader、url-loader 等进行协助处理。</li><li>plugins：扩展插件，在 Webpack 构建流程中的特定时机注入拓展逻辑来改变构建结果或者做其他你想做的事情。</li></ul><h2 id="Webpack-构建流程"><a href="#Webpack-构建流程" class="headerlink" title="Webpack 构建流程"></a>Webpack 构建流程</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li><li>确定入口：根据配置中的 entry 找出所有的入口文件</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ol><p>简单来说：</p><ol><li>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler（钩子）</li><li>编译：从 Entry 出发，针对每个 Module（模块）串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li><li>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中（Chunk 就是打包过程中，入口模块引用其他模块，模块再引用模块，这个关系链连接的 Module 就形成了 Chunk）</li></ol><p>在这个过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="1-entry"><a href="#1-entry" class="headerlink" title="1.entry"></a>1.entry</h3><blockquote><p>打包入口<br>指定打包⼊口文件，有三种不同的形式：string | object | array。</p></blockquote><p>一对一：一个入口、一个打包文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多对一：多个入口、一个打包文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [</span><br><span class="line">    <span class="string">&#x27;./src/index1.js&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;./src/index2.js&#x27;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多对多：多个入口、多打包文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">&#x27;index1&#x27;</span>: <span class="string">&quot;./src/index1.js&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;index2&#x27;</span>: <span class="string">&quot;./src/index2.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-output"><a href="#2-output" class="headerlink" title="2.output"></a>2.output</h3><blockquote><p>打包后的文件输出位置。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    filename: <span class="string">&quot;[name].js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以指定一个固定的文件名称，如果是多入口多出口（entry 为对象），则不能使用单文件出口，需要使用下面的方式<br>通过 Webpack 内置的变量占位符：[name]</p><h3 id="3-loader"><a href="#3-loader" class="headerlink" title="3.loader"></a>3.loader</h3><blockquote><p>模块转换器，用于把模块原内容按照需求转换成新内容</p></blockquote><p>loader 的执行顺序是从右向左执行的，也就是后面的 loader 先执行。</p><p>假如有配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那就是先处理 less-loader，再处理 css-loader，最后处理 style-loader。</p><h4 id="常见的-loader"><a href="#常见的-loader" class="headerlink" title="常见的 loader"></a>常见的 loader</h4><ol><li><p>关于文件处理常见的 loader</p><ul><li><code>file-loader</code>：当引入的文件是 <code>.png</code>、<code>.txt</code> 等时，可以通过<code>file-loader</code> 解析项目中的 <code>url</code> 引入。根据配置将文件拷贝到相应的路径，并修改打包后文件的引入路径，让它指向正确的文件。</li><li><code>url-loader</code>：<code>url-loader</code> 封装了 <code>file-loader</code> 且可以不依赖于 <code>file-loader</code> 单独使用，并且可以配置 <code>limit</code>。对小于 <code>limit</code> 大小的图片转换成 <code>Base64</code>，大于 <code>limit</code> 的时候使用 <code>file-loader</code> 里的方法。</li></ul></li><li><p>关于语法检查常见 loader</p></li></ol><ul><li>tslint-loader：通过 TSLint 检查 TypeScript 代码</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li></ul><ol start="3"><li>关于 HTML 代码处理常见的 loader</li></ol><ul><li>html-withimg-loader：处理 HTML 中的图片</li></ul><ol start="4"><li>关于 CSS 代码处理常见的 loader</li></ol><ul><li>style-loader：动态创建 style 标签，将 CSS 代码插入到 head 中。</li><li>css-loader：负责处理 @import、url 等语句。例如 import css from ‘file.css’、url(image.png)。</li><li>postcss-loader：负责进一步处理 CSS 文件，比如添加浏览器前缀，压缩 CSS 等。</li><li>less-loader：将 .less 文件内容转换成 CSS。</li><li>sass-loader：将 .sass 文件内容转换成 CSS。</li></ul><ol start="5"><li>关于 JS 代码处理常见的 loader</li></ol><ul><li>babel-loader：将 JS 代码向低版本转换，我们需要使用 -babel-loader。</li><li>ts-loader：将 TypeScript 转换成 JavaScript</li></ul><h3 id="4-plugin"><a href="#4-plugin" class="headerlink" title="4.plugin"></a>4.plugin</h3><blockquote><p>扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情</p></blockquote><h4 id="常见-plugin"><a href="#常见-plugin" class="headerlink" title="常见 plugin"></a>常见 plugin</h4><ul><li>clean-webpack-plugin：打包前自动清理 dist 目录，防止文件残留。</li><li>copy-webpack-plugin：将单个文件或者整个目录复制到构建目录<br>mini-css-extract-plugin：将 CSS 抽离出来单独打包并且通过配置可以设置是否压缩。</li><li>html-webpack-plugin：这个插件可以配置生成一个 HTML5 文件，其中 script 标签包含所有 Webpack 包。如果你设置多个入口点，你可以据此实现多页面应用打包。<h4 id="提高效率的-plugin"><a href="#提高效率的-plugin" class="headerlink" title="提高效率的 plugin"></a>提高效率的 plugin</h4></li><li>webpack-dashboard：可以更友好的展示相关打包信息。</li><li>webpack-merge：提取公共配置，减少重复配置代码</li><li>speed-measure-webpack-plugin：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。</li><li>size-plugin：监控资源体积变化，尽早发现问题</li><li>HotModuleReplacementPlugin：模块热替换</li></ul><h4 id="loader-和-plugin-的区别"><a href="#loader-和-plugin-的区别" class="headerlink" title="loader 和 plugin 的区别"></a>loader 和 plugin 的区别</h4><ol><li><p>Loader</p><p> Loader 本质上就是一个函数，对接收到的内容进行转换，返回转换后的结果。</p><p> 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对不同类型的资源进行处理。</p><p> 就好比 file-loader 或者 url-loader，配置之后就可以正确引用 png 等格式的图片、txt 等格式文件。</p><p> 又好比 style-loader 以及 css-loader，引用后就可以对 CSS 内容进行预编译处理。</p></li><li><p>Plugin</p><p> Plugin 就是插件，就好比 编写的 VS Code 插件一样，Plugin 拓展了 Webpack 的功能。</p><p> Plugin 就是在 Webpack 的生命周期中进行各种操作，从而达到使用者目的插件。</p><p> 就好比 html-webpack-plugin，配合多入口形式使用之后，就可以实现多页面应用的功能。</p><p> 又好比 clean-webpack-plugin 实现打包之前清空 dist 目录，copy-webpack-plugin 可以将单个文件或者整个目录复制到构建目录。</p></li></ol><h3 id="5-resolve"><a href="#5-resolve" class="headerlink" title="5.resolve"></a>5.resolve</h3><blockquote><p>resolve 配置 Webpack 如何寻找模块所对应的文件。</p></blockquote><p>Webpack 内置 JavaScript 模块化语法解析功能，默认会采用模块化标准里约定好的规则去寻找，但你可以根据自己的需要修改默认的规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    modules: [<span class="string">&#x27;./src/components&#x27;</span>, <span class="string">&#x27;node_modules&#x27;</span>] <span class="comment">// 从左到右依次查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>resolve.modules：配置 Webpack 去哪些目录下寻找第三方模块，默认情况下，只会去 node_modules 下寻找，如果你在项目中某个文件夹下的模块经常被导入，不希望写很长的路径，那么就可以通过配置 resolve.modules 来简化。</li><li>resolve.alias：配置项通过别名把原导入路径映射成一个新的导入路径。</li><li>resolve.extensions：适配多端的项目中，可能会出现 .web.js, .wx.js，例如在转 Web 的项目中，我们希望首先找 .web.js，如果没有，再找 .js。extensions: [‘web.js’, ‘.js’]。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://juejin.cn/post/6844904094281236487#heading-0">「吐血整理」再来一打Webpack面试题</a></p></li><li><p><a href="https://juejin.cn/post/6844904079219490830#heading-0">带你深度解锁Webpack系列(基础篇)</a></p></li><li><p><a href="https://juejin.cn/post/6924258563862822919#heading-1">Webpack5 新特性业务落地实战</a></p></li><li><p><a href="https://juejin.cn/post/6902225969604460558#heading-0">Vite 原理分析</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;Webpack-是什么&quot;&gt;&lt;a href=&quot;#Webpack-是什么&quot; class=&quot;headerlink&quot; title=&quot;Webpack 是什么
      
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://github.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="前端工程化" scheme="http://github.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之网络安全</title>
    <link href="http://github.com/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://github.com/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><p>浏览器安全可以分为三大块：</p><ul><li>Web 页面安全</li><li>浏览器网络安全</li><li>浏览器系统安全</li></ul><p>在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。</p><p>这就引出了页面中最基础、最核心的安全策略：同源策略（Same-origin policy）。</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>所谓的同源，是指 协议、域名、端口 一致的情况下，才属于同源。</p><p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</p><h3 id="为什么需要同源策略"><a href="#为什么需要同源策略" class="headerlink" title="为什么需要同源策略"></a>为什么需要同源策略</h3><p>同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p><ol><li><p>第一个，DOM 层面</p><p> 同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p><p> 当你在 A 页面，通过 <code>&lt;a href=&quot;xxx&quot; target=&quot;_blank&quot;&gt;</code> 的形式打开 B 页面，经过下面 2 行代码可以将 A 页面的内容给隐藏掉：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pdom = opener.document;</span><br><span class="line">pdom.body.style.display = <span class="string">&quot;none&quot;</span>;</span><br></pre></td></tr></table></figure><p> 这就是同源情况下 DOM 的一个操作。</p><p> 而不同源的是无法操作的。</p></li><li><p>第二个，数据层面</p></li></ol><p>同源策略限制了不同源的站点读取当前站点的 <code>Cookie</code>、<code>IndexDB</code>、<code>LocalStorage</code> 等数据。</p><p>由于同源策略，我们依然无法通过 B 页面的 <code>opener</code> 来访问 A 页面中的 <code>Cookie</code>、<code>IndexDB</code> 或者 <code>LocalStorage</code> 等内容。</p><ol start="3"><li>第三个，网络层面<br>同源策略限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送给不同源的站点。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ol><ul><li><p><a href="https://juejin.cn/post/6844903842635579405">【面试篇】寒冬求职之你必须要懂的Web安全</a></p></li><li><p><a href="https://zoumiaojiang.com/article/common-web-security/#xss">常见 Web 安全攻防总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;浏览器安全&quot;&gt;&lt;a href=&quot;#浏览器安全&quot; class=&quot;headerlink&quot; title=&quot;浏览器安全&quot;&gt;&lt;/a&gt;浏览器安全&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://github.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://github.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript之基础篇</title>
    <link href="http://github.com/2021/02/01/TypeScript%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://github.com/2021/02/01/TypeScript%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对TS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>let isDone: boolean = false;</code></p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: number = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binaryLiteral: number = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octalLiteral: number = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: string = <span class="string">&quot;bob&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 方式1: 可以在元素类型后面接上 []，表示由此类型元素组成的一个数组</span></span><br><span class="line"><span class="keyword">let</span> list: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 方式2: 使用数组泛型，Array&lt;元素类型&gt;：</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [string, number];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当访问一个越界的元素，会使用联合类型替代</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure><h3 id="枚举（Enum）"><a href="#枚举（Enum）" class="headerlink" title="枚举（Enum）"></a>枚举（Enum）</h3><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。<br>1.数字枚举</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  NORTH,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dir: Direction = Direction.NORTH;</span><br></pre></td></tr></table></figure><p>复制代码默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。上面的枚举示例代码经过编译后会生成以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;NORTH&quot;</span>] = <span class="number">0</span>)] = <span class="string">&quot;NORTH&quot;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;SOUTH&quot;</span>] = <span class="number">1</span>)] = <span class="string">&quot;SOUTH&quot;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;EAST&quot;</span>] = <span class="number">2</span>)] = <span class="string">&quot;EAST&quot;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;WEST&quot;</span>] = <span class="number">3</span>)] = <span class="string">&quot;WEST&quot;</span>;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> dir = Direction.NORTH;</span><br></pre></td></tr></table></figure><p>当然我们也可以设置 NORTH 的初始值，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  NORTH = <span class="number">3</span>,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: any = <span class="number">4</span>;</span><br><span class="line">notSure.ifItExists(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.toFixed(); <span class="comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br></pre></td></tr></table></figure><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void。<br><br>声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p>undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和  void相似，它们的本身的类型用处不是很大</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。<br><br>当你指定了 –strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自。</p><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>never 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。<br><br>never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。<br>使用 object 类型，就可以更好的表示像 Object.create 这样的API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | null</span>): <span class="title">void</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">&#123; prop: <span class="number">0</span> &#125;</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">null</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="number">42</span></span>); // <span class="title">Error</span></span></span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。<br>类型断言有两种形式。 其一是“尖括号”语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (<span class="xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>someValue).length;</span></span><br></pre></td></tr></table></figure><p>另一个为 as 语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (someValue <span class="keyword">as</span> string).length;</span><br></pre></td></tr></table></figure><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。</p><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>联合类型使用 | 分隔每个类型。</p><p>这里的 let myFavoriteNumber: string | number 的含义是，允许 myFavoriteNumber 的类型是 string 或者 number，但是不能是其他类型。</p><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>TypeScript 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">  id: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IWorker &#123;</span><br><span class="line">  companyId: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IStaff = IPerson &amp; IWorker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> staff: IStaff = &#123;</span><br><span class="line">  id: <span class="string">&#x27;E1006&#x27;</span>,</span><br><span class="line">  age: <span class="number">33</span>,</span><br><span class="line">  companyId: <span class="string">&#x27;EFT&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(staff)</span><br></pre></td></tr></table></figure><p>在上面示例中，我们首先为 <code>IPerson</code> 和 <code>IWorker</code> 类型定义了不同的成员，然后通过 <code>&amp; </code>运算符定义了 <code>IStaff </code> 交叉类型，所以该类型同时拥有<code>IPerson</code>和 <code>IWorker </code>这两种类型的成员。</p><h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(<code>interface</code>)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person &#x3D; &#123;</span><br><span class="line">    name: &#39;Tom&#39;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接口一般首字母大写。有的编程语言中会建议接口的名称加上 I 前缀。</p><p>定义的变量比接口少了一些属性是不允许的,多一些属性也是不允许的,赋值的时候，变量的形状必须和接口的形状保持一致。</p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但仍然不允许添加未定义的属性：</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly 来指定只读属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">    readonly y: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过赋值一个对象字面量来构造一个 Point 。 赋值后， x 和 y 再也不能被改变了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1: Point = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line">p1.x = <span class="number">5</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>TypeScript 具有 ReadonlyArray<T> 类型，它与 Array<T> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;number&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，可以看到就算把整个 ReadonlyArray 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> number[];</span><br></pre></td></tr></table></figure><h3 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h3><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    gender: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>[propName: string]</code> 定义了任意属性取<code>string</code>类型的值。</p><p>需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><h3 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myAdd has the full function type</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="comment">// The parameters `x` and `y` have the type number</span></span><br><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">baseValue: number, increment: number</span>) =&gt;</span> number = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, lastName: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">&quot;Bob&quot;</span>);                  <span class="comment">// error, too few parameters</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>, <span class="string">&quot;Sr.&quot;</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>);         <span class="comment">// ah, just right</span></span><br></pre></td></tr></table></figure><p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在 TypeScript 里我们可以在参数名旁使用 ? 实现可选参数的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, lastName?: string</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>在 TypeScript 里，你可以把所有参数收集到一个变量里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, ...restOfName: string[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">&quot;Joseph&quot;</span>, <span class="string">&quot;Samuel&quot;</span>, <span class="string">&quot;Lucas&quot;</span>, <span class="string">&quot;MacKinzie&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="TypeScript-泛型"><a href="#TypeScript-泛型" class="headerlink" title="TypeScript 泛型"></a>TypeScript 泛型</h3><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。<br><br>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。<br><br>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。<br><br>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">  (arg: T): T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  zeroValue: T;</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;number&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="泛型变量"><a href="#泛型变量" class="headerlink" title="泛型变量"></a>泛型变量</h3><p>对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：</p><ul><li>T（Type）：表示一个 TypeScript 类型</li><li>K（Key）：表示对象中的键类型</li><li>V（Value）：表示对象中的值类型</li><li>E（Element）：表示元素类型</li></ul><h3 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h3><p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。</p><ol><li>typeof<br>在 TypeScript 中，typeof 操作符可以用来获取一个变量声明或对象的类型。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sem: Person = &#123; <span class="attr">name</span>: <span class="string">&#x27;semlinker&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line">type Sem= <span class="keyword">typeof</span> sem; <span class="comment">// -&gt; Person</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">x: number</span>): <span class="title">Array</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Func = <span class="keyword">typeof</span> toArray; <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br></pre></td></tr></table></figure></li><li>keyof</li></ol><p>keyof 操作符可以用来一个对象中的所有 key 值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type K1 = keyof Person; <span class="comment">// &quot;name&quot; | &quot;age&quot;</span></span><br><span class="line">type K2 = keyof Person[]; <span class="comment">// &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot; </span></span><br><span class="line">type K3 = keyof &#123; [x: string]: Person &#125;;  <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure><ol start="3"><li>in</li></ol><p>in 用来遍历枚举类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Keys = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line">type Obj =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: any</span><br><span class="line">&#125; <span class="comment">// -&gt; &#123; a: any, b: any, c: any &#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>infer</li></ol><p>在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type ReturnType&lt;T&gt; &#x3D; T extends (</span><br><span class="line">  ...args: any[]</span><br><span class="line">) &#x3D;&gt; infer R ? R : any;</span><br></pre></td></tr></table></figure><p>以上代码中 <code>infer R</code> 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。<br>5. extends</p><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ILengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error, number doesn&#x27;t have a .length property</span></span><br></pre></td></tr></table></figure><p>这时我们需要传入符合约束类型的值，必须包含必须的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(&#123;<span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><ol start="6"><li>Partial</li></ol><p><code>Partial&lt;T&gt;</code> 的作用就是将某个类型里的属性全部变为可选项 <code>?</code>。<br>定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts</span><br><span class="line"> * Make all properties in T optional</span><br><span class="line"> *&#x2F;</span><br><span class="line">type Partial&lt;T&gt; &#x3D; &#123;</span><br><span class="line">  [P in keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在以上代码中，首先通过 <code>keyof T</code> 拿到 <code>T</code> 的所有属性名，然后使用 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后通过 <code>T[P]</code> 取得相应的属性值。中间的 <code>?</code> 号，用于将所有属性变为可选。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Todo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  description: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTodo</span>(<span class="params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo1 = &#123;</span><br><span class="line">  title: <span class="string">&quot;organize desk&quot;</span>,</span><br><span class="line">  description: <span class="string">&quot;clear clutter&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo2 = updateTodo(todo1, &#123;</span><br><span class="line">  description: <span class="string">&quot;throw out trash&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的 <code>updateTodo</code> 方法中，我们利用 <code>Partial&lt;T&gt;</code> 工具类型，定义 <code>fieldsToUpdate</code> 的类型为 <code>Partial&lt;Todo&gt;</code>，<br>即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   title?: string | <span class="literal">undefined</span>;</span><br><span class="line">   description?: string | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://juejin.cn/post/6844903842635579405">【面试篇】寒冬求职之你必须要懂的Web安全</a></p></li><li><p><a href="https://zoumiaojiang.com/article/common-web-security/#xss">常见 Web 安全攻防总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对TS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;基础类型&quot;&gt;&lt;a href=&quot;#基础类型&quot; class=&quot;headerlink&quot; title=&quot;基础类型&quot;&gt;&lt;/a&gt;基础类型&lt;/h2&gt;&lt;h3 id=&quot;布
      
    
    </summary>
    
    
      <category term="TypeScript" scheme="http://github.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://github.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>JS之DOM事件流</title>
    <link href="http://github.com/2021/01/31/JS%E4%B9%8BDOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <id>http://github.com/2021/01/31/JS%E4%B9%8BDOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2021-01-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><blockquote><p>事件流描述的是从页面中接收事件的顺序</p></blockquote><p>DOM2级事件流包括下面几个阶段。</p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><h2 id="事件冒泡与事件捕获"><a href="#事件冒泡与事件捕获" class="headerlink" title="事件冒泡与事件捕获"></a>事件冒泡与事件捕获</h2><p>事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;outer&quot;</span>&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;inner&quot;</span>&gt;Click me!&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？为了解决这个问题微软和网景提出了两种几乎完全相反的概念。</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>微软(IE)提出了名为事件冒泡(event bubbling)的事件流。</p><p>事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。</p><p>因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是:</p><p>p -&gt; div -&gt; body -&gt; html -&gt; document</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>网景提出另一种事件流名为事件捕获(event capturing)。</p><p>与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。</p><p>上面的例子在事件捕获的概念下发生click事件的顺序应该是:</p><p>document -&gt; html -&gt; body -&gt; div -&gt; p</p><h3 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h3><blockquote><p>W3C 对这两种方案进行了统一：将 DOM 事件分为两个阶段，事件捕获和事件冒泡阶段</p></blockquote><p>当一个元素被点击，首先是事件捕获阶段，window 最先接收事件，然后一层一层往下捕获，最后由具体元素接收；之后再由具体元素再一层一层往上冒泡，到 window 接收事件。</p><h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h3><blockquote><p>E浏览器对addEventListener兼容性并不算太好，只有IE9以上可以使用。</p></blockquote><p><code>DOM2级事件</code>中规定的事件流同时支持了事件捕获阶段和事件冒泡阶段，而作为开发者，我们可以选择事件处理函数在哪一个阶段被调用。</p><p><code>addEventListener</code>方法用来为一个特定的元素绑定一个事件处理函数，是<code>JavaScript</code>中的常用方法。</p><blockquote><p><code>element.addEventListener(event, function, useCapture)</code></p></blockquote><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">event</td><td align="left">必须。字符串，指定事件名。<br>注意: 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。<br>提示： 所有 HTML DOM 事件，</td></tr><tr><td align="left">function</td><td align="left">必须。指定要事件触发时执行的函数。<br>当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。<br>例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。</td></tr><tr><td align="left">useCapture</td><td align="left">可选。布尔值，指定事件是否在捕获或冒泡阶段执行。<br>可能值:<br>true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）<br>false(默认值)。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）</td></tr></tbody></table><h3 id="如何让事件先冒泡后捕获"><a href="#如何让事件先冒泡后捕获" class="headerlink" title="如何让事件先冒泡后捕获"></a>如何让事件先冒泡后捕获</h3><p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。</p><h2 id="事件委托-代理"><a href="#事件委托-代理" class="headerlink" title="事件委托(代理)"></a>事件委托(代理)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</p><h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2><ol><li>给子级加 <code>event.stopPropagation( )</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#div1&quot;</span>).mousedown(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=event||<span class="built_in">window</span>.event;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>在事件处理函数中返回 <code>false</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#div1&quot;</span>).mousedown(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=e||<span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>但是这两种方式是有区别的。</li></ol><ul><li><code>return false</code> 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。</li><li><code>event.stopPropagation()</code>则只阻止事件往上冒泡，不阻止事件本身。</li></ul><p>3.  <code>event.target==event.currentTarget</code>，让触发事件的元素等于绑定事件的元素，也可以阻止事件冒泡；</p><h2 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h2><ul><li>（1）event.preventDefault( )</li><li>（2）return false</li></ul><h2 id="并不是所有的事件都有冒泡"><a href="#并不是所有的事件都有冒泡" class="headerlink" title="并不是所有的事件都有冒泡"></a>并不是所有的事件都有冒泡</h2><p>例如：</p><ul><li><code>onblur</code></li><li><code>onfocus</code></li><li><code>onmouseenter</code></li><li><code>onmouseleave</code></li></ul><h2 id="onmouseover-和-onmouseenter-区别"><a href="#onmouseover-和-onmouseenter-区别" class="headerlink" title="onmouseover 和 onmouseenter 区别"></a>onmouseover 和 onmouseenter 区别</h2><ul><li><p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</p></li><li><p>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</p></li></ul><p>这两者都是移入的时候触发，但是 onmouseover 会触发多次，而 onmouseenter 只在进去的时候才触发。</p><h2 id="JS-位置"><a href="#JS-位置" class="headerlink" title="JS 位置"></a>JS 位置</h2><ul><li><code>clientHeight</code>：表示可视区域的高度，不包含 <code>border</code> 和滚动条</li><li><code>offsetHeight</code>：表示可视区域的高度，包含了 <code>border</code> 和滚动条</li><li><code>scrollHeight</code>：表示了所有区域的高度，包含了因为滚动被隐藏的部分</li><li><code>clientTop</code>：表示边框 border 的厚度，在未指定的情况下一般为0</li><li><code>scrollTop</code>：滚动后被隐藏的高度，获取对象相对于由 <code>offsetParent </code>属性指定的父坐标（CSS 定位的元素或 body 元素）距离顶端的高度。</li></ul><h2 id="js拖拽功能的实现"><a href="#js拖拽功能的实现" class="headerlink" title="js拖拽功能的实现"></a>js拖拽功能的实现</h2><ol><li>通过 mousedown、mousemove、mouseup 方法实现</li></ol><ul><li><p>首先是三个事件，分别是mousedown，mousemove，mouseup,当鼠标点击按下的时候，需要一个tag标识此时已经按下，可以执行mousemove里面的具体方法。</p></li><li><p>clientX，clientY标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用offsetX和offsetY来表示元素的元素的初始坐标，<br><br>移动的举例应该是：<br><br>鼠标移动时候的坐标-鼠标按下去时候的坐标。<br><br>也就是说定位信息为：<br><br>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft.<br></p></li></ul><ol start="2"><li>可以通过html5的拖放（Drag 和 drop）来实现</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903834075021326#heading-0">你真的理解事件冒泡和事件捕获吗</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h2&gt;&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之从输入 URL 到页面呈现</title>
    <link href="http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0/"/>
    <id>http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0/</id>
    <published>2021-01-29T16:00:00.000Z</published>
    <updated>2021-01-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改（浏览器的工作原理）</p><h2 id="整体过程"><a href="#整体过程" class="headerlink" title="整体过程"></a>整体过程</h2><p>在用户输入 URL，按下回车之后，走过的步骤：</p><ul><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器响应</li><li>浏览器解析渲染页面</li></ul><h2 id="具体阶段"><a href="#具体阶段" class="headerlink" title="具体阶段"></a>具体阶段</h2><ul><li>用户输入阶段</li><li>发起URL请求阶段</li><li>准备渲染进程阶段</li><li>提交文档阶段</li><li>页面渲染阶段</li></ul><h2 id="用户输入阶段"><a href="#用户输入阶段" class="headerlink" title="用户输入阶段"></a>用户输入阶段</h2><ul><li>合成 URL：用户输入 URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容 + 默认搜索引擎合成新的 URL；如果用户输入的内容符合 URL 规则，浏览器就会根据 URL 协议，在这段内容上加上协议合成合法的 URL；</li><li>加载：用户输入完内容，按下回车键，浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得；</li></ul><h2 id="发起URL请求阶段"><a href="#发起URL请求阶段" class="headerlink" title="发起URL请求阶段"></a>发起URL请求阶段</h2><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/30/XovFHrwqVeN37ds.png"></p><h3 id="开始阶段"><a href="#开始阶段" class="headerlink" title="开始阶段"></a>开始阶段</h3><ol><li><p>构建请求：浏览器进程首先会构建请求行信息，然后通过进程间通信（IPC）将 URL 请求发送给网络进程；</p></li><li><p>查找缓存：网络进程获取到 URL，先去本地缓存中查找是否有缓存资源，如果有则拦截请求，直接将缓存资源返回给浏览器进程；否则，进入网络请求阶段；</p></li></ol><h3 id="网络请求阶段-从服务器获取资源"><a href="#网络请求阶段-从服务器获取资源" class="headerlink" title="网络请求阶段(从服务器获取资源)"></a>网络请求阶段(从服务器获取资源)</h3><ol><li><p><code>DNS</code> 解析：网络进程请求首先会从 <code>DNS</code> 数据缓存服务中查找是否缓存过当前域名信息，有则直接返回；否则，会进行 DNS 解析返回域名对应的 IP 和端口号，如果没有指定端口号，<code>http</code> 默认<code> 80</code> 端口，<code>https</code> 默认 <code>443</code>。如果是 <code>https</code> 请求，还需要建立 <code>TLS</code> 连接；</p></li><li><p>等待 <code>TCP</code> 队列：<code>Chrome</code> 有个机制，同一个域名同时最多只能建立 <code>6</code> 个 <code>TCP</code> 连接，如果在同一个域名下同时有 <code>10 </code>个请求发生，那么其中 <code>4</code> 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于<code>6</code>个，会直接建立 <code>TCP</code> 连接；</p></li><li><p>建立 <code>TCP</code> 连接：<code>TCP</code> 三次握手与服务器建立连接，然后进行数据的传输，最后；</p></li><li><p>发送 <code>HTTP</code> 请求：浏览器首先会向服务器发送请求行，它包含了请求方法、请求 <code>URI</code> 和 <code>HTTP</code> 协议的版本；另外还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核，请求域名、<code>Cookie</code> 等；如果需要传递参数，则还需要发送请求体；</p></li><li><p>服务器处理请求：服务器首先返回响应行，包括协议版本和状态码，比如状态码 <code>200</code> 表示继续处理该请求；（如果是 <code>301</code>，则表示重定向，将会在响应头的 <code>Locaiton</code> 字段中加上重定向的地址信息，接下来浏览器获取这个地址，将会重新导航。）服务器也会向浏览器发送响应头，包含了一些信息，比如服务器生成返回数据的时间、返回的数据类型（<code>JSON</code>、<code>HTML</code>、<code>流媒体</code>等类型），以及服务器要在客户端保存的 <code>Cookie</code> 等；继续发送响应体的数据；(服务器处理请求完毕后，会返回 HTTP 报文)</p></li><li><p>断开 <code>TCP</code> 连接：数据传输完成，正常情况下 <code>TCP</code> 将四次挥手断开连接。但是如果浏览器或者服务器在<code>HTTP</code>头部加上 <code>Connection: keep-alive</code>，<code>TCP</code> 就会一直保持连接。保持 <code>TCP</code> 连接可以省下下次需要建立连接的时间，提示资源加载速度；</p></li></ol><h2 id="准备渲染进程阶段"><a href="#准备渲染进程阶段" class="headerlink" title="准备渲染进程阶段"></a>准备渲染进程阶段</h2><blockquote><p>将获取到的数据包进行解析</p></blockquote><ol><li><p>网络进程将获取到的数据包进行解析，根据响应头中的 <code>Content-type</code> 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是 <code>text/html</code> 类型，就通知浏览器进程获取到的是 <code>HTML</code>，应该准备渲染进程了；</p></li><li><p>正常情况下每个浏览器的 <code>tab</code> 会对应一个渲染进程，但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程，否则就会创建一个新的渲染进程；</p></li></ol><h2 id="提交文档阶段"><a href="#提交文档阶段" class="headerlink" title="提交文档阶段"></a>提交文档阶段</h2><ol><li><p>渲染进程准备好后，浏览器会发出 <code>&quot;提交文档&quot;</code> 的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的 <code>&quot;管道&quot;</code>，文档数据传输完成后，渲染进程会返回<code>&quot;确认提交&quot;</code>的消息给浏览器进程；</p></li><li><p>浏览器收到 <code>&quot;确认提交&quot;</code> 的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 <code>web</code> 页面，此时的 <code>web</code> 页面是空白页；</p></li></ol><h2 id="页面渲染阶段"><a href="#页面渲染阶段" class="headerlink" title="页面渲染阶段"></a>页面渲染阶段</h2><ol><li><p>文档一旦提交，渲染进程将开始页面解析和子资源加载；渲染阶段比较复杂，所以将分为多个子阶段，按照渲染的时间顺序可以分为：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成；</p></li><li><p>构建 DOM 树：HTML 经过解析器后输出一个以 document 为顶层节点的树状结构的 DOM；</p></li><li><p>样式计算：这里有 3 个步骤：</p><ul><li>将 3 个来源（<code>&lt;link&gt;</code> 标签引入的外部样式、<code>&lt;style&gt;</code> 标签里定义的样式、以及元素的 <code>style</code> 属性上的样式）的 <code>CSS</code> 转化成浏览器能够理解的结构 <code>styleSheets</code>；</li><li>转换样式表中的属性值，使其标准化；比如 <code>font-weight: bold</code>; 会转成 <code>font-weight: 700</code>;， <code>color: blue</code>; 会转成 <code>color: rgb(0, 0, 255)</code>; 等；</li><li>依据 <code>CSS</code> 的继承和层叠规则计算出 <code>DOM</code> 树中每个节点的具体样式；</li></ul></li><li><p>布局阶段：<code>DOM</code> 树中依然存在许多不可见的元素（比如 <code>head</code>），这些元素对于布局是丝毫没用的，所以又会生成一棵只包含可见元素的布局树；然后再根据布局树的每个节点计算出其具体位置和尺寸大小；</p></li><li><p>分层：页面中有很多复杂的效果，如一些复杂的 <code>3D</code> 变换、页面滚动，或者使用 <code>z-index</code> 做 <code>z</code> 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树；关于层叠上下文的知识，具体可以参考这里彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、<code>z-index</code>；</p></li><li><p>绘制：为每个图层生成绘制列表，并将其提交到合成线程；</p></li><li><p>光栅化：通常一个页面很大，而视口很局限，所以合成线程会按照视口附近的图块来优先生成位图，并在光栅化线程池中将图块转换成位图；</p></li><li><p>合成：一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令 <code>DrawQuad</code>，然后将该命令提交给浏览器进程；之后浏览器将开始生成显示页面。</p></li></ol><h2 id="渲染过程（此为面试回答）"><a href="#渲染过程（此为面试回答）" class="headerlink" title="渲染过程（此为面试回答）"></a>渲染过程（此为面试回答）</h2><h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><ul><li>解析 <code>HTML</code>，生成 <code>DOM</code> 树</li><li>解析 <code>CSS</code>，生成 <code>CSS</code> 规则树（<code>CSS Rule Tree</code>）</li><li>将 <code>DOM Tree</code> 和 <code>CSS Rule Tree</code> 相结合，生成 渲染树（<code>Render Tree</code>）</li><li>从根节点开始，计算每一个元素的大小、位置，给出每个节点所应该出现的屏幕精确坐标，(计算每个节点的位置)从而得到基于渲染树的 布局渲染树（<code>Layout of the render tree</code>）。</li><li>遍历渲染树，将每个节点用 <code>UI</code> 渲染引擎来绘制，从而将整棵树绘制到页面上，这个步骤叫 绘制渲染树（<code>Painting the render tree</code>）(调用 GPU 绘制，合成图层，显示在屏幕上)</li></ul><h3 id="在解析渲染过程中，可能会产生-回流-和-重绘："><a href="#在解析渲染过程中，可能会产生-回流-和-重绘：" class="headerlink" title="在解析渲染过程中，可能会产生 回流 和 重绘："></a>在解析渲染过程中，可能会产生 回流 和 重绘：</h3><ul><li><p>重绘(repaint)：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此损耗较少。</p></li><li><p>回流(reflow)：又叫重排（layout）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。</p></li></ul><h3 id="渲染过程碰到-JS-文件"><a href="#渲染过程碰到-JS-文件" class="headerlink" title="渲染过程碰到 JS 文件"></a>渲染过程碰到 JS 文件</h3><blockquote><p>JavaScript 的加载、解析和执行会阻塞 DOM 的构建。</p></blockquote><p>在构建 <code>DOM</code> 的时候，<code>HTML</code> 解析器如果碰到 <code>JavaScript</code>，那么就会停止构建 <code>DOM</code>，将控制权交给 <code>JavaScript</code> 引擎，等 <code>JavaScript</code> 运行完毕，浏览器再从中断的地方恢复 <code>DOM</code> 构建。</p><p>也就是说：首屏渲染越快，就越不应该在首屏的时候加载 JS 文件，这也就是建议将 script 标签放到 body 标签底部，或者给 script 标签添加 defer/async 属性的原因。</p><h3 id="为什么操作-DOM-慢"><a href="#为什么操作-DOM-慢" class="headerlink" title="为什么操作 DOM 慢"></a>为什么操作 DOM 慢</h3><ol><li>涉及 JS 引擎和渲染引擎两个线程间的通信，损耗性能。</li><li>操作 DOM 可能会重复回流，加剧性能损耗。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6909258409250553869">「面试常问」从输入 URL 到显示发生了什么（ 99 分答案）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改（浏览器的工作原理）&lt;/p&gt;
&lt;h2 id=&quot;整体过程&quot;&gt;&lt;a href=&quot;#整体过程&quot; class=&quot;headerlink&quot; title=&quot;整体过程&quot;&gt;&lt;/a&gt;整体过程&lt;/h
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之从重绘和重排</title>
    <link href="http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/"/>
    <id>http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/</id>
    <published>2021-01-29T16:00:00.000Z</published>
    <updated>2021-01-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><blockquote><p>回流必将引起重绘，重绘不一定会引起回流</p></blockquote><h2 id="浏览器的渲染"><a href="#浏览器的渲染" class="headerlink" title="浏览器的渲染"></a>浏览器的渲染</h2><ol><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display:将像素发送给GPU，展示在页面上。</li></ol><h2 id="回流-Reflow-重绘"><a href="#回流-Reflow-重绘" class="headerlink" title="回流 (Reflow)(重绘)"></a>回流 (Reflow)(重绘)</h2><p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p><h3 id="会导致回流的操作："><a href="#会导致回流的操作：" class="headerlink" title="会导致回流的操作："></a>会导致回流的操作：</h3><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除可见的DOM元素</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法</li></ul><h3 id="一些常用且会导致回流的属性和方法："><a href="#一些常用且会导致回流的属性和方法：" class="headerlink" title="一些常用且会导致回流的属性和方法："></a>一些常用且会导致回流的属性和方法：</h3><ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>scrollIntoView()、scrollIntoViewIfNeeded()</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li><li>scrollTo()</li></ul><h2 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘 (Repaint)"></a>重绘 (Repaint)</h2><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><h3 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h3><p>回流比重绘的代价要更高。</p><p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</p><p>现代浏览器会对频繁的回流或重绘操作进行优化：</p><p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p><p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p><ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>width、height</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li></ul><p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p><h3 id="如何触发重绘？"><a href="#如何触发重绘？" class="headerlink" title="如何触发重绘？"></a>如何触发重绘？</h3><ul><li>修改背景色、颜色（background、color）</li><li>设置可见度（visibility）</li><li>设置背景图（background-image）</li></ul><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><p>CSS</p><ul><li>避免使用table布局。</li><li>尽可能在DOM树的最末端改变class。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到position属性为absolute或fixed的元素上。</li><li>避免使用CSS表达式（例如：calc()）。</li></ul><p>JavaScript</p><ul><li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li><li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li><li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><h2 id="减少重绘和回流的细节："><a href="#减少重绘和回流的细节：" class="headerlink" title="减少重绘和回流的细节："></a>减少重绘和回流的细节：</h2><ol><li>使用 translate 替代 top</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>尽量算出结果再去重绘把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame  Load 和 DOMContentLoaded 区别。Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000017329980">你真的了解回流和重绘吗</a></li><li><a href="https://juejin.cn/post/6844903569087266823">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></li><li><a href="https://juejin.cn/post/6844903569087266823">回流与重绘：CSS性能让JavaScript变慢？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;回流必将引起重绘，重绘不一定会引起回流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;浏览器的渲染&quot;&gt;&lt;a href=&quot;#浏览器
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之本地存储</title>
    <link href="http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <id>http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</id>
    <published>2021-01-27T16:00:00.000Z</published>
    <updated>2021-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="HTTP无状态"><a href="#HTTP无状态" class="headerlink" title="HTTP无状态"></a>HTTP无状态</h2><blockquote><p>HTTP无状态协议，是指协议对于交互性场景没有记忆能力。</p></blockquote><p><code>HTTP</code> 是无状态的，即它不会记住用户的操作，服务器单纯从网络连接上无从知道客户身份, 这让我们在记住用户状态等场景被限制</p><p>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。</p><p>比如服务器不知道某个用户是否已登录过了。因为愚蠢的服务器不知道客户端是否已登录过了,所以每次都要在交互场景(会话)中请求中带上上一次的请求信息，如账号、密码。明明只需要在<code>/login</code>接口中，才需要对比数据库中的账号密码和客户端传的是否一致来确定合法性。这下在添加购物车中也需要再一次的进行同样的重复且没有必要的操作，即降低了响应速度，又对用户不友好（因为每次都需要填账号，密码）。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><code>Cookie</code> 最开始被设计出来其实并不是来做本地存储的，而是为了弥补 <code>HTTP</code> 在状态管理上的不足。</p><p><code>Cookie</code> 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。</p><p>向同一个域名下发送请求，都会携带相同的 <code>Cookie</code>，服务器拿到 <code>Cookie</code> 进行解析，便能拿到客户端的状态。</p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol><li><p>A: 首先，客户端会发送一个<code>http</code>请求到服务器端。</p></li><li><p>B: 服务器端接受客户端请求后，发送一个<code>http</code>响应到客户端，这个响应头，其中就包含<code>Set-Cookie</code>头部。</p></li><li><p>C: 在客户端发起的第二次请求（注意：如果服务器需要我们带上<code>Cookie</code>，我们就需要在B步骤上面拿到这个<code>Cookie</code>然后作为请求头一起发起第二次请求），提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了<code>cookies</code>。尽管，用户可能在和应用程序交互的过程中突然禁用<code>cookies</code>的使用，但是，这个情况基本是不太可能发生的，所以可以不加以考虑，这在实践中也被证明是对的。</p></li></ol><h3 id="Cookie的不可跨域名性"><a href="#Cookie的不可跨域名性" class="headerlink" title="Cookie的不可跨域名性"></a>Cookie的不可跨域名性</h3><p><code>Cookie</code>具有不可跨域名性。根据<code>Cookie</code>规范，浏览器访问<code>Google</code>只会携带<code>Google</code>的<code>Cookie</code>，而不会携带<code>Baidu</code>的<code>Cookie</code>。<code>Google</code>也只能操作<code>Google</code>的<code>Cookie</code>，而不能操作<code>Baidu</code>的<code>Cookie</code>。</p><p><code>Cookie</code>在客户端是由浏览器来管理的。浏览器能够保证<code>Google</code>只会操作<code>Google</code>的<code>Cookie</code>而不会操作<code>Baidu</code>的<code>Cookie</code>，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站<code>Cookie</code>的依据是域名。<code>Google</code>与<code>Baidu</code>的域名不一样，因此<code>Google</code>不能操作<code>Baidu</code>的<code>Cookie</code>。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>cookie, 如果不设置过期时间，cookie保存在内存中，生命周期随浏览器的关闭而结束，如果设置了过期时间，cookie保存在硬盘中，关闭浏览器，cookie数据直到过期时间而消失；cookie是服务器发给客户端的特殊信息，cookie是以文本的形式保存在客户端，每次请求都会带上它；</p><h3 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h3><ul><li>容量缺陷。体积上线 4kb，只能存储少量信息。用户禁用cookie,就会使其功能受限</li><li>性能缺陷。Cookie 请求每次都会携带上完整的 Cookie，随着请求数增多，造成性能浪费。</li><li>安全缺陷。以纯文本的形式在浏览器和服务器中传递，容易被非法截获和篡改。</li></ul><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><h3 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h3><p><code>Local Storge</code> 相对 <code>Cookie</code> 而言，它也是针对同一个域名。<br>同一个域名下，会存储相同的一段 <code>Local Storage</code>。</p><h4 id="设置与取值"><a href="#设置与取值" class="headerlink" title="设置与取值"></a>设置与取值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置：</span></span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jsliang&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;jsliang&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&quot;info&quot;</span>, <span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值：</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> info = <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;info&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="相比-Cookie-优势"><a href="#相比-Cookie-优势" class="headerlink" title="相比 Cookie 优势"></a>相比 Cookie 优势</h4><ol><li>容量。体积上线 <code>5M</code>，大于 <code>Cookie</code> 的 <code>4kb</code>。</li><li>只存在客户端。不参与和服务端的通讯，避免 <code>Cookie</code> 的性能缺陷和安全缺陷。</li><li>接口封装。有 <code>setItem</code> 和 <code>getItem</code> 两个<code>API</code>接口。</li></ol><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ol><li>以 <code>Base64</code> 方式存储官方 <code>Logo</code> 等图片。</li></ol><h3 id="Session-Storage"><a href="#Session-Storage" class="headerlink" title="Session Storage"></a>Session Storage</h3><p>基本上和 <code>Local Stoarge</code> 一致。</p><h4 id="相比Local-Storage："><a href="#相比Local-Storage：" class="headerlink" title="相比Local Storage："></a>相比Local Storage：</h4><p>会话级别的存储。不同于 <code>Local Storage</code> 的持续化存储，<code>Session Storage</code> 当页面关闭的时候就不复存在了。</p><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><ol><li><p>对表单信息做维护。用户刷新页面不丢失。</p></li><li><p>存储本次浏览记录。看过的页面不怕找不到。</p><h3 id="localStorage和sessionStorage："><a href="#localStorage和sessionStorage：" class="headerlink" title="localStorage和sessionStorage："></a>localStorage和sessionStorage：</h3></li><li><p>生命周期：localStorage的生命周期是永久的，关闭页面也不会消失，除非是主动删除；sessionStorage的生命周期是仅在当前会话下有效</p></li><li><p>存储大小：localStorage和sessionStorage的存储数据一般都是5mb;</p></li><li><p>存储内容类型：都只能存储字符串类型；</p></li><li><p>获取方式：localStorage: window.localStorage; sessionStorage: window.sessionStorage;</p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexedDB 是运行在浏览器中的 非关系型数据库。</p></li></ol><p>因为本质上是数据库，所以一般来说容量是没有上线的。</p><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token只能被保存在客户端的cookie或localstorage中，因为用户的状态在服务端的内存中是不能存储的，所以这是一种无状态的认证机制；</p><h3 id="为什么需要token"><a href="#为什么需要token" class="headerlink" title="为什么需要token"></a>为什么需要token</h3><p>众所周知，HTTP 是无状态协议，即它对于交互性场景没有记忆能力。</p><p>但是，如果碰到某些场景，就有点无奈了：</p><ul><li>输入账号密码进行登录</li><li>将商品加入购物车</li><li>点击支付，发现用户要重新登录</li></ul><p>我们可以通过 token 来维持用户的登录态</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><blockquote><p>用户 id + 过期时间 + SecretKey</p></blockquote><p><code>&quot;用户 id&quot; + &quot;过期时间&quot; + SHA1(&quot;用户 id&quot; + &quot;用户口令&quot; + &quot;过期时间&quot; + &quot;SecretKey&quot;)</code></p><p>这样，当浏览器发送请求给服务器，token 会通过 cookie 等形式将上面实例内容传输给服务器。</p><p>服务器拿到数据后，根据用户 id 查找用户口令，并进一步计算是否已过期，从而判断用户是否需要重新登录。</p><p>需要重新登录则跳转到登录页面，不需要重新登录则进行支付流程。</p><h4 id="token认证流程"><a href="#token认证流程" class="headerlink" title="token认证流程"></a>token认证流程</h4><ol><li>用户登录校验，校验成功后就返回<code>Token</code>给客户端;</li><li>客户端收到数据后就保存在客户端;</li><li>客户端每次访问<code>api</code>就携带<code>Token</code>到服务端 ;</li><li>服务端采用<code>filter</code>过滤器校验，校验成功后返回请求数据，校验失败则返回校验码；<h4 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h4></li></ol><p>A：当用户首次登录成功（注册也是一种可以适用的场景）之后, 服务器端就会生成一个token值，这个值，会在服务器保存token值(保存在数据库中)，再将这个token值返回给客户端。</p><p>B：客户端拿到token值之后,进行本地保存（SP存储是大家能够比较支持和易于理解操作的存储）。</p><p>C：当客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个token值附带到参数中发送给服务器。</p><p>D：服务器接收到客户端的请求之后,会取出token值与保存在本地(数据库)中的token值做对比:</p><ul><li>对比一：如果两个 token 值相同， 说明用户登录成功过!当前用户处于登录状态！</li><li>对比二：如果没有这个 token 值, 则说明没有登录成功。</li><li>对比三：如果 token 值不同: 说明原来的登录信息已经失效,让用户重新登录。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ul><ul><li><a href="https://blog.csdn.net/qq_36632174/article/details/102402203">cookie、Session、Token、sessionStorage、localStorage简介</a></li><li><a href="https://blog.csdn.net/yinge0508/article/details/95761173">session,cookie,sessionStorage,localStorage,token的区别？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;HTTP无状态&quot;&gt;&lt;a href=&quot;#HTTP无状态&quot; class=&quot;headerlink&quot; title=&quot;HTTP无状态&quot;&gt;&lt;/a&gt;HTTP无状态&lt;
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之跨域</title>
    <link href="http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E8%B7%A8%E5%9F%9F/"/>
    <id>http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E8%B7%A8%E5%9F%9F/</id>
    <published>2021-01-27T16:00:00.000Z</published>
    <updated>2021-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><blockquote><p>所谓 源，可以指 URL。</p></blockquote><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>简单来看某个 URL 组成；</p><p><code>https://lonelyzou.github.io/longin</code></p><ul><li>名称    举例</li><li>协议    <code>http</code>、<code>https</code></li><li>域名    <code>lonelyzou.github.io</code></li><li>端口    80、443</li><li>其中，如果 URL 上未标明端口，那么 http 默认是 80 端口，https 默认是 443 端口。</li></ul><p>而所谓的同源策略，是指这 3 个（协议、域名、端口）一致的情况下，才属于同源。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>对于下面的 URL，我们判断下哪些属于同源哪些属于不同源：</p><ul><li><a href="https://github.com/LiangJunrong/document-library">https://github.com/LiangJunrong/document-library</a><table><thead><tr><th align="left">URL</th><th align="left">是否同源</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left"><a href="http://github.com/">http://github.com</a></td><td align="left">否</td><td align="left">协议不同</td></tr><tr><td align="left"><a href="https://github2.com/">https://github2.com</a></td><td align="left">否</td><td align="left">域名不同</td></tr><tr><td align="left"><a href="https://github.com:80/LiangJunrong">https://github.com:80/LiangJunrong</a></td><td align="left">否</td><td align="left">https 默认端口为 443</td></tr><tr><td align="left"><a href="https://money.github.com/">https://money.github.com</a></td><td align="left">是</td><td align="left">多级域名和主域名一致</td></tr></tbody></table></li></ul><p>在上面，如果两个页面对应的地址不同源，那么浏览器就会判定跨域，从而导致下面问题：</p><ul><li>Ajax 请求不能发送</li><li>无法获取 DOM 元素并进行操作</li><li>无法读取 Cookie、LocalStorage 和 IndexDB<blockquote><p>有些请求是不受到跨域限制。例如：WebSocket，script、img、iframe、video、audio标签的src属性等。</p></blockquote><h3 id="出于怎样的考虑，浏览器才要设置跨域？"><a href="#出于怎样的考虑，浏览器才要设置跨域？" class="headerlink" title="出于怎样的考虑，浏览器才要设置跨域？"></a>出于怎样的考虑，浏览器才要设置跨域？</h3></li></ul><ol><li><p>首先，跨域只存在于浏览器端，因为我们知道浏览器的形态是很开放的，所以我们需要对它有所限制。</p></li><li><p>其次，同源策略主要是为了保证用户信息的安全，可分为两种：Ajax 同源策略和 DOM 同源策略。</p></li><li><p>Ajax 同源策略主要是使得不同源的页面不能获取 Cookie 且不能发起 Ajax 请求，这样在一定层度上防止了 CSRF 攻击。</p></li><li><p>DOM 同源策略也一样，它限制了不同源页面不能获取 DOM，这样可以防止一些恶意网站在自己的网站中利用 iframe 嵌入正规的网站并迷惑用户，以此来达到窃取用户信息。</p></li></ol><h3 id="实际开发场景为什么会出现跨域："><a href="#实际开发场景为什么会出现跨域：" class="headerlink" title="实际开发场景为什么会出现跨域："></a>实际开发场景为什么会出现跨域：</h3><ul><li>前后端部署的机子，不属于同一台云服务器。</li><li>同一台云服务器，但是你在 <a href="https://github.com/">https://github.com</a> 请求的是 <a href="https://github2.com/">https://github2.com</a> 上的资源。</li></ul><h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><ol><li>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</li><li>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。</li><li>这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？</li></ol><p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p><h2 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h2><h3 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1.jsonp"></a>1.jsonp</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 <code>JSON </code>数据。<code>JSONP</code>请求一定需要对方的服务器做支持才可以。</p><h4 id="JSONP和AJAX对比"><a href="#JSONP和AJAX对比" class="headerlink" title="JSONP和AJAX对比"></a><code>JSONP</code>和<code>AJAX</code>对比</h4><p><code>JSONP</code>和<code>AJAX</code>相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但<code>AJAX</code>属于同源策略，<code>JSONP</code>属于非同源策略（跨域请求)</p><h4 id="JSONP优缺点"><a href="#JSONP优缺点" class="headerlink" title="JSONP优缺点"></a>JSONP优缺点</h4><ul><li>优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</li><li>缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</li></ul><h3 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2.CORS"></a>2.CORS</h3><h4 id="CORS-跨域的原理。"><a href="#CORS-跨域的原理。" class="headerlink" title="CORS 跨域的原理。"></a>CORS 跨域的原理。</h4><p>跨域资源共享（CORS）是一种机制，是 W3C 标准。它允许浏览器向跨源服务器，发出 XMLHttpRequest 或 Fetch 请求。并且整个 CORS 通信过程都是浏览器自动完成的，不需要用户参与。</p><p>而使用这种跨域资源共享的前提是，浏览器必须支持这个功能，并且服务器端也必须同意这种 “跨域” 请求。因此实现 CORS 的关键是服务器需要服务器。</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。</p><p>该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><h4 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h4><p>当你使用 IE&lt;=9, Opera&lt;12, or Firefox&lt;3.5 或者更加老的浏览器，这个时候请使用 JSONP</p><h4 id="CORS方法优点-amp-缺点："><a href="#CORS方法优点-amp-缺点：" class="headerlink" title="CORS方法优点&amp;缺点："></a>CORS方法优点&amp;缺点：</h4><p>优点</p><ul><li>简单，几乎不需要什么开发量，只需要简单配置相应的请求与响应头信息即可。</li><li>支持各种类型的请求（get, post, put等等）。</li></ul><p>缺点</p><ul><li>需要对跨域的服务接口进行一定的改造。如果该服务因为某些原因无法改造，则无法实现。但这种改造还是相对较小的。</li><li>不兼容一些“古董”浏览器。</li></ul><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。</p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>不会触发 CORS 预检请求。这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：</p><ol><li>情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)</li></ol><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><ol start="2"><li>情况二: 人为设置以下集合外的请求头</li></ol><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code> （需要注意额外的限制）</li><li><code>DPR</code></li><li><code>Downlink</code></li><li><code>Save-Data</code></li><li><code>Viewport-Width</code></li><li><code>Width</code></li></ul><ol start="3"><li>情况三：<code>Content-Type</code>的值仅限于下列三者之一：(例如 <code>application/json </code>为非简单请求)</li></ol><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><ol start="4"><li><p>情况四:<br>请求中的任意<code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；<code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。</p></li><li><p>情况五:<br>请求中没有使用 ReadableStream 对象。</p></li></ol><h3 id="3-postMessage"><a href="#3-postMessage" class="headerlink" title="3.postMessage"></a>3.postMessage</h3><blockquote><p>postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一。</p></blockquote><p>它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的 iframe 消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>postMessage() 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><blockquote><p><code>otherWindow.postMessage(message, targetOrigin, [transfer])</code>;</p></blockquote><ul><li>message: 将要发送到其他 window的数据。</li><li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><h4 id="案列"><a href="#案列" class="headerlink" title="案列"></a>案列</h4><p>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递<code>“我爱你”</code>,然后后者传回<code>&quot;我不爱你&quot;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.html</span><br><span class="line">  &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;b.html&quot; frameborder&#x3D;&quot;0&quot; id&#x3D;&quot;frame&quot; onload&#x3D;&quot;load()&quot;&gt;&lt;&#x2F;iframe&gt; &#x2F;&#x2F;等它加载完触发一个事件</span><br><span class="line">  &#x2F;&#x2F;内嵌在http:&#x2F;&#x2F;localhost:3000&#x2F;a.html</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      function load() &#123;</span><br><span class="line">        let frame &#x3D; document.getElementById(&#39;frame&#39;)</span><br><span class="line">        frame.contentWindow.postMessage(&#39;我爱你&#39;, &#39;http:&#x2F;&#x2F;localhost:4000&#39;) &#x2F;&#x2F;发送数据</span><br><span class="line">        window.onmessage &#x3D; function(e) &#123; &#x2F;&#x2F;接受返回数据</span><br><span class="line">          console.log(e.data) &#x2F;&#x2F;我不爱你</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; b.html</span><br><span class="line">  window.onmessage &#x3D; function(e) &#123;</span><br><span class="line">    console.log(e.data) &#x2F;&#x2F;我爱你</span><br><span class="line">    e.source.postMessage(&#39;我不爱你&#39;, e.origin)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4.WebSocket"></a>4.WebSocket</h3><p>WebSocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。</p><p>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。</p><p>简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。</p><p>这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>前端部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  </span><br><span class="line">  <span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:8080&quot;</span>);socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">   socket.send(<span class="string">&quot;秋风的笔记&quot;</span>);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(e.data);  </span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>后端部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&quot;ws&quot;</span>);<span class="keyword">const</span> server = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);server.on(<span class="string">&quot;connection&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;  </span><br><span class="line">  socket.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;    </span><br><span class="line">    socket.send(data);  </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-Node-正向代理"><a href="#5-Node-正向代理" class="headerlink" title="5.Node 正向代理"></a>5.Node 正向代理</h3><blockquote><p>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</p></blockquote><p>代理服务器实现步骤：</p><ul><li>接受客户端请求 。</li><li>将请求 转发给服务器。</li><li>拿到服务器 响应 数据。</li><li>将 响应 转发给客户端。</li></ul><h4 id="cli-工具中的代理"><a href="#cli-工具中的代理" class="headerlink" title="cli 工具中的代理"></a>cli 工具中的代理</h4><ol><li>Webpack (4.x)<br>在webpack中可以配置proxy来快速获得接口代理的能力。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">  entry: &#123;    <span class="attr">index</span>: <span class="string">&quot;./index.js&quot;</span>  &#125;,  </span><br><span class="line">  output: &#123;    </span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,    </span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>)  </span><br><span class="line">  &#125;,  </span><br><span class="line">  devServer: &#123;    </span><br><span class="line">    port: <span class="number">8000</span>,    </span><br><span class="line">    proxy: &#123;      </span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;        </span><br><span class="line">        target: <span class="string">&quot;http://localhost:8080&quot;</span>      </span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  plugins: [    </span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;     </span><br><span class="line">       filename: <span class="string">&quot;index.html&quot;</span>,      </span><br><span class="line">      template: <span class="string">&quot;webpack.html&quot;</span>    </span><br><span class="line">    &#125;)  </span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>修改前端接口请求方式，改为不带域名。（因为现在是同域请求了）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;getlist&quot;</span>&gt;获取列表&lt;button&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;login&quot;</span>&gt;登录&lt;/button&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;  </span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;  </span><br><span class="line">getlist.onclick = <span class="function">() =&gt;</span> &#123;    </span><br><span class="line">  axios.get(<span class="string">&quot;/api/corslist&quot;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;      </span><br><span class="line">    <span class="built_in">console</span>.log(res.data);    </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;;  </span><br><span class="line">login.onclick = <span class="function">() =&gt;</span> &#123;    axios.post(<span class="string">&quot;/api/login&quot;</span>);  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>Vue-cli 2.x<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/index.js</span></span><br><span class="line">...proxyTable: &#123;  <span class="string">&#x27;/api&#x27;</span>: &#123;     <span class="attr">target</span>: <span class="string">&#x27;http://localhost:8080&#x27;</span>,  &#125;&#125;,</span><br><span class="line">..</span><br></pre></td></tr></table></figure></li><li>Vue-cli 3.x<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js 如果没有就新建</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">  devServer: &#123;    </span><br><span class="line">    port: <span class="number">8000</span>,    </span><br><span class="line">    proxy: &#123;      </span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;        </span><br><span class="line">        target: <span class="string">&quot;http://localhost:8080&quot;</span>      </span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li>Parcel (2.x)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .proxyrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;http://localhost:8080&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="charles"><a href="#charles" class="headerlink" title="charles"></a>charles</h4>这是一个测试、开发的神器。<a href="https://juejin.cn/post/6844903665304600589">介绍与使用</a></li></ol><p>利用 charles 进行跨域，本质就是请求的拦截与代理。</p><p>在 tools/map remote 中设置代理</p><h3 id="6-Nginx-反向代理"><a href="#6-Nginx-反向代理" class="headerlink" title="6.Nginx 反向代理"></a>6.Nginx 反向代理</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。<br>只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>先下载nginx，然后将nginx目录下的nginx.conf修改如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass   http:&#x2F;&#x2F;www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http:&#x2F;&#x2F;www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过命令行nginx -s reload启动nginx</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 向前台写cookie</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>   <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="7-window-name-iframe"><a href="#7-window-name-iframe" class="headerlink" title="7.window.name + iframe"></a>7.window.name + iframe</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。<br>其中<code>a.html</code>和<code>b.html</code>是同域的，都是<code>http://localhost:3000;而c.html是http://localhost:4000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html(http://localhost:3000/b.html)</span></span><br><span class="line"> &lt;iframe src=<span class="string">&quot;http://localhost:4000/c.html&quot;</span> frameborder=<span class="string">&quot;0&quot;</span> onload=<span class="string">&quot;load()&quot;</span> id=<span class="string">&quot;iframe&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="keyword">let</span> first = <span class="literal">true</span></span><br><span class="line">   <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(first)&#123;</span><br><span class="line">     <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">       <span class="keyword">let</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">       iframe.src = <span class="string">&#x27;http://localhost:3000/b.html&#x27;</span>;</span><br><span class="line">       first = <span class="literal">false</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span><br><span class="line">       <span class="built_in">console</span>.log(iframe.contentWindow.name);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>b.html为中间代理页，与a.html同域，内容为空。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.html(http://localhost:4000/c.html)</span></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="built_in">window</span>.name = <span class="string">&#x27;我不爱你&#x27;</span></span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="8-location-hash-iframe"><a href="#8-location-hash-iframe" class="headerlink" title="8. location.hash +  iframe"></a>8. location.hash +  iframe</h3><p>实现原理： <code>a.html</code>欲与<code>c.html</code>跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用<code>iframe</code>的<code>location.hash</code>传值，相同域之间直接js访问来通信。<br>具体实现步骤：一开始<code>a.html</code>给<code>c.html</code>传一个<code>hash</code>值，然后<code>c.html</code>收到<code>hash</code>值后，再把<code>hash</code>值传递给<code>b.html</code>，最后<code>b.html</code>将结果放到<code>a.html</code>的<code>hash</code>值中。<br>同样的，<code>a.html</code>和<code>b.html</code>是同域的，都是<code>http://localhost:3000</code>;而<code>c.html</code>是<code>http://localhost:4000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html</span></span><br><span class="line"> &lt;iframe src=<span class="string">&quot;http://localhost:4000/c.html#iloveyou&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//检测hash的变化</span></span><br><span class="line">     <span class="built_in">console</span>.log(location.hash);</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.html</span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.parent.parent.location.hash = location.hash </span><br><span class="line">    <span class="comment">//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span></span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.html</span></span><br><span class="line"> <span class="built_in">console</span>.log(location.hash);</span><br><span class="line">  <span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">  iframe.src = <span class="string">&#x27;http://localhost:3000/b.html#idontloveyou&#x27;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(iframe);</span><br></pre></td></tr></table></figure><h3 id="9-document-domain-iframe"><a href="#9-document-domain-iframe" class="headerlink" title="9.document.domain + iframe"></a>9.document.domain + iframe</h3><p>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。<br>只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。<br>实现原理：两个页面都通过js强制设置<code>document.domain</code>为基础主域，就实现了同域。<br>我们看个例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中<code>a</code>的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line"> helloa</span><br><span class="line">  &lt;iframe src=<span class="string">&quot;http://b.zf1.cn:3000/b.html&quot;</span> frameborder=<span class="string">&quot;0&quot;</span> onload=<span class="string">&quot;load()&quot;</span> id=<span class="string">&quot;frame&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="built_in">document</span>.domain = <span class="string">&#x27;zf1.cn&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(frame.contentWindow.a);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.html</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">   hellob</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">     <span class="built_in">document</span>.domain = <span class="string">&#x27;zf1.cn&#x27;</span></span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h2 id="正向代理与反向代理比较"><a href="#正向代理与反向代理比较" class="headerlink" title="正向代理与反向代理比较"></a>正向代理与反向代理比较</h2><p>从用途上来讲：</p><ul><li>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。</li><li>反向代理的典型用途是为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。</li></ul><p>从安全性来讲：</p><ul><li>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。</li><li>反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</li></ul><p>从使用方来看：</p><ul><li>正向代理是浏览器端进行配置的，与服务器端无关，甚至可以对服务端隐藏。</li><li>反向代理是服务器端配置的，对浏览器端是透明的。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ul><ol><li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li><li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li><li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li><li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903767226351623">九种跨域方式实现原理（完整版）</a></li><li><a href="https://juejin.cn/post/6844904148022870023#heading-0">面试题：nginx有配置过吗?反向代理知道吗?</a></li><li><a href="https://juejin.cn/post/6844904126246027278#heading-0">10种跨域解决方案（附终极大招）</a></li><li><a href="https://segmentfault.com/a/1190000010719058">前端开发如何独立解决跨域问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JS之ES6语法知识点二</title>
    <link href="http://github.com/2021/01/25/JS%E4%B9%8BES6%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"/>
    <id>http://github.com/2021/01/25/JS%E4%B9%8BES6%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/</id>
    <published>2021-01-24T16:00:00.000Z</published>
    <updated>2021-01-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="新增类型"><a href="#新增类型" class="headerlink" title="新增类型"></a>新增类型</h2><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>Symbol 是一个新的原始类型，用来表示一个独一无二的值，可以通过 Symbol() 函数来创建一个 Symbol 类型的值，为了加以区分，可以传入一个字符串作为其描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">s1 === s2  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Symbol 类型无法通过数学运算符进行隐式类型转换，但是可以通过 String() 显示转成字符串或者通过 Boolean() 显示转成布尔值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">String</span>(s)     <span class="comment">// &quot;Symbol(&#x27;foo&#x27;)&quot;</span></span><br><span class="line">s.toString()  <span class="comment">// &quot;Symbol(&#x27;foo&#x27;)&quot;</span></span><br><span class="line"><span class="built_in">Boolean</span>(s)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>引入 Symbol 最大的初衷其实就是为了让它作为对象的属性名而使用，这样就可以有效避免属性名的冲突了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [foo]: <span class="string">&#x27;foo1&#x27;</span>,</span><br><span class="line">    foo: <span class="string">&#x27;foo2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[foo]  <span class="comment">// &#x27;foo1&#x27;</span></span><br><span class="line">obj.foo   <span class="comment">// &#x27;foo2&#x27;</span></span><br></pre></td></tr></table></figure><p>Symbol 属性的不可枚举性，不会被 for…in、for…of、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 等枚举：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;age&#x27;</span>)]: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(person)  <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(person)  <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(person)  <span class="comment">// &#x27;&#123;&quot;name&quot;:&quot;布兰&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>但是可以通过 Object.getOwnPropertySymbols() 获取到对象的所有 Symbol 属性名，返回一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(person)  <span class="comment">// [Symbol(age)]</span></span><br></pre></td></tr></table></figure><h3 id="静态方法："><a href="#静态方法：" class="headerlink" title="静态方法："></a>静态方法：</h3><ol><li><p>Symbol.for() 按照描述去全局查找 Symbol，找不到则在全局登记一个：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p> Symbol.for() 的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p></li><li><p>Symbol.keyFor() 根据已经在全局登记的 Symbol 查找其描述：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s)  <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Symbol-的内置值："><a href="#Symbol-的内置值：" class="headerlink" title="Symbol 的内置值："></a>Symbol 的内置值：</h3><ul><li><code>Symbol.hasInstance</code>：指向一个内部方法，当其他对象使用 <code>instanceof</code> 运算符判断是否为此对象的实例时会调用此方法；</li><li><code>Symbol.isConcatSpreadable</code>：指向一个布尔，定义对象用于 <code>Array.prototype.concat()</code> 时是否可展开；</li><li><code>Symbol.species：</code>指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数；</li><li><code>Symbol.match：</code>指向一个函数，当实例对象被 <code>String.prototype.match()</code> 调用时会重新定义<code>match()</code>的行为；</li><li><code>Symbol.replace：</code>指向一个函数，当实例对象被 <code>String.prototype.replace()</code> 调用时会重新定义 <code>replace()</code> 的行为；</li><li><code>Symbol.search：</code>指向一个函数，当实例对象被<code>String.prototype.search()</code>调用时会重新定义 <code>search()</code> 的行为；</li><li><code>Symbol.split</code>：指向一个函数，当实例对象被 <code>String.prototype.split()</code> 调用时会重新定义 <code>split() </code>的行为；</li><li><code> Symbol.iterator：</code>指向一个默认遍历器方法，当实例对象执行 <code>for...of </code>时会调用指定的默认遍历器；</li><li><code>Symbol.toPrimitive：</code>指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值；</li><li><code>Symbol.toStringTag：</code>指向一个函数，当实例对象被 <code>Object.prototype.toString()</code> 调用时其返回值会出现在 <code>toString()</code> 返回的字符串之中表示对象的类型；</li><li><code>Symbol.unscopables：</code>指向一个对象，指定使用 <code>with </code>时哪些属性会被 <code>with </code>环境排除；</li><li><code>Symbol.prototype.description</code> : 描述属性  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let symbol &#x3D; Symbol(&#39;foo&#39;)</span><br><span class="line">symbol.description  &#x2F;&#x2F; &#39;foo&#39;</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2></li></ul><p>Set 是一种新的数据结构，类似数组，但是它没有键只有值，且值都是唯一的。可以通过构造函数生成一个新实例，接收一个数组或者可迭代数据结构作为参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">&#x27;abc&#x27;</span>)      <span class="comment">// Set &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>Set 判断两个值是不是相等用的是 sameValueZero 算法，类似于 ===，唯一的区别是，在 Set 里 NaN 之间被认为是相等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span></span><br><span class="line">set.add(a)</span><br><span class="line">set.add(b)</span><br><span class="line">set.size  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>相同对象的不同实例也被 Set 认为是不相等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line">set.add(a)</span><br><span class="line">set.add(b)</span><br><span class="line">set.size  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>Set 是有顺序的，将按照插入的顺序进行迭代，可以使用 for…of 迭代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">set.add(<span class="number">5</span>)</span><br><span class="line">set.add(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set-实例属性和方法："><a href="#Set-实例属性和方法：" class="headerlink" title="Set 实例属性和方法："></a>Set 实例属性和方法：</h3><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是 <code>Set</code> 函数；</li><li><code>Set.prototype.size</code>：返回 <code>Set</code> 实例的成员总数；</li><li><code>Set.prototype.add(value)</code>：添加某个值，返回 <code>Set</code> 结构本身；</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功；</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员；</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值；</li><li><code>Set.prototype.keys()</code>：返回键名的遍历器；</li><li><code>Set.prototype.values()</code>：返回键值的遍历器；</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器；</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">set.add(<span class="number">5</span>)     <span class="comment">// Set &#123;1, 3, 5&#125;</span></span><br><span class="line">set.size       <span class="comment">// 3</span></span><br><span class="line">set.delete(<span class="number">1</span>)  <span class="comment">// true，1 已被删除</span></span><br><span class="line">set.has(<span class="number">1</span>)     <span class="comment">// false</span></span><br><span class="line">set.keys()     <span class="comment">// SetIterator &#123;3, 5&#125;</span></span><br><span class="line">set.clear()</span><br><span class="line">set.size       <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="Set-应用场景："><a href="#Set-应用场景：" class="headerlink" title="Set 应用场景："></a>Set 应用场景：</h3></li></ul><ol><li><p>数组去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>])]         <span class="comment">// [1, 3, 6]</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>]))  <span class="comment">// [1, 3, 6]</span></span><br></pre></td></tr></table></figure></li><li><p>字符串去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&#x27;abcbacd&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>)  <span class="comment">// &#x27;abcd&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>求两个集合的交集/并集/差集：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b])  <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)))  <span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)))  <span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>遍历修改集合成员的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>))     <span class="comment">// Set &#123;2, 3, 6&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(set, <span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>))  <span class="comment">// Set &#123;2, 4, 6&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p><code>WeakSet</code> 对象允许将弱保持对象存储在一个集合中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123;&#125;</span><br><span class="line">ws.add(foo)  <span class="comment">// WeakSet &#123;&#123;&#125;&#125;</span></span><br><span class="line">ws.has(foo)  <span class="comment">// true</span></span><br><span class="line">ws.delete(foo)  <span class="comment">// WeakSet &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>和 Set 的区别：</p><ul><li><code>WeakSet</code> 只能是对象的集合，而不能是任何类型的任意值；</li><li><code>WeakSet</code> 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 <code>WeakSet</code> 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 <code>WeakSet</code> 中没有存储当前对象的列表。正因为这样，WeakSet 是不可枚举的，也就没有 <code>size</code> 属性，没有 <code>clear</code> 和遍历的方法。</li></ul><p>实例方法：</p><ul><li><code>WeakSet.prototype.add(value)</code>：添加一个新元素 <code>value</code>；</li><li><code>WeakSet.prototype.delete(value)</code>：从该 WeakSet 对象中删除 <code>value</code> 这个元素；</li><li><code>WeakSet.prototype.has(value)</code>：返回一个布尔值,  表示给定的值 <code>value </code>是否存在于这个 <code>WeakSet</code> 中；</li></ul><p>应用场景</p><ul><li>储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li><li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在WeakSet结构中的引用就会自动消</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>Map</code> 是一种类似于 <code>Object</code> 的这种键值对的数据结构，区别是对象的键只能是字符串或者 <code>Symbol</code>，而 <code>Map </code>的键可以是任何类型（原始类型、对象或者函数），可以通过 <code>Map</code> 构造函数创建一个实例，入参是具有 <code>Iterator</code> 接口且每个成员都是一个双元素数组 <code>[key, value] </code>的数据结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map1.set(&#123;&#125;, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;布兰&#x27;</span>], [<span class="string">&#x27;age&#x27;</span>, <span class="number">12</span>]]</span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(arr)</span><br></pre></td></tr></table></figure><p>Map 中的键和 Set 里的值一样也必须是唯一的，遵循 sameValueZero 算法，对于同一个键后面插入的会覆盖前面的，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123;<span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span>&#125;</span><br><span class="line">map.set(foo, <span class="string">&#x27;foo1&#x27;</span>)</span><br><span class="line">map.set(foo, <span class="string">&#x27;foo2&#x27;</span>)</span><br><span class="line">map.get(foo)  <span class="comment">// &#x27;foo2&#x27; </span></span><br></pre></td></tr></table></figure><p>对于键名同为 NaN 以及相同对象而不同实例的处理同 Set 的值一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(a, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">map.set(b, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">map.size    <span class="comment">// 1</span></span><br><span class="line">map.get(a)  <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> d = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">map.set(c, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">map.set(d, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">map.size    <span class="comment">// 3</span></span><br><span class="line">map.get(c)  <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="实例属性和方法："><a href="#实例属性和方法：" class="headerlink" title="实例属性和方法："></a>实例属性和方法：</h3><ul><li><p><code>Map.prototype.size</code>：返回 <code>Map </code>对象的键值对数量；</p></li><li><p><code>Map.prototype.set(key, value)</code>：设置 <code>Map</code> 对象中键的值。返回该 <code>Map</code> 对象；</p></li><li><p><code>Map.prototype.get(key)</code>： 返回键对应的值，如果不存在，则返回 <code>undefined</code>；</p></li><li><p><code>Map.prototype.has(key)</code>：返回一个布尔值，表示<code>Map</code>实例是否包含键对应的值；</p></li><li><p><code>Map.prototype.delete(key)</code>： 如果 <code>Map</code> 对象中存在该元素，则移除它并返回 <code>true</code>；</p></li><li><p><code>Map.prototype.clear()</code>： 移除 <code>Map</code> 对象的所有键/值对；</p></li><li><p><code>Map.prototype.keys()</code>：返回一个新的 <code>Iterator</code> 对象， 它按插入顺序包含了 <code>Map</code> 对象中每个元素的键；</p></li><li><p><code>Map.prototype.values()</code>：返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map </code>对象中每个元素的值；</p></li><li><p><code>Map.prototype.entries()</code>：返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map </code>对象中每个元素的<code>[key, value]</code>数组；</p></li><li><p><code>Map.prototype.forEach(callbackFn[, thisArg])</code>：按插入顺序遍历 <code>Map</code>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">map.set(&#123;<span class="attr">a</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;a: 1&#125; &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#123;a: 2&#125; &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"><span class="comment">// &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2></li><li><p>定义：和Map结构类似，成员键只能是对象</p></li><li><p>声明：<code>const set = new WeakMap(arr)</code></p></li><li><p>入参：具有<code>Iterator</code>接口且每个成员都是一个双元素数组的数据结构<br>属性</p></li><li><p><code>constructor</code>：构造函数，返回<code>WeakMap</code></p></li></ul><p>方法</p><ul><li><code>get()</code>：返回键值对</li><li><code>set()</code>：添加键值对，返回实例</li><li><code>delete()</code>：删除键值对，返回布尔</li><li><code>has()</code>：检查键值对，返回布尔</li></ul><p>应用场景</p><ul><li>储存<code>DOM</code>节点：<code>DOM</code>节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li><li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li></ul><p>特点</p><ul><li>成员键都是弱引用，垃圾回收机制不考虑<code>WeakMap</code>结构对此成员键的引用</li><li>成员键不适合引用，它会随时消失，因此<code>ES6</code>规定<code>WeakMap</code>结构不可遍历</li><li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap</code>结构中</li><li>一旦不再需要，成员会自动消失，不用手动删除引用</li><li>弱引用的只是键而不是值，值依然是正常引用</li><li>即使在外部消除了成员键的引用，内部的成员值依然存在</li></ul><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p><code>Proxy</code> 用来定义基本操作的的自定义行为，可以理解为当对目标对象<code>target</code>进行某个操作之前会先进行拦截（执行 <code>handler </code>里定义的方法），必须要对 <code>Proxy</code> 实例进行操作才能触发拦截，对目标对象操作是不会拦截的，可以通过如下方式定义一个代理实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>&#125;, &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`hello, <span class="subst">$&#123;target.name&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">instance.name  <span class="comment">// &#x27;hello, 布兰&#x27;</span></span><br></pre></td></tr></table></figure><p>如果 <code>handle</code> 没有设置任何拦截，那么对实例的操作就会转发到目标对象身上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;)</span><br><span class="line">proxy.name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">target.name  <span class="comment">// &#x27;布兰&#x27;</span></span><br></pre></td></tr></table></figure><p>目标对象被 <code>Proxy</code> 代理的时候，内部的 this 会指向代理的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span> === proxy)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">target.m()  <span class="comment">// false</span></span><br><span class="line">proxy.m()   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="静态方法：-1"><a href="#静态方法：-1" class="headerlink" title="静态方法："></a>静态方法：</h3><p>Proxy.revocable() 用以定义一个可撤销的 Proxy：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(target, handler)</span><br><span class="line">  </span><br><span class="line">proxy.foo = <span class="number">123</span></span><br><span class="line">proxy.foo  <span class="comment">// 123</span></span><br><span class="line">revoke()</span><br><span class="line">proxy.foo  <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h3 id="handle-对象的方法："><a href="#handle-对象的方法：" class="headerlink" title="handle 对象的方法："></a>handle 对象的方法：</h3><ul><li><code>get(target, propKey, receiver)</code>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li><li><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置，比如 <code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li><code>has(target, propKey)</code>：拦截 <code>propKey in proxy </code>的操作，返回一个布尔值。</li><li><code>deleteProperty(target, propKey)</code>：拦截 <code>delete proxy[propKey]</code> 的操作，返回一个布尔值。</li><li><code>ownKeys(target)</code>：拦截 <code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in </code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 <code>Object.keys() </code>的返回结果仅包括目标对象自身的可遍历属性。</li><li><code>getOwnPropertyDescriptor(target, propKey)</code>：拦截<code>Object</code>.- <code>getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li><code>defineProperty(target, propKey, propDesc)</code>：拦截 <code>Object</code>.<code>defineProperty(proxy, propKey, propDesc)</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li><code>preventExtensions(target)</code>：拦截 <code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li><code>getPrototypeOf(target)</code>：拦截 <code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li><code>isExtensible(target)</code>：拦截 <code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li><code>setPrototypeOf(target, proto)</code>：拦截 <code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li><code>apply(target, object, args)</code>：拦截<code> Proxy</code> 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li><code>construct(target, args)</code>：拦截 <code>Proxy</code> 实例作为构造函数调用的操作，比如 <code>new proxy(...args)</code>。<h3 id="与Object-defineProperty对比"><a href="#与Object-defineProperty对比" class="headerlink" title="与Object.defineProperty对比"></a>与Object.defineProperty对比</h3><code>Object.defineProperty</code>：数据劫持：直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</li></ul><p>在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。数据劫持最典型的应用 —–&gt; 双向的数据绑定</p><ul><li><p>Object.defineProperty</p><p>  只能监听对象(Object)，不能监听数组的变化，无法触发push, pop, shift, unshift,splice, sort, reverse。<br>  必须遍历对象的每个属性<br>  只能劫持当前对象属性，如果想深度劫持，必须深层遍历嵌套的对象</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> value = <span class="number">1</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;listenA&#x27;</span>, &#123;</span><br><span class="line">writable: <span class="literal">true</span>,  <span class="comment">//可修改</span></span><br><span class="line">enumerable: <span class="literal">true</span>,  <span class="comment">// 可枚举   for...in...   Object.keys()</span></span><br><span class="line">configurable: <span class="literal">true</span>,  <span class="comment">// 可配置，可删除</span></span><br><span class="line">get: <span class="function">() =&gt;</span> value,</span><br><span class="line">set: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`set obj.listenA .. <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">    value = val</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">obj.listenA = <span class="number">2</span> <span class="comment">//set obj.listenA .. 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.listenA)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>Proxy</p><ul><li>可以直接监听对象而非属性</li><li>可以直接监听数组的变化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 代理整个对象</span><br><span class="line">let proxyObj &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">get: (target, key, receiver) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;getting $&#123;key&#125;!&#96;);</span><br><span class="line">    return target[key];</span><br><span class="line">&#125;,</span><br><span class="line">set: (target, key, value, receiver) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(target, key, value, receiver);</span><br><span class="line">    return target[key] &#x3D; value;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxyObj.val &#x3D; 1;    &#x2F;&#x2F; &#123;&#125; val 1 &#123;&#125;</span><br><span class="line">proxyObj.val;       &#x2F;&#x2F; getting val!</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;代理数组</span><br><span class="line">let proxyArr &#x3D; new Proxy([], &#123;</span><br><span class="line">get: (target, key, receiver) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;getting $&#123;key&#125;!&#96;);</span><br><span class="line">    return target[key];</span><br><span class="line">&#125;,</span><br><span class="line">set: (target, key, value, receiver) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(target, key, value, receiver);</span><br><span class="line">    return (target[key] &#x3D; value);</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxyArr[0] &#x3D; 1; &#x2F;&#x2F;  &#123;&#125; val 1 &#123;&#125;</span><br><span class="line">console.log(proxyArr[0]); &#x2F;&#x2F;  getting val!  &#x2F;&#x2F; 1</span><br><span class="line">console.log(proxyArr); &#x2F;&#x2F; [1]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903959283367950#heading-0">1.5万字概括ES6全部特性(已更新ES2020)</a></li><li><a href="https://juejin.cn/post/6895898051559456776#heading-0">送你一份精心总结的3万字ES6实用指南（上）</a></li><li><a href="https://juejin.cn/post/6896986598999588872#heading-0">「建议收藏」送你一份精心总结的3万字ES6实用指南（下）</a></li><li><a href="https://juejin.cn/post/6844903775329583112#heading-1">近一万字的ES6语法知识点补充</a></li><li><a href="https://juejin.cn/post/6844903679976275976#heading-1">ES6、ES7、ES8特性一锅炖(ES6、ES7、ES8学习指南)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;新增类型&quot;&gt;&lt;a href=&quot;#新增类型&quot; class=&quot;headerlink&quot; title=&quot;新增类型&quot;&gt;&lt;/a&gt;新增类型&lt;/h2&gt;&lt;h3 id=&quot;S
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之ES6语法知识点一</title>
    <link href="http://github.com/2021/01/23/JS%E4%B9%8BES6%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"/>
    <id>http://github.com/2021/01/23/JS%E4%B9%8BES6%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/</id>
    <published>2021-01-22T16:00:00.000Z</published>
    <updated>2021-01-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><blockquote><p>声明方法：var、const、let、function、class、import</p></blockquote><h3 id="let-const特性"><a href="#let-const特性" class="headerlink" title="let,const特性"></a>let,const特性</h3><ol><li><p>const：声明一个常量，let：声明一个变量；const/let 声明的常量/变量都只能作用于代码块（块级作用域或函数作用域）里；</p></li><li><p>const/let 不存在变量提升，所以在代码块里必须先声明然后才可以使用，这叫暂时性死区；</p></li><li><p>const/let 不允许在同一个作用域内，重复声明；</p></li><li><p>const 声明时必须初始化，且后期不能被修改，但如果初始化的是一个对象，那么不能修改的是该对象的内存地址；</p></li><li><p>const/let 在全局作用域中声明的常量/变量不会挂到顶层对象（浏览器中是 window ）的属性中；</p></li></ol><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h3 id="解构类型："><a href="#解构类型：" class="headerlink" title="解构类型："></a>解构类型：</h3><ol><li><p>字符串解构</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c = <span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;12&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)  <span class="comment">// &#x27;1&#x27; &#x27;2&#x27; &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数值解构</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toFixed</span>: tf&#125; = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log( tf.call(<span class="built_in">Math</span>.PI, <span class="number">2</span>) )  <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure></li><li><p>布尔值解构</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: ts&#125; = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log( ts.call(<span class="literal">false</span>) )  <span class="comment">// &#x27;false&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数组解构：等号右侧的数据具有 Iterator 接口可以进行数组形式的解构赋值；</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构不成功的变量值为 undefined</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)  <span class="comment">// 1, 2, undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以设置默认值</span></span><br><span class="line"><span class="keyword">let</span> [x, y, z = <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>]</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z)  <span class="comment">// 1, 2, null</span></span><br></pre></td></tr></table></figure><p> 什么样的数据具有 Iterator 接口呢？如果一个对象能够通过 [Symbol.iterator] 访问，且能够返回一个符合迭代器协议的对象，那么该对象就是可迭代的。目前内置的可迭代对象有：String、Array、TypeArray、Map、Set、arguments 和 NodeList 等。</p></li><li><p>对象解构：与数组按照索引位置进行解构不同，对象解构是按照属性名进行解构赋值，如果在当前对象属性匹配不成功则会去对象的原型属性上查找：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认写法</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: name, <span class="attr">age</span>: age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改名且设置默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: name1, <span class="attr">age</span>: age1 = <span class="number">12</span> &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name1, age1)  <span class="comment">// &#x27;布兰&#x27; 12</span></span><br></pre></td></tr></table></figure></li><li><p>函数参数解构：其实就是运用上面的对象解构和数组解构规则；</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([x, y])</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;)  <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;)        <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;)            <span class="comment">// [0, 0]</span></span><br><span class="line">move()              <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="解构要点："><a href="#解构要点：" class="headerlink" title="解构要点："></a>解构要点：</h3><ul><li>只要等号两边的模式相同（同是对象或同是数组），则左边的变量会被赋予对应的值；</li><li>解构不成功的变量值为 undefined；</li><li>默认值生效的前提是当等号右边对应的值全等于 undefined 的时候；</li><li>只要等号右边的值不是对象或者数组，则会进行自动装箱将其转成对象；</li><li>null 和 undefined 都无法转成对象，所以无法解构。</li></ul><h3 id="解构应用："><a href="#解构应用：" class="headerlink" title="解构应用："></a>解构应用：</h3><ol><li>交换变量的值； <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x]</span><br><span class="line"><span class="built_in">console</span>.log(x, y)  <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure></li><li>通过函数返回对象属性 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">        age: <span class="number">12</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name, age&#125; = getParams()</span><br></pre></td></tr></table></figure></li><li>通过定义函数参数来声明变量 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">init(person)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 普通用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;name, age&#125; = person</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 更简洁用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">&#123;name, age&#125;</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>指定函数参数默认值 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPerson</span>(<span class="params">&#123;name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name, age)</span><br><span class="line">&#125;</span><br><span class="line">initPerson()  <span class="comment">// &#x27;布兰&#x27; 12</span></span><br><span class="line">initPerson(&#123;<span class="attr">age</span>: <span class="number">20</span>&#125;)  <span class="comment">// &#x27;布兰&#x27; 20</span></span><br></pre></td></tr></table></figure></li><li>提取 JSON 数据 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> responseData = &#123;</span><br><span class="line">    code: <span class="number">1000</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    message: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> &#123; code, data = &#123;&#125; &#125; = responseData</span><br></pre></td></tr></table></figure></li><li>遍历 Map 结构 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line">map.set(<span class="string">&#x27;xiamen&#x27;</span>, <span class="string">&#x27;厦门&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>输入模块的指定方法和属性 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile, writeFile &#125; = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h2></li></ol><ul><li>模板字符串: <code>`$&#123;name&#125;`</code></li><li>Unicode表示法：大括号包含表示Unicode字符(\u{0xXX}或\u{0XXX})</li><li>字符串遍历：可通过for-of遍历字符串</li><li>字符串模板：可单行可多行可插入变量的增强版字符串</li><li>标签模板：函数参数的特殊调用</li><li>String.raw()：返回把字符串所有变量替换且对斜杠进行转义的结果</li><li>String.fromCodePoint()：返回码点对应字符</li><li>codePointAt()：返回字符对应码点(String.fromCodePoint()的逆操作)</li><li>normalize()：把字符的不同表示方法统一为同样形式，返回新字符串-(Unicode正规化)</li><li>repeat()：把字符串重复n次，返回新字符串</li><li>matchAll()：返回正则表达式在字符串的所有匹配</li><li>includes()：是否存在指定字符串</li><li>startsWith()：是否存在字符串头部指定字符串</li><li>endsWith()：是否存在字符串尾部指定字符串</li></ul><h2 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h2><ul><li>二进制表示法：0b或0B开头表示二进制(0bXX或0BXX)</li><li>八进制表示法：0o或0O开头表示二进制(0oXX或0OXX)</li><li>Number.EPSILON：数值最小精度</li><li>Number.MIN_SAFE_INTEGER：最小安全数值(-2^53)</li><li>Number.MAX_SAFE_INTEGER：最大安全数值(2^53)</li><li>Number.parseInt()：返回转换值的整数部分</li><li>Number.parseFloat()：返回转换值的浮点数部分</li><li>Number.isFinite()：是否为有限数值</li><li>Number.isNaN()：是否为NaN</li><li>Number.isInteger()：是否为整数</li><li>Number.isSafeInteger()：是否在数值安全范围内</li><li>Math.trunc()：返回数值整数部分</li><li>Math.sign()：返回数值类型(正数1、负数-1、零0)</li><li>Math.cbrt()：返回数值立方根</li><li>Math.clz32()：返回数值的32位无符号整数形式</li><li>Math.imul()：返回两个数值相乘</li><li>Math.fround()：返回数值的32位单精度浮点数形式</li><li>Math.hypot()：返回所有数值平方和的平方根</li><li>Math.expm1()：返回e^n - 1</li><li>Math.log1p()：返回1 + n的自然对数(Math.log(1 + n))</li><li>Math.log10()：返回以10为底的n的对数</li><li>Math.log2()：返回以2为底的n的对数</li><li>Math.sinh()：返回n的双曲正弦</li><li>Math.cosh()：返回n的双曲余弦</li><li>Math.tanh()：返回n的双曲正切</li><li>Math.asinh()：返回n的反双曲正弦</li><li>Math.acosh()：返回n的反双曲余弦</li><li>Math.atanh()：返回n的反双曲正切</li></ul><h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><ol><li><p>对象属性简写</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;aa&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name,</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;aa&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性名表达式：在用对象字面量定义对象的时候，允许通过属性名表达式来定义对象属性</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    [name]: <span class="string">&#x27;aa&#x27;</span>,</span><br><span class="line">    [<span class="string">&#x27;get&#x27;</span>+ name]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Object.is()：用来判断两个值是否相等，表现基本和 === 一样，除了以下两种情况：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span>            <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>          <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>Object.assign()：合并对象(浅拷贝)，返回原对象</p><p> Object.assign() 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target），如果有同名属性，则后面的会直接替换前面的：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> source1 = &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">d</span>: &#123;<span class="attr">e</span>: <span class="number">1</span>, <span class="attr">f</span>: <span class="number">2</span>&#125; &#125;</span><br><span class="line"><span class="keyword">let</span> source2 = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: &#123;<span class="attr">g</span>: <span class="number">3</span>&#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2)</span><br><span class="line">target  <span class="comment">// &#123; a: 3, b: 3, c: 4, d: &#123;g: 3&#125; &#125;</span></span><br></pre></td></tr></table></figure><p> Object.assign() 实行的是浅拷贝，如果源对象某个属性是对象，那么拷贝的是这个对象的引用：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> source = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line">target.a.b = <span class="number">3</span></span><br><span class="line">source.a.b  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p>__proto__：返回或设置对象的原型对象</p></li><li><p>Object.values()</p><p> 返回一个由对象自身所有可遍历属性的属性值组成的数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="number">12</span>,</span><br><span class="line">    enumrable: <span class="literal">false</span>  <span class="comment">// age 属性将不可遍历</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(person))  <span class="comment">// [&#x27;布兰&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似 str.split(&#x27;&#x27;) 效果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(<span class="string">&#x27;abc&#x27;</span>))  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>Object.entries()</p><p> 返回一个由对象自身所有可遍历属性的键值对组成的数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(person))  <span class="comment">// [[&quot;name&quot;, &quot;布兰&quot;], [&quot;age&quot;, 12]]</span></span><br></pre></td></tr></table></figure><p> 利用这个方法可以很好的将对象转成正在的 Map 结构：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(person))</span><br><span class="line"><span class="built_in">console</span>.log(map)  <span class="comment">// Map &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Object.fromEntries()</p><p>Object.fromEntries() 方法是 Object.entries() 的逆操作，用于将一个键值对数组转为对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> keyValueArr = <span class="built_in">Object</span>.entries(person)   <span class="comment">// [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(arr)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Object.getOwnPropertyDescriptors()</p><p>Object.getOwnPropertyDescriptor() 会返回指定对象某个自身属性的的描述对象，而 Object.getOwnPropertyDescriptors() 则是返回指定对象自身所有属性的描述对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person))</span><br><span class="line"><span class="comment">//&#123; </span></span><br><span class="line"><span class="comment">//  name: &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;,</span></span><br><span class="line"><span class="comment">//  age: &#123;configurable: false, enumerable: false, value: 12, writable: false&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>配合 Object.create() 可以实现浅克隆：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="built_in">Object</span>.create(</span><br><span class="line">    <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>Object.setPrototypeOf()与Object.getPrototypeOf()</p><p>Object.setPrototypeOf() 用于设置对象原型，Object.getPrototypeOf() 用于读取对象原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, &#123;<span class="attr">name</span>: <span class="string">&#x27;动物&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person)  <span class="comment">// &#123;name: &#x27;动物&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h2><ol><li><p>数组扩展运算符</p><p> 数组扩展运算符（…）将数组展开成用逗号分隔的参数序列，只能展开一层数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用一：函数传参</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用二：数组合并</span></span><br><span class="line"><span class="keyword">let</span> merge = [...[<span class="number">1</span>, <span class="number">2</span>], ...[<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, <span class="number">6</span>]  <span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用三：浅克隆</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> clone = [...a]</span><br><span class="line">a === clone  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用四：数组解构</span></span><br><span class="line"><span class="keyword">const</span> [x, ...y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x  <span class="comment">// 1</span></span><br><span class="line">y  <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.from()</p><p> Array.from()可以将类数组对象（ NodeList，arguments）和可迭代对象转成数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用一：字符串转数组</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;foo&#x27;</span>)  <span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用二：数组合并去重</span></span><br><span class="line"><span class="keyword">let</span> merge = [...[<span class="number">1</span>, <span class="number">2</span>], ...[<span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(merge))  <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用三：arguments 转数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p> 如果 Array.from() 带第二个参数 mapFn，将对生成的新数组执行一次 map 操作：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x )    <span class="comment">// [1, 4, 9]</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> ++i)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.of()</p><p> Array.of()将一组参数转成数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayOf</span>(<span class="params">...params</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].slice.call(params)</span><br><span class="line">&#125;</span><br><span class="line">arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.copyWithin()</p><p> Array.copyWithin()在当前数组内部，将制定位置的成员复制到其他位置（会覆盖原来位置的成员），最后返回一个新数组。接收 3 个参数，参数为负数表示右边开始计算：</p><ul><li>target（必选）：替换位置的索引；</li><li>start（可选）：从该位置开始读取数据，默认为 0；</li><li>end（可选）：从该位置结束读取数据（不包括该位置的数据），默认为原数组长度；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-1</span>)         <span class="comment">// [1, 2, 3, 4, 1]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1</span>)          <span class="comment">// [1, 1, 2, 3, 4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)    <span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-3</span>, <span class="number">-1</span>)  <span class="comment">// [3, 4, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查找第一个出现的子成员：find() 和 findIndex()：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出第一个偶数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>].find(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span> val % <span class="number">2</span> === <span class="number">0</span>)       <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出第一个偶数的索引位置</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>].findIndex(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span> val % <span class="number">2</span> === <span class="number">0</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>fill() 使用给定的值来填充数组，有 3 个参数：</p><ul><li>value：填充值；</li><li>start（可选），开始索引，默认为 0；</li><li>end（可选）：结束索引，默认为数组长度，不包括该索引位置的值；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化空数组</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">1</span>)  <span class="comment">// [1, 1, 1]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].fill(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>)  <span class="comment">// [1, 2, &#x27;a&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过 keys()（键名）、entries()（键值）和 values()（键值对） 获取数组迭代器对象，可以被 for…of 迭代，</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)  <span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)  <span class="comment">// [0, &#x27;a&#x27;] [0, &#x27;b&#x27;] [0, &#x27;c&#x27;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组空位</p><p> 指数组没有值，比如：[,,]，而像这种 [undefined] 是不包含空位的。由于 ES6 之前的一些 API 对空位的处理规则很不一致，所以实际操作的时候应该尽量避免空位的出现，而为了改变这个现状，ES6 的 API 会默认将空位处理成 undefined：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[<span class="number">1</span>, , <span class="number">3</span>].values()]  <span class="comment">// [1, undefined, 3]</span></span><br><span class="line">[<span class="number">1</span>, , <span class="number">3</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> x === <span class="literal">undefined</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.includes</p><p> 判断一个数组是否包含某个元素，之前一般是这么做的：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) &gt;= <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (~arr.indexOf(el)) &#123;&#125;</span><br></pre></td></tr></table></figure><p> 而现在你可以这么做了：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.includes(el)) &#123;&#125;</span><br></pre></td></tr></table></figure><p> indexOf 会返回找到元素在数组中的索引位置，判断的逻辑是是否严格相等，所以他在遇到 NaN 的时候不能正确返回索引，但是 includes 解决了这个问题：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">3</span>].indexOf(<span class="literal">NaN</span>)   <span class="comment">// -1</span></span><br><span class="line">[<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">3</span>].includes(<span class="literal">NaN</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.prototype.flat()</code>: 扁平化嵌套数组和移除数组中的空项:</p><p>arr.flat(depth) 按照 depth （不传值的话默认是 1）深度拍平一个数组，并且将结果以新数组形式返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// depth 默认是 1</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(arr1.flat())  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Infinity，可展开任意深度的嵌套数组；自动跳过空数组；</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, , [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]]]]</span><br><span class="line"><span class="built_in">console</span>.log(arr2.flat(<span class="literal">Infinity</span>))</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>用 reduce 实现拍平一层数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> newStr = arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc.concat(cur), [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">const</span> flattened = <span class="function"><span class="params">arr</span> =&gt;</span> [].concat(...arr)</span><br><span class="line">flattened(arr)</span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.flatMap()</p><p>flatMap(callback) 使用映射函数 callback 映射每个元素，callback 每次的返回值组成一个数组，并且将这个数组执行类似 arr.flat(1) 的操作进行拍平一层后最后返回结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// 将 [[2], [4], [6], [8]] 数组拍平一层得到最终结果：[2, 4, 6, 8]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h2><ol><li><p>函数参数默认值</p><ul><li><p>参数不能有同名的</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, x, y = <span class="number">1</span></span>) </span>&#123;&#125;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li><li><p>函数体内不能用 let 和 const 声明同参数名的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>length：返回没有指定默认值的参数个数</p><p>  如果设置默认值的参数不是尾参数，则 length 不再计入后面的参数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>)</span>&#123;&#125;).length      <span class="comment">// 2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">1</span></span>)</span>&#123;&#125;).length  <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>)</span>&#123;&#125;).length  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>rest/spread参数(…)：返回函数多余参数</p><ul><li>形式：以数组的形式存在，之后不能再有其他参数</li><li>作用：代替Arguments对象</li><li>length：返回没有指定默认值的参数个数但不包括rest/spread参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, ...y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> y) &#123;</span><br><span class="line">        coonsole.log(val)  <span class="comment">// 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>严格模式：在严格条件下运行JS</p><ul><li>应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式</li><li>规避限制的办法有两个：设置全局的严格模式或者在函数体外在包一个立即执行函数并且声明严格模式：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">2</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二</span></span><br><span class="line"><span class="keyword">let</span> f = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y = <span class="number">2</span></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>箭头函数(=&gt;)</p><p> 箭头函数语法比函数表达式更简洁，并且没有自己的 this、arguments，不能用作构造函数和用作生成器。</p><ul><li>箭头函数误区<ul><li>函数体内的this是定义时所在的对象而不是使用时所在的对象</li><li>可让this指向固定化，这种特性很有利于封装回调函数</li><li>不可当作构造函数，因此箭头函数不可使用new命令</li><li>不可使用yield命令，因此箭头函数不能用作Generator函数</li><li>不可使用Arguments对象，此对象在函数体内不存在(可用rest/spread参数代替)</li><li>返回对象时必须在对象外面加上括号</li></ul></li></ul></li><li><p>尾调用优化：只保留内层函数的调用帧</p><ul><li>尾调用<ul><li>定义：某个函数的最后一步是调用另一个函数</li><li>形式：function f(x) { return g(x); }</li></ul></li><li>尾递归<ul><li>定义：函数尾调用自身</li><li>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</li><li>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</li></ul></li></ul></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903959283367950#heading-0">1.5万字概括ES6全部特性(已更新ES2020)</a></li><li><a href="https://juejin.cn/post/6895898051559456776#heading-0">送你一份精心总结的3万字ES6实用指南（上）</a></li><li><a href="https://juejin.cn/post/6896986598999588872#heading-0">「建议收藏」送你一份精心总结的3万字ES6实用指南（下）</a></li><li><a href="https://juejin.cn/post/6844903775329583112#heading-1">近一万字的ES6语法知识点补充</a></li><li><a href="https://juejin.cn/post/6844903679976275976#heading-1">ES6、ES7、ES8特性一锅炖(ES6、ES7、ES8学习指南)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;声
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之模块化</title>
    <link href="http://github.com/2021/01/23/JS%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://github.com/2021/01/23/JS%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2021-01-22T16:00:00.000Z</published>
    <updated>2021-01-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统。参见阮一峰老师的文章<a href="https://es6.ruanyifeng.com/#docs/module-loader">module-loader</a> 。</p><h3 id="原生模块化"><a href="#原生模块化" class="headerlink" title="原生模块化"></a>原生模块化</h3><p>一个函数就是一个模块</p><ol><li><p>一个函数就是一个模块</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">m1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">m2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 缺点：污染了全局变量，无法保证不会与其它模块发生冲突，而且模块成员之间看不出直接关系。</p></li><li><p>一个对象就是一个模块</p><p> 对象写法 为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> module1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">    _sum: <span class="number">0</span>,</span><br><span class="line">    foo1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    foo2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 缺点：会暴露所有模块成员，内部的状态可能被改写。</p><p> 例如，我们如果只是想暴露出两个方法而不暴露出<code>_sum</code>，就做不到。<br> 而此时，<code>_sum</code>可能被外部改写：<br> <code>module1._sum = 2;</code></p></li><li><p>立即执行函数为一个模块</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> foo1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> foo2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo1: foo1,</span><br><span class="line">      foo2: foo2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 利用立即执行函数内的作用域已经闭包来实现模块功能，导出我们想要导出的成员。<br> 此时外部代码就不能读取到_sum了：</p><p> <code>console.log(module1._sum) // undefined </code></p><h3 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h3><p>Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。</p></li></ol><h4 id="暴露-定义-模块"><a href="#暴露-定义-模块" class="headerlink" title="暴露(定义)模块"></a>暴露(定义)模块</h4><p>暴露模块有两种方式：</p><ol><li><code>module.exports = &#123;&#125;</code></li><li><code>exports.xxx = &#39;xxx&#39;</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种暴露方式：</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name: <span class="string">&#x27;aa&#x27;</span>,</span><br><span class="line">    sex: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种暴露方式：</span></span><br><span class="line"><span class="built_in">exports</span>.name = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line"><span class="built_in">exports</span>.sex = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.name = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.sex = <span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="引用-引入-模块"><a href="#引用-引入-模块" class="headerlink" title="引用(引入)模块"></a>引用(引入)模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用自定义的模块时，参数包含路径，可省略.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用核心模块时，不需要带路径</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">http.createService(...).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;js</span><br><span class="line">var m1Url &#x3D; &#39;.&#x2F;m1.js&#39;;</span><br><span class="line">var m1 &#x3D; require(m1Url);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 甚至做一些字符串拼接：</span><br><span class="line">var m1 &#x3D; require(&#39;.&#x2F;m&#39; + &#39;1.js&#39;);</span><br></pre></td></tr></table></figure><p>这个传参可以为表达式并不是<code>require</code>特有的。因为JS语言是传值调用，函数或者方法在调用的时候参数会被先计算出来，因此在我们使用require方法并传入表达式的时候，会先计算出表达式的值再传递给<code>require</code>。</p><h4 id="模块标识符-标识"><a href="#模块标识符-标识" class="headerlink" title="模块标识符(标识)"></a>模块标识符(标识)</h4><blockquote><p>模块标识符其实就是你在引入模块时调用require()函数的参数</p></blockquote><p>引入不同模块</p><ul><li>核心模块(Node.js自带的模块(<code>const path = require(&#39;path&#39;);</code>)</li><li>路径模块(相对或绝对定位开始的模块)(<code>const m1 = require(&#39;./m1.js&#39;);</code>)</li><li>自定义模块(node_modules里的模块)(<code>const lodash = require(&#39;lodash&#39;);</code>)</li></ul><p>三种模块的查找方式：</p><ul><li>核心模块: 直接跳过路径分析和文件定位</li><li>路径模块: 直接得出相对路径就好了</li><li>自定义模块: 先在当前目录的node_modules里找这个模块，如果没有，它会往上一级目录查找，查找上一级的node_modules，依次往上，直到根目录下都没有, 就抛出错误。</li></ul><h4 id="CommonJS规范的特点"><a href="#CommonJS规范的特点" class="headerlink" title="CommonJS规范的特点"></a>CommonJS规范的特点</h4><ol><li>所有代码都运行在模块作用域，不会污染全局作用域；</li><li>模块是同步加载的，即只有加载完成，才能执行后面的操作；</li><li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存；</li><li>CommonJS输出是值的拷贝(即，require返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值)。<blockquote><p>CommonJS输出是值的拷贝，这个对于引用类型的变量来说还是会有一点歧义的，比如下面的advantage那个例子，大家知道就行了。</p></blockquote></li></ol><p>CommonJS输出是值的拷贝案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js:</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> sex = <span class="string">&#x27;boy&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> advantage = [<span class="string">&#x27;handsome&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  sex = <span class="string">&#x27;girl&#x27;</span>;</span><br><span class="line">  advantage.push(<span class="string">&#x27;cute&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.name = name;</span><br><span class="line"><span class="built_in">exports</span>.sex = sex;</span><br><span class="line"><span class="built_in">exports</span>.advantage = advantage;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js:</span></span><br><span class="line"><span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;./m1&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;read count after 1000ms in commonjs is&#x27;</span>, m1.sex)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;read count after 1000ms in commonjs is&#x27;</span>, m1.advantage)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>执行node test.js之后的执行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read count after 1000ms in commonjs is boy</span><br><span class="line">read count after 1000ms in commonjs is [ &#39;handsome&#39;, &#39;cute&#39; ]</span><br></pre></td></tr></table></figure><p>也就是说，在开始var m1 = require(‘./m1’)的时候，m1已经被引入进来了，但是过了500ms后我改变了原本m1里的一些属性，sex这种基本数据类型是不会被改变的，但是advantage这种引用类型共用的还是同一个内存地址。（这种复制的关系让我想到了之前学原型链继承的时候，它那里也是，会影响Father.prototype上的引用类型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果advantage重新赋值</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  sex = <span class="string">&#x27;girl&#x27;</span>;</span><br><span class="line">  advantage = [<span class="string">&#x27;cute&#x27;</span>];</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 commonjs is [ &#x27;handsome&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><blockquote><p>为了能让我们采用异步的方式加载模块。</p></blockquote><ol><li>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</li><li>AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。<h4 id="用require-config-指定引用路径"><a href="#用require-config-指定引用路径" class="headerlink" title="用require.config()指定引用路径"></a>用require.config()指定引用路径</h4></li></ol><p>首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置require.config()并规定项目中用到的基础模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 网页中引入require.js及main.js **/</span></span><br><span class="line">&lt;script src=<span class="string">&quot;js/require.js&quot;</span> data-main=<span class="string">&quot;js/main&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">&quot;js/lib&quot;</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery.min&quot;</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">&quot;underscore&quot;</span>: <span class="string">&quot;underscore.min&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;jquery&quot;</span>,<span class="string">&quot;underscore&quot;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$,_</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="暴露-定义-模块-1"><a href="#暴露-定义-模块-1" class="headerlink" title="暴露(定义)模块"></a>暴露(定义)模块</h4><p><code>define(id?, dependencies?, factory)</code></p><ul><li>id: 一个字符串，表示模块的名称，但是是可选的</li><li>dependencies: 一个数组，是我们当前定义的模块要依赖于哪些模块，数组中的每一项表示的是要依赖模块的相对路径，且这个参数也是可选的</li><li>factory: 工厂方法，一个函数，这里面就是具体的模块内容了</li></ul><p>如果我们定义的模块本身依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义math.js模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add,</span><br><span class="line">        basicNum :basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义一个依赖underscore.js的模块</span></span><br><span class="line">define([<span class="string">&#x27;underscore&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">_</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> classify = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">    _.countBy(list,<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num &gt; <span class="number">30</span> ? <span class="string">&#x27;old&#x27;</span> : <span class="string">&#x27;young&#x27;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    classify :classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="引用模块"><a href="#引用模块" class="headerlink" title="引用模块"></a>引用模块</h4><p>引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入requirejs模块</span></span><br><span class="line"><span class="keyword">var</span> requirejs = <span class="built_in">require</span>(<span class="string">&quot;requirejs&quot;</span>);</span><br><span class="line"></span><br><span class="line">requirejs([<span class="string">&#x27;math&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(math)</span><br><span class="line">  <span class="built_in">console</span>.log(math.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用模块，将模块放在[]内</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;math&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = math.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">  $(<span class="string">&quot;#sum&quot;</span>).html(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h3><blockquote><p>CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。</p></blockquote><p>require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** AMD写法 **/</span></span><br><span class="line">define([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">      b.foo()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行，只有到require时依赖模块才执行。此规范其实是在sea.js推广过程中产生的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** CMD写法 **/</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>); <span class="comment">//在需要时申明</span></span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** sea.js **/</span></span><br><span class="line"><span class="comment">// 定义模块 math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery.js&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exports</span>.add = add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">&#x27;math.js&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = math.add(<span class="number">1</span>+<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="AMD和CMD的区别。"><a href="#AMD和CMD的区别。" class="headerlink" title="AMD和CMD的区别。"></a>AMD和CMD的区别。</h4><blockquote><p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同，二者皆为异步加载模块。</p></blockquote><p>虽然它们的define()方法的参数都相同，但是:</p><p>AMD中会把当前模块的依赖模块放到dependencies中加载，并在factory回调中拿到加载成功的依赖CMD一般不在dependencies中加载，而是写在factory中，使用require加载某个依赖模块<br>因此才有了我们常常看到的一句话：</p><p>还是上面那句话，让我们来看个小例子理解一下。</p><p>同样是math模块中需要加载m1模块。</p><p>在AMD中我们会这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define([<span class="string">&#x27;m1&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是math, 我被加载了...&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(m1.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    add: add,</span><br><span class="line">    print: print</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是对于CMD，我们会这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是math, 我被加载了...&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;m1&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(m1.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add: add,</span><br><span class="line">    print: print</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>假如此时m1.js中有一个语句是在m1模块被加载的时候打印出”我是m1, 我被加载了…”。</p><p>执行结果区别：</p><p>AMD，会先加载m1，”我是m1”会先执行CMD，我是”我是math”会先执行，因为本题中console.log(‘我是math, 我被加载了…’)是放在require(‘m1’)前面的。<br>现在可以很明显的看到区别了。<br>AMD依赖前置，js很方便的就知道要加载的是哪个模块了，因为已经在define的dependencies参数中就定义好了，会立即加载它。</p><p>CMD是就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块。<br>OK👌，来看个总结：</p><p>两者之间，最明显的区别就是在模块定义时对依赖的处理不同</p><ul><li>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</li><li>CMD推崇就近依赖，只有在用到某个模块的时候再去require</li></ul><h3 id="ES6-Modules规范"><a href="#ES6-Modules规范" class="headerlink" title="ES6 Modules规范"></a>ES6 Modules规范</h3><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p><h4 id="export导出模块"><a href="#export导出模块" class="headerlink" title="export导出模块"></a>export导出模块</h4><p>export有两种模块导出方式：</p><ul><li>命名式导出(名称导出)</li><li>默认导出(自定义导出)</li></ul><ol><li><p>命名式导出</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种为错误</span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为正确</span></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; a &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 接口名与模块内部变量之间，建立了一一对应的关系</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 接口名与模块内部变量之间，建立了一一对应的关系</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者用 as 来命名</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; a <span class="keyword">as</span> outA &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; a <span class="keyword">as</span> outA, b <span class="keyword">as</span> outB &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 容易混淆的可能是2和4两种写法了，看着很像，但是2却不行。2直接导出一个值为1的变量是和情况一一样，没有什么意义，因为你在后面要用的时候并不能完成解构。</p><p> 但是4中，接口名与模块内部变量之间，建立了一一对应的关系，所以可以。</p></li><li><p>默认导出</p><p> 默认导出会在export后面加上一个default：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; a &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 可以导出一个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span>()</span>&#123;&#125;; <span class="comment">// 也可以出一个类</span></span><br><span class="line">复制代码</span><br><span class="line">其实，默认导出可以理解为另一种形式上的命名导出，也就是说a这个属性名相当于是被我重写了成了<span class="keyword">default</span>：</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> defalut a;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">export</span> &#123; a <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br></pre></td></tr></table></figure><p> 所以，我们才可以用const a = 1; export default a;这种方式导出一个值。</p><h4 id="import导入模块"><a href="#import导入模块" class="headerlink" title="import导入模块"></a>import导入模块</h4><p>import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。</p></li><li><p>写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某个模块的导出 moudule.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块导入</span></span><br><span class="line"><span class="comment">// 1. 这里的a得和被加载的模块输出的接口名对应</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 as 换名</span></span><br><span class="line"><span class="keyword">import</span> &#123; a <span class="keyword">as</span> myA &#125; <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 若是只想要运行被加载的模块可以这样写，但是即使加载2次也只是运行一次</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./module&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 整体加载</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. default接口和具名接口</span></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">module</span>, &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span></span><br></pre></td></tr></table></figure><p>第四种写法会获取到module中所有导出的东西，并且赋值到module这个变量下，这样我们就可以用module.a这种方式来引用a了。</p></li><li><p>export … from…</p></li></ol><p>其实还有一种写法，可以将export和from结合起来用。<br>例如，我有三个模块a、b、c。<br>c模块现在想要引入a模块，但是它不不直接引用a，而是通过b模块来引用，那么你可能会想到b应该这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; someVariable &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; someVariable &#125;;</span><br></pre></td></tr></table></figure><p>引入someVariable然后再导出。<br>这还只是一个变量，我们得导入再导出，若是有很多个变量需要这样，那无疑会增加很多代码量。<br>所以这时候可以用下面这种方式来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; someVariable &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>不过这种方式有一点需要注意：</p><p>这样的方式不会将数据添加到该聚合模块的作用域, 也就是说, 你无法在该模块(也就是b)中使用someVariable。</p><h4 id="ES6-Modules规范的特点"><a href="#ES6-Modules规范的特点" class="headerlink" title="ES6 Modules规范的特点"></a>ES6 Modules规范的特点</h4><p>总结一下它的特点哈：</p><ul><li>输出使用export</li><li>输入使用import</li><li>可以使用export…from…这种写法来达到一个”中转”的效果</li><li>输入的模块变量是不可重新赋值的，它只是个可读引用，不过却可以改写属性</li><li>export命令和import命令可以出现在模块的任何位置，只要处于模块顶层就可以。 如果处于块级作用域内，就会报错，这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。</li><li>import命令具有提升效果，会提升到整个模块的头部，首先执行。</li></ul><h4 id="Bable下的ES6模块转换"><a href="#Bable下的ES6模块转换" class="headerlink" title="Bable下的ES6模块转换"></a>Bable下的ES6模块转换</h4><p>还有一点就是，如果你有使用过一些ES6的Babel的话，你会发现当使用export/import的时候，Babel也会把它转换为exports/require的形式。<br>例如我的输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>我的输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index.js:</span><br><span class="line"><span class="keyword">import</span> &#123;count&#125; <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(count)</span><br></pre></td></tr></table></figure><p>当使用Babel编译之后，各自会被转换为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m1.js:</span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123;</span><br><span class="line">  value: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">exports</span>.count = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exports</span>.count = count;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index.js:</span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _m = <span class="built_in">require</span>(<span class="string">&quot;./m1.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_m.count);</span><br></pre></td></tr></table></figure><p>正是因为这种转换关系，才能让我们把exports和import结合起来用：<br>也就是说你可以这样用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出模块 m1.js</span></span><br><span class="line"><span class="built_in">exports</span>.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js中引入</span></span><br><span class="line"><span class="keyword">import</span> &#123;count&#125; <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(count)</span><br></pre></td></tr></table></figure><h3 id="CommonJS与ES6-Modules规范的区别"><a href="#CommonJS与ES6-Modules规范的区别" class="headerlink" title="CommonJS与ES6 Modules规范的区别"></a>CommonJS与ES6 Modules规范的区别</h3><ol><li><p>CommonJS输出是值的拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变</p><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul></li><li><p>CommonJS模块是运行时加载，ES6 Modules是编译时输出接口</p><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li></ul></li></ol><pre><code>- 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</code></pre><ol start="3"><li>CommonJS加载的是整个模块，将所有的接口全部加载进来，ES6 Module可以单独加载其中的某个接口；</li><li>CommonJs导入的模块路径可以是一个表达式，因为它使用的是require()方法；而ES6 Modules只能是字符串</li><li>CommonJS this指向当前模块，ES6 Modules this指向undefined</li><li>且ES6 Modules中没有这些顶层变量：arguments、require、module、exports、__filename、__dirname</li></ol><p>关于第2个差异，是因为CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>目前浏览器对ES6 Module兼容还不太好，我们平时在webpack中使用的export/import，会被打包为exports/require。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903576309858318">前端模块化：CommonJS,AMD,CMD,ES6</a></li><li><a href="https://juejin.cn/post/6844904145443356680">CommonJS和ES6模块规范讲解</a></li><li><a href="https://juejin.cn/post/6844903520865386510#heading-1">import、require、export、module.exports 混合使用详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;模块化&quot;&gt;&lt;a href=&quot;#模块化&quot; class=&quot;headerlink&quot; title=&quot;模块化&quot;&gt;&lt;/a&gt;模块化&lt;/h2&gt;&lt;p&gt;模块化的开发方式可以
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之Promise</title>
    <link href="http://github.com/2021/01/20/JS%E4%B9%8BPromise/"/>
    <id>http://github.com/2021/01/20/JS%E4%B9%8BPromise/</id>
    <published>2021-01-19T16:00:00.000Z</published>
    <updated>2021-01-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="Promise-初探"><a href="#Promise-初探" class="headerlink" title="Promise 初探"></a>Promise 初探</h2><h3 id="什么是-Promise？"><a href="#什么是-Promise？" class="headerlink" title="什么是 Promise？"></a>什么是 Promise？</h3><p>Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。现已被 ES6 纳入进规范中。</p><p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p><h3 id="Promise-出现的原因"><a href="#Promise-出现的原因" class="headerlink" title="Promise 出现的原因"></a>Promise 出现的原因</h3><ol><li>为了解决回调地狱带来的负面作用<ul><li>代码臃肿。</li><li>可读性差。</li><li>耦合度过高，可维护性差。</li><li>代码复用性差。</li><li>容易滋生 bug。</li><li>只能在回调里处理异常。</li></ul></li><li>解决异步嵌套的问题。</li></ol><h3 id="Promise-如何使用？常用的方法有哪些？它们的作用是什么？"><a href="#Promise-如何使用？常用的方法有哪些？它们的作用是什么？" class="headerlink" title="Promise 如何使用？常用的方法有哪些？它们的作用是什么？"></a>Promise 如何使用？常用的方法有哪些？它们的作用是什么？</h3><h4 id="1-new-Promise"><a href="#1-new-Promise" class="headerlink" title="1. new Promise"></a>1. new Promise</h4><p>首先，我们先看看如何走一个 new Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(resolve); <span class="comment">// [Function]</span></span><br><span class="line">  <span class="built_in">console</span>.log(reject); <span class="comment">// [Function]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise); <span class="comment">// Promise &#123; &lt;pending&gt; &#125;</span></span><br></pre></td></tr></table></figure><p>然后，我们对这几个概念进行区分：</p><ol><li><p>Promise 对象是一个构造函数，用来生成 Promise 实例，所以 new Promise() 不足奇怪。</p></li><li><p>new Promise() 传入一个函数，这个函数可以带 2 个参数：resolve 和 reject。</p></li><li><p>resolve 的作用是将 Promise 对象的状态从 “未完成” 变为 “成功”（pending -&gt; resolved）</p></li><li><p>reject 的作用是将 Promise 对象的状态从 “未完成” 变为 “失败”（pending -&gt; rejected）</p></li><li><p>在没有执行 resolve 和 reject 之前，它们还是 pending 的。</p><h4 id="2-Promise-状态"><a href="#2-Promise-状态" class="headerlink" title="2. Promise 状态"></a>2. Promise 状态</h4></li><li><p>Promise 有 3 种状态：pending、fulfilled、rejected</p><ul><li><p>初始状态：pending</p></li><li><p>成功状态：fulfilled（实际打印会看到 resolved）</p></li><li><p>失败状态：rejected</p><p>如果你在 new Promise 中用了 resolve()，那么它就会走 .then()；</p><p>如果你用的是 reject()，那么它就走 .catch()。</p></li></ul></li><li><p>Promise 的状态一经改变就不能再进行更改。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;成功 1&#x27;</span>);</span><br><span class="line">  reject(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">  resolve(<span class="string">&#x27;成功 2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;res：&#x27;</span>, res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err：&#x27;</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出啥？=&gt; res： 成功 1</span></span><br></pre></td></tr></table></figure></li><li><p>Promise 也是不允许返回的：</p><p> 你将状态改为了 resolved，那么就不能再改了，只能.then()！</p></li></ol><h3 id="Promise也有一些缺点。"><a href="#Promise也有一些缺点。" class="headerlink" title="Promise也有一些缺点。"></a>Promise也有一些缺点。</h3><ol><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ol><p>如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。</p><h3 id="基本用法-API"><a href="#基本用法-API" class="headerlink" title="基本用法(API)"></a>基本用法(API)</h3><ol><li>Promise.resolve(value)<blockquote><p>类方法，该方法返回一个以 value 值解析后的 Promise 对象</p></blockquote></li></ol><ul><li>如果这个值是个 thenable（即带有 then 方法），返回的 Promise 对象会“跟随”这个 thenable 的对象，采用它的最终状态（指 resolved/rejected/pending/settled）</li><li>如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。</li><li>其他情况以该值为成功状态返回一个 Promise 对象。</li></ul><p>上面是 resolve 方法的解释，传入不同类型的 value 值，返回结果也有区别。</p><ol><li><p>如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="number">123</span>);</span><br><span class="line">    &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p0 = <span class="keyword">new</span> <span class="built_in">Promise</span>(fn);</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(p0);</span><br><span class="line"><span class="comment">// 返回为true，返回的 Promise 即是 入参的 Promise 对象。</span></span><br><span class="line"><span class="built_in">console</span>.log(p0 === p1);</span><br></pre></td></tr></table></figure><ol start="2"><li>传入 thenable 对象，返回 Promise 对象跟随 thenable 对象的最终状态。</li></ol><p>ES6 Promises 里提到了 Thenable 这个概念，简单来说它就是一个非常类似 Promise 的东西。最简单的例子就是 jQuery.ajax，它的返回值就是 thenable 对象。但是要谨记，并不是只要实现了 then 方法就一定能作为 Promise 对象来使用。</p><p>如果传入的 value 本身就是 thenable 对象，返回的 promise 对象会跟随 thenable 对象的状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">&#x27;/test/test.json&#x27;</span>));<span class="comment">// =&gt; promise对象</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>返回一个状态已变成 resolved 的 Promise 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">123</span>); </span><br><span class="line"><span class="comment">//打印p1 可以看到p1是一个状态置为resolved的Promise对象</span></span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br></pre></td></tr></table></figure><ol start="2"><li>Promise.reject</li></ol><p>类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。</p></li></ol><ol start="3"><li><p>Promise.prototype.then</p><p> 实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。</p></li><li><p>Promise.prototype.catch</p><p> 实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息。</p></li><li><p>Promise.prototype.finally()</p><p> finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。finally方法里面的操作，是与状态无关的，不依赖于 Promise 的执行结果。该方法是 ES2018 引入标准的。</p></li></ol><ol start="6"><li><p>Promise.race()</p><p> 类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败。<br> 。</p></li><li><p>Promise.all()</p><p> 类方法，多个 Promise 任务同时执行。<br> 如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。  如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p2])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;等到两个异步完成后，再执行&#x27;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>Promise.any()</p><p> ES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</p><p> Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。</p></li><li><p>Promise.allSettled()</p><p> Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 ES2020 引入。</p></li></ol><h2 id="Promise的一些应用"><a href="#Promise的一些应用" class="headerlink" title="Promise的一些应用"></a>Promise的一些应用</h2><ol><li><p>加载图片</p><p> 我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>用Promise对象实现的 Ajax 操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="built_in">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">&quot;/posts.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Contents: &#x27;</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="co-Generator-方式"><a href="#co-Generator-方式" class="headerlink" title="co + Generator 方式"></a>co + Generator 方式</h2><p>利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> r1 = <span class="keyword">yield</span> readFilePromise(<span class="string">&#x27;1.json&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> r2 = <span class="keyword">yield</span> readFilePromise(<span class="string">&#x27;2.json&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> r3 = <span class="keyword">yield</span> readFilePromise(<span class="string">&#x27;3.json&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> r4 = <span class="keyword">yield</span> readFilePromise(<span class="string">&#x27;4.json&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h2><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><blockquote><p>async 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用await 表明当前函数是异步函数 不会阻塞线程导致后续代码停止运行。</p></blockquote><p>async 函数的返回值很特殊: 不管在函数体内 return 了什么值, async 函数的实际返回值总是一个 Promise 对象. 详细讲就是:若在 async 函数中 return 了一个值 a, 不管 a 值是什么类型, async 函数的实际返回值总是 Promise.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve(a)<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(asyncFn())</span><br><span class="line"><span class="comment">//Promise &#123;&lt;resolved&gt;: &quot;hello world&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>如果函数内部抛出异常或者是返回reject，都会使函数的promise状态为失败reject。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;has Error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">asyncFn()</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// Error: has Error</span></span><br></pre></td></tr></table></figure><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>await意思是async wait(异步等待)。这个关键字只能在使用async定义的函数里面使用。任何async函数都会默认返回promise，并且这个promise解析的值都将会是这个函数的返回值，而async函数必须等到内部所有的 await 命令的 Promise 对象执行完，才会发生状态改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsonAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> axios.get(<span class="string">&#x27;api/user&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">getJsonAsync()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.data)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>笔试题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncfn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">await</span> asyncfn2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncfn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">asyncfn1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><ol><li>打印 “1” </li><li>遇到setTimeout,setTimeout是宏任务,将它放在宏任务队列中</li><li>执行 asyncfn1  打印 “2”遇到await关键字，先执行关键字后面的 asyncfn2函数 打印：”4”,因为await关键字将这块代码asyncContext挂起并执行上级 上下文 所以先打印了”5”,执行完后回到 async context 打印 “3” </li><li>最后打印 “setTimeout”</li></ol><p>加入Promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>重点：</p><ol><li>执行到 await async2()，发现 async2 也是个 async 定义的函数，所以直接执行了“console.log(‘async2’)”，同时async2返回了一个Promise，划重点：此时返回的Promise会被放入到回调队列中等待，await会让出线程（js是单线程还用我介绍吗），接下来就会跳出 async1函数 继续往下执行。</li><li>然后执行到 new Promise，前面说过了promise是立即执行的，所以先打印出来“promise1”，然后执行到 resolve 的时候，resolve这个任务就被放到回调队列中等待，然后跳出Promise继续往下执行，输出“script end”。 </li><li>同步的事件都循环执行完了，调用栈现在已经空出来了，那么事件循环就会去回调队列里面取任务继续放到调用栈里面了。</li></ol><h3 id="async-await-能代替Promise吗"><a href="#async-await-能代替Promise吗" class="headerlink" title="async/await 能代替Promise吗"></a>async/await 能代替Promise吗</h3><p>使用Async / Await时，我们仍在使用Promise。从长远来看，对Promise的良好理解实际上对您有很大的好处。<br>甚至有一些用例Async / Await并不能解决问题，我们不得不回到Promise上<br>一个这样的场景</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903625609707534">面试精选之Promise</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise">ECMAScript 6 入门(阮一峰)</a></li><li><a href="https://blog.csdn.net/weixin_37719279/article/details/80950713">ES6之Promise常见面试题</a></li><li><a href="https://juejin.cn/post/6844903509934997511">Promise 必知必会（十道题）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;Promise-初探&quot;&gt;&lt;a href=&quot;#Promise-初探&quot; class=&quot;headerlink&quot; title=&quot;Promise 初探&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之EventLoop(事件循环)</title>
    <link href="http://github.com/2021/01/20/JS%E4%B9%8BEventLoop(%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF)/"/>
    <id>http://github.com/2021/01/20/JS%E4%B9%8BEventLoop(%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF)/</id>
    <published>2021-01-19T16:00:00.000Z</published>
    <updated>2021-01-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="一-浏览器中的Event-Loop"><a href="#一-浏览器中的Event-Loop" class="headerlink" title="一 浏览器中的Event Loop"></a>一 浏览器中的Event Loop</h2><blockquote><p>Event Loop 即事件循环，是指浏览器或 Node 的一种解决 JavaScript 单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。</p></blockquote><h3 id="单线程和多线程"><a href="#单线程和多线程" class="headerlink" title="单线程和多线程"></a>单线程和多线程</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>JavaScript 是一个单线程的语言。</p><p>单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。</p><p>以 Chrome 浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程。</p><p>一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。</p><p>当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p><h4 id="浏览器内核是怎样的？"><a href="#浏览器内核是怎样的？" class="headerlink" title="浏览器内核是怎样的？"></a>浏览器内核是怎样的？</h4><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用 CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p><p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p><ul><li>GUI 渲染线程：解析 HTML、CSS 等。在 JavaScript 引擎线程运行脚本期间，GUI 渲染线程处于挂起状态，也就是被 “冻结” 了。</li><li>JavaScript 引擎线程：负责处理 JavaScript 脚本。</li><li>定时触发器线程：setTimeout、setInterval 等。事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行。</li><li>事件触发线程：负责将准备好的事件交给 JS 引擎执行。</li><li>异步 http 请求线程：负责执行异步请求之类函数的线程，例如 Promise.then()、ajax 等。</li></ul><ol><li><p>GUI 渲染线程</p><p> 主要负责页面的渲染，解析 HTML、CSS，构建 DOM 树，布局和绘制等。<br> 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。<br> 该线程与 JS 引擎线程互斥，当执行 JS 引擎线程时，GUI 渲染会被挂起，当任务队列空闲时，JS 引擎才会去执行 GUI 渲染。</p></li><li><p>JS 引擎线程</p><p> 该线程当然是主要负责处理 JavaScript 脚本，执行代码。<br> 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS 引擎线程的执行。<br> 当然，该线程与 GUI 渲染线程互斥，当 JS 引擎线程执行 JavaScript 脚本时间过长，将导致页面渲染的阻塞。</p></li><li><p>定时器触发线程</p><p> 负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。<br> 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行。</p></li><li><p>事件触发线程</p><p> 主要负责将准备好的事件交给 JS 引擎线程执行。<br> 比如 setTimeout 定时器计数结束， ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS 引擎线程的执行。</p></li><li><p>异步 http 请求线程</p><p> 负责执行异步请求一类的函数的线程，如： Promise，axios，ajax 等。<br> 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待 JS 引擎线程执行。</p><h4 id="为什么不设计成多线程？"><a href="#为什么不设计成多线程？" class="headerlink" title="为什么不设计成多线程？"></a>为什么不设计成多线程？</h4><p>JS是可以去操作DOM的。</p></li></ol><p>假设有个 DOM 节点，现在有线程 A 操作它，删除了这个 DOM；<br>然后线程 B 又操作它，修改了这个 DOM 某部分。<br>这肯定不可以。（多线程可以互不干预的操作一段内存空间）<br>所以干脆设计成一个单线程，安全稳妥不出事。</p><p>哪怕后期 HTML5 出了个 Web Worker 也是不允许操作 DOM 结构的，可以完成一些分布式的计算。</p><p>对于dom结构我们必须顺序操纵，坚决不允许出现对同一个dom同时进行操作。</p><h4 id="为什么需要异步？"><a href="#为什么需要异步？" class="headerlink" title="为什么需要异步？"></a>为什么需要异步？</h4><p>这时候又有问题了，如果调用某个接口（Ajax），或者加载某张图片的时候，我们卡住了，这样页面是不是就一直不能渲染？</p><p>然后因为单线程只能先让前面的程序走完，即便这个接口或者图片缓过来了，我下面还有其他任务没做呢，这不就卡死了么？</p><p>所以这时候异步来了：</p><p>在涉及某些需要等待的操作的时候，我们就选择让程序继续运行。</p><p>等待接口或者图片返回过来后，就通知程序我做好了，你可以继续调用了。</p><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><h4 id="为什么会有-Event-Loop？"><a href="#为什么会有-Event-Loop？" class="headerlink" title="为什么会有 Event Loop？"></a>为什么会有 Event Loop？</h4><p>JavaScript 线程一次只能做一件事。<br>如果碰到一些需要等待的程序，例如 setTimeout 等，那就歇菜了。<br>所以，JavaScript 为了协调事件、用户交互、脚本、渲染、网络等，就搞出来一个 事件循环（Event Loop）。</p><h4 id="什么是-Event-Loop？"><a href="#什么是-Event-Loop？" class="headerlink" title="什么是 Event Loop？"></a>什么是 Event Loop？</h4><p>JavaScript 从 script 开始读取，然后不断循环，从 “<code>任务队列</code>” 中读取执行事件的过程，就是 事件循环（<code>Event Loop</code>）。</p><h4 id="Event-Loop-执行过程"><a href="#Event-Loop-执行过程" class="headerlink" title="Event Loop 执行过程"></a>Event Loop 执行过程</h4><p>Event Loop 执行过程如下：</p><ol><li>一开始整个脚本 script 作为一个宏任务执行</li><li>执行过程中，同步代码 直接执行，宏任务 进入宏任务队列，微任务 进入微任务队列。</li><li>当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完毕。</li><li>执行浏览器 UI 线程的渲染工作。</li><li>检查是否有 Web Worker 任务，有则执行。</li><li>执行完本轮的宏任务，回到步骤 2，依次循环，直到宏任务和微任务队列为空。</li></ol><p>事件循环中的异步队列有两种：宏任务队列（MacroTask）和 微任务队列（MicroTask）。</p><p>Web Worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。</p><h4 id="宏任务队列可以有多个，微任务队列只有一个。"><a href="#宏任务队列可以有多个，微任务队列只有一个。" class="headerlink" title="宏任务队列可以有多个，微任务队列只有一个。"></a>宏任务队列可以有多个，微任务队列只有一个。</h4><p>宏任务 包括：</p><ul><li>script</li><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I/O</li><li>UI rendering</li></ul><p>微任务 包括：</p><ul><li>MutationObserver(html5 新特性)</li><li>Promise.then()/catch()</li><li>以 Promise 为基础开发的其他技术，例如 fetch API</li><li>V8 的垃圾回收过程</li><li>Node 独有的 process.nextTick</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ol><li><p>案例一</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise1&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p> 最后输出结果是 Promise1，setTimeout1，Promise2，setTimeout2</p><p> 一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出 Promise1，同时会生成一个宏任务 setTimeout2<br> 然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1<br> 在执行宏任务 setTimeout1 时会生成微任务 Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2<br> 清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</p></li><li><p>案例二</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： script start</span></span><br><span class="line"><span class="comment">//       async2 end</span></span><br><span class="line"><span class="comment">//       Promise</span></span><br><span class="line"><span class="comment">///      script end</span></span><br><span class="line"><span class="comment">//       async1 end</span></span><br><span class="line"><span class="comment">//       promise1</span></span><br><span class="line"><span class="comment">//       promise2</span></span><br><span class="line"><span class="comment">//       setTimeout</span></span><br></pre></td></tr></table></figure></li></ol><p>这里需要先理解async/await。<br>async/await 在底层转换成了 promise 和 then 回调函数。<br>也就是说，这是 promise 的语法糖。<br>每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。<br>async/await 的实现，离不开 Promise。从字面意思来理解，async 是“异步”的简写，而 await 是 async wait 的简写可以认为是等待异步方法执行完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> p</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化理解为：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> RESOLVE(p).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="node中的event-loop"><a href="#node中的event-loop" class="headerlink" title="node中的event loop"></a>node中的event loop</h2><h3 id="三大关键阶段"><a href="#三大关键阶段" class="headerlink" title="三大关键阶段"></a>三大关键阶段</h3><p>首先，梳理一下 nodejs 三个非常重要的执行阶段:</p><ol><li>执行 定时器回调 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout、setInterval。这个阶段暂且叫它timer。</li></ol><ol start="2"><li><p>轮询(英文叫poll)阶段。因为在node代码中难免会有异步操作，比如文件I/O，网络I/O等等，那么当这些异步操作做完了，就会来通知JS主线程，怎么通知呢？就是通过’data’、’connect’等事件使得事件循环到达 poll 阶段。到达了这个阶段后:</p><p> 如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到timer阶段。</p><p> 如果没有定时器, 会去看回调函数队列。</p><p> 如果队列不为空，拿出队列中的方法依次执行</p><p> 如果队列为空，检查是否有 setImmdiate 的回调</p><p> 有则前往check阶段(下面会说)</p><p> 没有则继续等待，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后自动进入 check 阶段。</p></li><li><p>check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。</p></li></ol><p>这三个阶段为一个循环过程。不过现在的eventLoop并不完整，我们现在就来一一地完善。</p><h3 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h3><p>首先，当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 I/O异常的回调阶段。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。</p><p>并且在 check 阶段结束后还会进入到 关闭事件的回调阶段。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()，<br>‘close’ 事件的回调就会在这个阶段执行。</p><p>梳理一下，nodejs 的 eventLoop 分为下面的几个阶段:</p><ol><li>timer 阶段</li><li>I/O 异常回调阶段</li><li>空闲、预备状态(第2阶段结束，poll 未触发之前)</li><li>poll 阶段</li><li>check 阶段</li><li>关闭事件的回调阶段</li></ol><h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这里我要说，node版本 &gt;= 11和在 11 以下的会有不同的表现。<br>首先说 node 版本 &gt;= 11的，它会和浏览器表现一致，一个定时器运行完立即运行相应的微任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">time2</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure><p>而 node 版本小于 11 的情况下，对于定时器的处理是:</p><p>若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务。</p><p>因此会打印出这样的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure><h3 id="关于process-nextTick的一点说明"><a href="#关于process-nextTick的一点说明" class="headerlink" title="关于process.nextTick的一点说明"></a>关于process.nextTick的一点说明</h3><p>process.nextTick 是一个独立于 eventLoop 的任务队列。<br>在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。</p><h2 id="nodejs-和-浏览器关于eventLoop的主要区别"><a href="#nodejs-和-浏览器关于eventLoop的主要区别" class="headerlink" title="nodejs 和 浏览器关于eventLoop的主要区别"></a>nodejs 和 浏览器关于eventLoop的主要区别</h2><p>两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。</p><h3 id="为啥会有-浏览器-Event-Loop-和-Node-js-Event-Loop？"><a href="#为啥会有-浏览器-Event-Loop-和-Node-js-Event-Loop？" class="headerlink" title="为啥会有 浏览器 Event Loop 和 Node.js Event Loop？"></a>为啥会有 浏览器 Event Loop 和 Node.js Event Loop？</h3><p>简单来说：</p><p>你的页面放到了浏览器去展示，你的数据放到了后台处理（将 Node.js 看成 PHP、Java 等后端语言），这两者能没有区别么？！<br>再仔细一点：</p><ul><li>Node.js：Node.js 的 Event Loop 是基于 libuv。libuv 已经对 Node.js 的 Event Loop 作出了实现。</li><li>浏览器：浏览器的 Event Loop 是基于 HTML5 规范 的。而 HTML5 规范中只是定义了浏览器中的 Event Loop 的模型，具体实现留给了浏览器厂商。<blockquote><p>libuv 是一个多平台支持库，主要用于异步 I/O。它最初是为 Node.js 开发的，现在 Luvit、Julia、pyuv 和其他的框架也使用它。</p></blockquote></li></ul><h2 id="浏览器与Node执行顺序的对比"><a href="#浏览器与Node执行顺序的对比" class="headerlink" title="浏览器与Node执行顺序的对比"></a>浏览器与Node执行顺序的对比</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">浏览器输出：</span></span><br><span class="line"><span class="comment">time1</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">time2</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Node输出：</span></span><br><span class="line"><span class="comment">time1</span></span><br><span class="line"><span class="comment">time2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><ul><li><p>在这个例子中，Node的逻辑如下：</p><p>最初timer1和timer2就在timers阶段中。开始时首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；<br>至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2。</p><p>而浏览器则因为两个setTimeout作为两个MacroTask, 所以先输出timer1, promise1，再输出timer2，promise2。</p></li><li><p>为了证明我们的理论，把代码改成下面的样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Node输出：</span></span><br><span class="line"><span class="comment">timer1               timer2</span></span><br><span class="line"><span class="comment">promise1    或者     promise2</span></span><br><span class="line"><span class="comment">timer2               timer1</span></span><br><span class="line"><span class="comment">promise2             promise1</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></li></ul><p>按理说setTimeout(fn,0)应该比setImmediate(fn)快，应该只有第二种结果，为什么会出现两种结果呢？<br>这是因为Node 做不到0毫秒，最少也需要1毫秒。实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。</p><p>另外，如果已经过了Timer阶段，那么setImmediate会比setTimeout更快，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;test.js&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line">  setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，setImmediate才会早于setTimeout执行。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000013861128">一篇文章教会你Event loop——浏览器和Node</a></li><li><a href="https://juejin.cn/post/6844904004007247880#heading-10">原生JS灵魂之问(下)</a></li><li><a href="https://zhuanlan.zhihu.com/p/54882306">浏览器与Node的事件循环(Event Loop)有何区别?</a></li><li><a href="https://juejin.cn/post/6844903764202094606#heading-0">一次弄懂Event Loop（彻底解决此类面试问题）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;一-浏览器中的Event-Loop&quot;&gt;&lt;a href=&quot;#一-浏览器中的Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;一 
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之作用域和执行上下文篇</title>
    <link href="http://github.com/2021/01/15/JS%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AF%87/"/>
    <id>http://github.com/2021/01/15/JS%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AF%87/</id>
    <published>2021-01-14T16:00:00.000Z</published>
    <updated>2021-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h3 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>1.概念</p><ul><li><p>作用域是指程序源代码中定义变量的区域。</p><p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p></li><li><p>静态作用域与动态作用域区别</p><p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p><p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p></li></ul><ol start="2"><li>案例理解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value &#x3D; 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结果是 1</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>静态作用域分析</p><p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p></li><li><p>动态作用域分析</p><p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p></li></ul><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><blockquote><p>JavaScript引擎并非一行一行地分析和执行程序，而是一段一段地分析，顺序执行。</p></blockquote><ul><li><p>概念</p><p>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p></li><li><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul></li><li><p>可执行代码</p><ul><li><p>js的可执行代码(executable code)的类型：全局代码、函数代码、eval代码。</p></li><li><p>举个例子</p><p>当javaScript引擎执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution contexts)”</p></li></ul></li><li><p>JavaScript 中有 3 种执行上下文类型：</p><ol><li>全局执行上下文：这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li>函数执行上下文：每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤。</li><li>Eval 函数执行上下文：执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。</li></ol></li></ul><h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>执行栈，也就是在其它编程语言中所说的 “调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。</p><p>当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p><p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><h4 id="模拟理解"><a href="#模拟理解" class="headerlink" title="模拟理解"></a>模拟理解</h4><p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [];</span><br></pre></td></tr></table></figure><p>  试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>JavaScript 遇到下面的这段代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fun3() &#123;</span><br><span class="line">    console.log(&#39;fun3&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun2() &#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure><p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 伪代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun1()</span><br><span class="line">ECStack.push(&lt;fun1&gt; functionContext);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun1中竟然调用了fun2，还要创建fun2的执行上下文</span><br><span class="line">ECStack.push(&lt;fun2&gt; functionContext);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 擦，fun2还调用了fun3！</span><br><span class="line">ECStack.push(&lt;fun3&gt; functionContext);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun3执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun2执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun1执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span><br></pre></td></tr></table></figure><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><blockquote><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p></blockquote><p>因为不同执行上下文下的变量对象稍有不同，所以有全局上下文下的变量对象和函数上下文下的变量对象。</p><p>全局上下文中的变量对象就是全局对象</p><h4 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h4><ul><li><p>概念</p><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p><p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p></li><li><p>执行过程</p><ul><li>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做： 1.进入执行上下文   2.代码执行</li></ul></li><li><p>进入执行上下文</p><p>  当进入执行上下文时，这时候还没有执行代码，</p><p>变量对象会包括：</p><ol><li><p>函数的所有形参 (如果是函数上下文)</p><p> 由名称和对应值组成的一个变量对象的属性被创建<br> 没有实参，属性值设为 undefined</p></li><li><p>函数声明</p><p> 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建<br> 如果变量对象已经存在相同名称的属性，则完全替换这个属性</p></li><li><p>变量声明</p><p> 由名称和对应值（undefined）组成一个变量对象的属性被创建；<br> 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</p></li></ol></li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  var b &#x3D; 2;</span><br><span class="line">  function c() &#123;&#125;</span><br><span class="line">  var d &#x3D; function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b &#x3D; 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(1);</span><br></pre></td></tr></table></figure><p>在进入执行上下文后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: undefined,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行<br>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p><p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 3,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p><p>全局上下文的变量对象初始化是全局对象</p><p>函数上下文的变量对象初始化只包括 Arguments 对象</p><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p><p>在代码执行阶段，会再次修改变量对象的属性值</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><blockquote><p>本文参考网站：</p></blockquote><ul><li><a href="https://juejin.cn/post/6844903479429824526">JavaScript深入系列15篇</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h3 id=&quot;词法作用域和动态作用域&quot;&gt;&lt;a href=&quot;#词法作用域和动态作用域&quot; class=&quot;headerlink&quot; title=&quot;词法作用域和动态作用域&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之闭包篇</title>
    <link href="http://github.com/2021/01/15/JS%E4%B9%8B%E9%97%AD%E5%8C%85%E7%AF%87/"/>
    <id>http://github.com/2021/01/15/JS%E4%B9%8B%E9%97%AD%E5%8C%85%E7%AF%87/</id>
    <published>2021-01-14T16:00:00.000Z</published>
    <updated>2021-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结(copy)，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h3 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h3><h4 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h4><blockquote><p>红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，</p></blockquote><blockquote><p>MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。<br>（其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）</p></blockquote><p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量。</p><p>当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。</p><p>简单来说：</p><p>在函数 A 中还有函数 B，函数 B 调用了函数 A 中的变量，那么函数 B 就称为函数 A 的闭包。</p><h4 id="闭包产生的原因"><a href="#闭包产生的原因" class="headerlink" title="闭包产生的原因?"></a>闭包产生的原因?</h4><ul><li>首先要明白作用域链的概念，其实很简单，在ES5中只存在两种作用域————全局作用域和函数作用域，</li><li>当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，</li><li>值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。</li></ul><p>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">function f1() &#123;</span><br><span class="line">  var a &#x3D; 2</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    var a &#x3D; 3;</span><br><span class="line">    console.log(a);&#x2F;&#x2F;3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，f1的作用域指向有全局作用域(window)和它本身，而f2的作用域指向全局作用域(window)、f1和它本身。而且作用域是从最底层向上找，直到找到全局作用域window为止，如果全局还没有的话就会报错。</p><h4 id="闭包产生的本质"><a href="#闭包产生的本质" class="headerlink" title="闭包产生的本质"></a>闭包产生的本质</h4><p>闭包产生的本质就是，当前环境中存在指向父级作用域的引用。</p><p>还是举上面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var a &#x3D; 2</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    console.log(a);&#x2F;&#x2F;2</span><br><span class="line">  &#125;</span><br><span class="line">  return f2;</span><br><span class="line">&#125;</span><br><span class="line">var x &#x3D; f1();</span><br><span class="line">x();</span><br></pre></td></tr></table></figure><p>这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。<br>那是不是只有返回函数才算是产生了闭包呢？、<br>回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f3;</span><br><span class="line">function f1() &#123;</span><br><span class="line">  var a &#x3D; 2</span><br><span class="line">  f3 &#x3D; function() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line">f3();</span><br></pre></td></tr></table></figure><p>让f1执行，给f3赋值后，等于说现在f3拥有了window、f1和f3本身这几个作用域的访问权限，还是自底向上查找，最近是在f1中找到了a,因此输出2。<br>在这里是外面的变量f3存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变。</p><h3 id="闭包好处和坏处"><a href="#闭包好处和坏处" class="headerlink" title="闭包好处和坏处"></a>闭包好处和坏处</h3><ul><li><p>好处：</p><p>  缓存。将变量隐藏起来不被垃圾回收。<br>  加强封装性，可以达到对变量的保护作用。<br>  实现柯里化。利用闭包特性完成柯里化。</p></li><li><p>坏处：</p><p>  内存消耗。闭包产生的变量无法被销毁。<br>  性能问题。由于闭包内部变量优先级高于外部变量，所以需要多查找作用域链的一个层次，一定程度影响查找速度。</p><h3 id="闭包有哪些表现形式"><a href="#闭包有哪些表现形式" class="headerlink" title="闭包有哪些表现形式?"></a>闭包有哪些表现形式?</h3><p>哪些地方能体现闭包的存在？</p></li><li><p>返回一个函数。<br>刚刚已经举例。<br>作为函数参数传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">function foo()&#123;</span><br><span class="line">  var a &#x3D; 2;</span><br><span class="line">  function baz()&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(baz);</span><br><span class="line">&#125;</span><br><span class="line">function bar(fn)&#123;</span><br><span class="line">  &#x2F;&#x2F; 这就是闭包</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出2，而不是1</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></li><li><p>在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。</p><p>以下的闭包保存的仅仅是window和当前作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定时器</span><br><span class="line">setTimeout(function timeHandler()&#123;</span><br><span class="line">  console.log(&#39;111&#39;);</span><br><span class="line">&#125;，100)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 事件监听</span><br><span class="line">$(&#39;#app&#39;).click(function()&#123;</span><br><span class="line">  console.log(&#39;DOM Listener&#39;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2;</span><br><span class="line">(function IIFE()&#123;</span><br><span class="line">  &#x2F;&#x2F; 输出2</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ul><p>如何解决下面的循环输出问题？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 1; i &lt;&#x3D; 5; i ++)&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>为什么会全部输出6？如何改进，让它输出1，2，3，4，5？(方法越多越好)</p><p>因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。</p></li><li><p>解决方法：</p><p>1、利用IIFE(立即执行函数表达式)当每次for循环时，把此时的i变量传递到定时器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 1;i &lt;&#x3D; 5;i++)&#123;</span><br><span class="line">  (function(j)&#123;</span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line">      console.log(j)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、给定时器传入第三个参数, 作为timer函数的第一个函数参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i&#x3D;1;i&lt;&#x3D;5;i++)&#123;</span><br><span class="line">  setTimeout(function timer(j)&#123;</span><br><span class="line">    console.log(j)</span><br><span class="line">  &#125;, 0, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用ES6中的let</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i &#x3D; 1; i &lt;&#x3D; 5; i++)&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let使JS发生革命性的变化，让JS有函数作用域变为了块级作用域，用let后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; i &#x3D; 1</span><br><span class="line">&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; i &#x3D; 2</span><br><span class="line">&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; i &#x3D; 3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因此能输出正确的结果。</p></li></ul><blockquote><p>本文参考(copy)网站：</p></blockquote><ul><li><p><a href="https://juejin.cn/post/6844903974378668039">J原生JS灵魂之问</a></p></li><li><p><a href="https://juejin.cn/post/6844903769646317576#heading-1">发现 JavaScript 中闭包的强大威力</a></p></li><li><p><a href="http://blog.leapoahead.com/2015/09/15/js-closure/">JavaScript闭包的底层运行机制</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结(copy)，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h3 id=&quot;闭包的理解&quot;&gt;&lt;a href=&quot;#闭包的理解&quot; class=&quot;headerlink&quot; title=&quot;闭包的理解&quot;&gt;&lt;/a&gt;闭包的理解&lt;/h3
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
</feed>
