<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>覆水行舟的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2021-01-31T16:00:00.000Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>覆水行舟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器之本地存储</title>
    <link href="http://github.com/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BHTTP/"/>
    <id>http://github.com/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BHTTP/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="HTTP-发展史"><a href="#HTTP-发展史" class="headerlink" title="HTTP 发展史"></a>HTTP 发展史</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>传输体积很小的文件，没有 HTTP 请求头和请求体，服务器也不返回头信息。</p><p>HTTP/0.9 并没有考虑太过复杂的内容，仅仅是用来传输体积很小的文件。</p><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>核心诉求是支持多种类型的文件下载。加入了请求头和响应头支持多种不同类型的数据。以及状态码、Cache 机制、用户代理等。</p><p>应对 HTTP/0.9 出现的问题，进行了支持多类型文件下载等内容的优化。<br><br>HTTP/1.0 定义了三种请求方法：GET，POST 和 HEAD 方法。</p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><ol><li>改进了 <code>HTTP/1.0</code> 版本每次 <code>HTTP</code> 通信都需要建立 <code>TCP</code> 连接、传输 <code>HTTP</code> 数据再断开 <code>TCP</code> 连接的尴尬局面，支持持续连接。只要浏览器或者服务器没有明确断开连接，那么该 <code>TCP</code> 连接会一直保持（默认开启 <code>keep-alive</code>）。</li><li>如果 <code>TCP</code> 通道中某个请求因为某些原因没有及时返回，会阻塞后面所有请求（队头阻塞），所以 <code>HTTP/1.1 </code>通过管线化来解决队头阻塞的问题。</li><li><code>HTTP/1.0</code> 每个域名绑定唯一 <code>IP</code> 地址，一个服务器只能支持一个域名。<code>HTTP/1.1</code> 请求头增加 <code>Host</code> 字段，表示当前域名地址，服务器可以根据不同的 <code>Host</code> 值做不同的处理。这样一台物理主机就可以绑定多个虚拟主机，每个虚拟主机都有自己单独的域名。</li><li><code>HTTP/1.0</code> 需要在响应头设置完整的数据大小来接收数据，但是随着服务器端发展，很多页面动态生成，不知道传输数据的最终大小。<code>HTTP/1.1</code> 引入 <code>Chunk transfer</code> 机制来解决这个问题，服务器将数据分割成任意大小的数据块，每个数据块发送时附带上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志，从而支持了动态内容。</li><li>客户端 <code>Cookie</code>、安全机制。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>HTTP/1.1</code> 默认开启 <code>Connection: keep-alive</code>，让一个 <code>TCP </code>连接能重复发送/接收多次 <code>HTTP </code>请求。</li><li><code>HTTP/1.1</code>新增了六种请求方法：<code>OPTIONS</code>、<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>、<code>TRACE</code> 和 <code>CONNECT</code> 方法。</li></ul><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><ol><li>一个域名只使用一个 TCP 长连接和消除队头阻塞问题</li><li>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。HTTP/2.0 实现了一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</li><li>队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>头部压缩：HTTP/2 压缩消息头，减少了传输数据的大小</li><li>多路复用：即多个请求都通过一个 TCP 连接并发地完成</li><li>设置请求优先级</li><li>服务器推送：服务端能够主动把资源推送给客户端</li></ul><h3 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP/3.0"></a>HTTP/3.0</h3><ol><li>实现了类似 TCP 的流量控制、传输可靠性的功能。</li><li>集成了 TLS 加密功能。</li><li>实现了 HTTP/2 中的多路复用功能。</li><li>实现了快速握手功能。</li></ol><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="什么是http？"><a href="#什么是http？" class="headerlink" title="什么是http？"></a>什么是http？</h3><blockquote><p>超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP）</p></blockquote><p>Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器等一系列运作流程。而协议是指规则的约定。可以说，Web 是建立在 HTTP 协议上通信的。</p><p>HTTP 最初的目的是为了让研究者共享知识信息，所以它的主要作用就是文档传输，它是一种用于传输文档的协议。用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><h3 id="HTTP的优点："><a href="#HTTP的优点：" class="headerlink" title="HTTP的优点："></a>HTTP的优点：</h3><ol><li><strong><em>灵活可扩展</em></strong>，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</li><li><strong><em>可靠传输</em></strong>。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</li><li><strong><em>请求-应答</em></strong>。也就是一发一收、有来有回，当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</li><li><strong><em>无状态</em></strong>。这里的状态是指通信过程的上下文信息，而每次 HTTP 请求都是独立、无关的，默认不需要保留状态信息。</li></ol><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><ol><li><strong><em>无状态</em></strong>。在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 HTTP 的缺点了。</li><li><strong><em>明文传输</em></strong>。协议里的报文（主要指的是头部）不使用二进制数据，而是文本形式。</li><li><strong><em>队头阻塞问题</em></strong>。当 HTTP 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态。</li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="什么是https"><a href="#什么是https" class="headerlink" title="什么是https"></a>什么是https</h3><blockquote><p>https的SSL加密是在传输层实现的。</p></blockquote><p>以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p><p>简单来说 HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，比 HTTP 协议的安全性更高。</p><p>最后一个字母 S 指的是 SSL/TLS 协议，它位于 HTTP 协议与 TCP/IP 协议中间。</p><h3 id="https协议的工作原理"><a href="#https协议的工作原理" class="headerlink" title="https协议的工作原理"></a>https协议的工作原理</h3><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><ul><li>浏览器请求 URL，找到服务器，向服务器发送请求。服务器将自己的证书（包含服务器公钥）、对称加密算法种类以及其他相关信息返回给浏览器。</li><li>浏览器检查 CA 证书是否可依赖，确认证书有效。</li><li>如果不是，给服务器发警告，询问是否可以继续使用。</li><li>如果是，浏览器使用公钥加密一个随机对称秘钥，包含加密的 URL 一起发送给服务器。</li><li>服务器用自己的私钥解密浏览器发送的钥匙，然后用这把对称加密的钥匙给浏览器请求的 URL 连接解密。</li><li>服务器用浏览器发送的对称钥匙给请求的网页加密，浏览器使用相同的钥匙就可以解密网页。</li></ul><h3 id="https协议的优点"><a href="#https协议的优点" class="headerlink" title="https协议的优点"></a>https协议的优点</h3><ol><li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li><li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li></ol><h3 id="https协议的缺点"><a href="#https协议的缺点" class="headerlink" title="https协议的缺点"></a>https协议的缺点</h3><ol><li>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</li><li>https缓存不如http高效，会增加数据开销。</li><li>SSL证书也需要钱，功能越强大的证书费用越高。</li><li>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</li></ol><h2 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h2><p>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</p><p>主要的区别如下：</p><ol><li><strong><em>概念对比</em></strong>。HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</li><li><strong><em>费用对比</em></strong>。 HTTPS 协议需要 CA 证书，费用较高。</li><li><strong><em>连接方式和端口</em></strong>。使用不同的连接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li><li><strong><em>安全性对比</em></strong>。 HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ol><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><ul><li>GET：获取资源</li><li>HEAD：获取资源的元信息</li><li>POST：提交/上传 数据</li><li>PUT：修改数据</li><li>DELETE：删除资源（几乎用不到）</li><li>CONNECT：建立连接渠道，用于代理服务器</li><li>OPTIONS：列出可对资源实施的请求方法，用来跨域请求</li><li>TRACE：追踪请求-响应的传输路径</li></ul><h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><p>GET 和 POST 方法没有实质区别，只是报文格式不同。</p><p>GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议。</p><p>无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。</p><ul><li>GET 获取资源；POST 提交/上传 数据。</li><li>GET 请求长度在浏览器中有限制，而 POST 并没有。</li><li>GET 请求会被浏览器主动保留下来（历史记录），而 POST 默认不会。</li><li>get和post在缓存方面的区别：<ul><li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li><li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li></ul></li></ul><h3 id="【误】GET-请求传参长度有限制"><a href="#【误】GET-请求传参长度有限制" class="headerlink" title="【误】GET 请求传参长度有限制"></a>【误】GET 请求传参长度有限制</h3><p>【误】我们经常说 GET 请求参数的大小存在限制，而 POST 请求的参数大小是无限制的。</p><p>其实这是有问题的，实际上 HTTP 协议从来没规定 GET/POST 的请求长度限制是多少。</p><p>对 GET 请求参数的限制来源于浏览器或者 Web 服务器，是它们限制了这个长度。</p><p>不同的浏览器和 Web 服务器，限制的最大长度不一样。</p><h3 id="【误】POST-方法比-GET-方法安全"><a href="#【误】POST-方法比-GET-方法安全" class="headerlink" title="【误】POST 方法比 GET 方法安全"></a>【误】POST 方法比 GET 方法安全</h3><p>返回目录</p><p>【误】POST 比 GET 安全，是因为数据在地址栏 URL 看不见。</p><p>从传输角度来说，都是 HTTP 在网络上的明文传输，可以通过抓包工具完整获取的。</p><p>如果想安全，那就用 HTTPS 吧。</p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p><code>HTTP</code> 的 <code>keep-alive</code> 也称为 <code>HTTP</code> 长连接。</p><p>它通过重用一个 TCP 连接来发送/接收多个 HTTP 请求，来减少创建/关闭多个 TCP 连接的开销。</p><p>在 HTTP/1.0 协议中，如果请求头中包含：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>则代表开启 keep-alive，而服务端的返回报文头中，也会包含相同的内容。</p><p>在 HTTP/1.1 协议中，默认开启 keep-alive，除非显式地关闭它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>当然，除此之外我们也可以设置断开的时间等：</p><p>Keep-Alive: timeout=5, max=100<br>这个就表示这个 TCP 通道可以保持 5 秒，max=100 表示这个长连接最多接收 100 次请求就断开。</p><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><h3 id="HTTP-状态码为-3-位数，被归为-5-类："><a href="#HTTP-状态码为-3-位数，被归为-5-类：" class="headerlink" title="HTTP 状态码为 3 位数，被归为 5 类："></a>HTTP 状态码为 3 位数，被归为 5 类：</h3><p>1XX：表示目前是协议处理的中间状态，还需要后续操作。<br>2XX：表示成功状态。<br>3XX：重定向状态，资源位置发生变动，需要重新请求。<br>4XX：请求报文有误。<br>5XX：服务器端发生错误。</p><h3 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h3><ul><li>101 Switching Protocols：在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码为 101。<h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3></li><li>200 OK：请求成功状态码，响应体中含有数据。</li><li>204 No Content：含义同 200，但是响应报文不含实体的主体部分。</li><li>206 Partial Content：表示部分内容请求成功。使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段 Content-Range。<h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3></li><li>301 Move Permanently：永久重定向。HTTP 升级 HTTPS，之前站点再也不用，那就是 301。</li><li>302 Found：临时重定向。当前站点暂时不可用，那就是 302，后续可能换回来。</li><li>304 Not Modified：当命中协商缓存时会返回这个状态码。<h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3></li><li>400 Bad Request：请求无效。通常为前后端数据格式不一致或者其他原因。</li><li>403 Forbidden：服务器已经得到请求，但是拒绝执行，比如没权限、法律禁止等。</li><li>404 Not Found：资源未找到，服务器不存在对应的资源。<h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h3></li><li>500 Internal Server Error：服务器报错，有些时候可以在 Response 看到后端 PHP 等技术的报错信息等。</li><li>502 Bad Gateway：服务器正常，但是访问出错。</li><li>503 Service Unavailable：服务器繁忙或者停机维护，暂时无法处理请求。</li></ul><h2 id="解决通讯安全问题"><a href="#解决通讯安全问题" class="headerlink" title="解决通讯安全问题"></a>解决通讯安全问题</h2><ol><li>对称加密： 可以理解为对原始数据的可逆变换</li><li>非对称加密: 有两个秘钥：一个公钥、一个私钥，客户端和服务器使用的是两个不同的秘钥</li><li>对称加密 + 非对称加密： HTTPS 就是采用这种对称加密和非对称加密两者并用的混合加密机制</li><li>第三方认证： 在 HTTPS 中，为了解决无法验证公钥正确性的问题，使用数字证书认证机构（CA）及其颁发的数字证书来解决这个问题。</li><li>第三方认证安全性</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/qq_36632174/article/details/102402203">cookie、Session、Token、sessionStorage、localStorage简介</a></li><li><a href="https://blog.csdn.net/yinge0508/article/details/95761173">session,cookie,sessionStorage,localStorage,token的区别？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;HTTP-发展史&quot;&gt;&lt;a href=&quot;#HTTP-发展史&quot; class=&quot;headerlink&quot; title=&quot;HTTP 发展史&quot;&gt;&lt;/a&gt;HTT
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://github.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://github.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>JS之DOM事件流</title>
    <link href="http://github.com/2021/01/31/JS%E4%B9%8BDOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <id>http://github.com/2021/01/31/JS%E4%B9%8BDOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2021-01-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><blockquote><p>事件流描述的是从页面中接收事件的顺序</p></blockquote><p>DOM2级事件流包括下面几个阶段。</p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><h2 id="事件冒泡与事件捕获"><a href="#事件冒泡与事件捕获" class="headerlink" title="事件冒泡与事件捕获"></a>事件冒泡与事件捕获</h2><p>事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;outer&quot;</span>&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;inner&quot;</span>&gt;Click me!&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？为了解决这个问题微软和网景提出了两种几乎完全相反的概念。</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>微软(IE)提出了名为事件冒泡(event bubbling)的事件流。</p><p>事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。</p><p>因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是:</p><p>p -&gt; div -&gt; body -&gt; html -&gt; document</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>网景提出另一种事件流名为事件捕获(event capturing)。</p><p>与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。</p><p>上面的例子在事件捕获的概念下发生click事件的顺序应该是:</p><p>document -&gt; html -&gt; body -&gt; div -&gt; p</p><h3 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h3><blockquote><p>W3C 对这两种方案进行了统一：将 DOM 事件分为两个阶段，事件捕获和事件冒泡阶段</p></blockquote><p>当一个元素被点击，首先是事件捕获阶段，window 最先接收事件，然后一层一层往下捕获，最后由具体元素接收；之后再由具体元素再一层一层往上冒泡，到 window 接收事件。</p><h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h3><blockquote><p>E浏览器对addEventListener兼容性并不算太好，只有IE9以上可以使用。</p></blockquote><p><code>DOM2级事件</code>中规定的事件流同时支持了事件捕获阶段和事件冒泡阶段，而作为开发者，我们可以选择事件处理函数在哪一个阶段被调用。</p><p><code>addEventListener</code>方法用来为一个特定的元素绑定一个事件处理函数，是<code>JavaScript</code>中的常用方法。</p><blockquote><p><code>element.addEventListener(event, function, useCapture)</code></p></blockquote><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">event</td><td align="left">必须。字符串，指定事件名。<br>注意: 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。<br>提示： 所有 HTML DOM 事件，</td></tr><tr><td align="left">function</td><td align="left">必须。指定要事件触发时执行的函数。<br>当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。<br>例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。</td></tr><tr><td align="left">useCapture</td><td align="left">可选。布尔值，指定事件是否在捕获或冒泡阶段执行。<br>可能值:<br>true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）<br>false(默认值)。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）</td></tr></tbody></table><h3 id="如何让事件先冒泡后捕获"><a href="#如何让事件先冒泡后捕获" class="headerlink" title="如何让事件先冒泡后捕获"></a>如何让事件先冒泡后捕获</h3><p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。</p><h2 id="事件委托-代理"><a href="#事件委托-代理" class="headerlink" title="事件委托(代理)"></a>事件委托(代理)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</p><h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2><ol><li>给子级加 <code>event.stopPropagation( )</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#div1&quot;</span>).mousedown(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=event||<span class="built_in">window</span>.event;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>在事件处理函数中返回 <code>false</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#div1&quot;</span>).mousedown(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=e||<span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>但是这两种方式是有区别的。</li></ol><ul><li><code>return false</code> 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。</li><li><code>event.stopPropagation()</code>则只阻止事件往上冒泡，不阻止事件本身。</li></ul><p>3.  <code>event.target==event.currentTarget</code>，让触发事件的元素等于绑定事件的元素，也可以阻止事件冒泡；</p><h2 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h2><ul><li>（1）event.preventDefault( )</li><li>（2）return false</li></ul><h2 id="并不是所有的事件都有冒泡"><a href="#并不是所有的事件都有冒泡" class="headerlink" title="并不是所有的事件都有冒泡"></a>并不是所有的事件都有冒泡</h2><p>例如：</p><ul><li><code>onblur</code></li><li><code>onfocus</code></li><li><code>onmouseenter</code></li><li><code>onmouseleave</code></li></ul><h2 id="onmouseover-和-onmouseenter-区别"><a href="#onmouseover-和-onmouseenter-区别" class="headerlink" title="onmouseover 和 onmouseenter 区别"></a>onmouseover 和 onmouseenter 区别</h2><ul><li><p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</p></li><li><p>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</p></li></ul><p>这两者都是移入的时候触发，但是 onmouseover 会触发多次，而 onmouseenter 只在进去的时候才触发。</p><h2 id="JS-位置"><a href="#JS-位置" class="headerlink" title="JS 位置"></a>JS 位置</h2><ul><li><code>clientHeight</code>：表示可视区域的高度，不包含 <code>border</code> 和滚动条</li><li><code>offsetHeight</code>：表示可视区域的高度，包含了 <code>border</code> 和滚动条</li><li><code>scrollHeight</code>：表示了所有区域的高度，包含了因为滚动被隐藏的部分</li><li><code>clientTop</code>：表示边框 border 的厚度，在未指定的情况下一般为0</li><li><code>scrollTop</code>：滚动后被隐藏的高度，获取对象相对于由 <code>offsetParent </code>属性指定的父坐标（CSS 定位的元素或 body 元素）距离顶端的高度。</li></ul><h2 id="js拖拽功能的实现"><a href="#js拖拽功能的实现" class="headerlink" title="js拖拽功能的实现"></a>js拖拽功能的实现</h2><ol><li>通过 mousedown、mousemove、mouseup 方法实现</li></ol><ul><li><p>首先是三个事件，分别是mousedown，mousemove，mouseup,当鼠标点击按下的时候，需要一个tag标识此时已经按下，可以执行mousemove里面的具体方法。</p></li><li><p>clientX，clientY标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用offsetX和offsetY来表示元素的元素的初始坐标，<br><br>移动的举例应该是：<br><br>鼠标移动时候的坐标-鼠标按下去时候的坐标。<br><br>也就是说定位信息为：<br><br>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft.<br></p></li></ul><ol start="2"><li>可以通过html5的拖放（Drag 和 drop）来实现</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903834075021326#heading-0">你真的理解事件冒泡和事件捕获吗</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h2&gt;&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之从输入 URL 到页面呈现</title>
    <link href="http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0/"/>
    <id>http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0/</id>
    <published>2021-01-29T16:00:00.000Z</published>
    <updated>2021-01-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改（浏览器的工作原理）</p><h2 id="整体过程"><a href="#整体过程" class="headerlink" title="整体过程"></a>整体过程</h2><p>在用户输入 URL，按下回车之后，走过的步骤：</p><ul><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器响应</li><li>浏览器解析渲染页面</li></ul><h2 id="具体阶段"><a href="#具体阶段" class="headerlink" title="具体阶段"></a>具体阶段</h2><ul><li>用户输入阶段</li><li>发起URL请求阶段</li><li>准备渲染进程阶段</li><li>提交文档阶段</li><li>页面渲染阶段</li></ul><h2 id="用户输入阶段"><a href="#用户输入阶段" class="headerlink" title="用户输入阶段"></a>用户输入阶段</h2><ul><li>合成 URL：用户输入 URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容 + 默认搜索引擎合成新的 URL；如果用户输入的内容符合 URL 规则，浏览器就会根据 URL 协议，在这段内容上加上协议合成合法的 URL；</li><li>加载：用户输入完内容，按下回车键，浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得；</li></ul><h2 id="发起URL请求阶段"><a href="#发起URL请求阶段" class="headerlink" title="发起URL请求阶段"></a>发起URL请求阶段</h2><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/30/XovFHrwqVeN37ds.png"></p><h3 id="开始阶段"><a href="#开始阶段" class="headerlink" title="开始阶段"></a>开始阶段</h3><ol><li><p>构建请求：浏览器进程首先会构建请求行信息，然后通过进程间通信（IPC）将 URL 请求发送给网络进程；</p></li><li><p>查找缓存：网络进程获取到 URL，先去本地缓存中查找是否有缓存资源，如果有则拦截请求，直接将缓存资源返回给浏览器进程；否则，进入网络请求阶段；</p></li></ol><h3 id="网络请求阶段-从服务器获取资源"><a href="#网络请求阶段-从服务器获取资源" class="headerlink" title="网络请求阶段(从服务器获取资源)"></a>网络请求阶段(从服务器获取资源)</h3><ol><li><p><code>DNS</code> 解析：网络进程请求首先会从 <code>DNS</code> 数据缓存服务中查找是否缓存过当前域名信息，有则直接返回；否则，会进行 DNS 解析返回域名对应的 IP 和端口号，如果没有指定端口号，<code>http</code> 默认<code> 80</code> 端口，<code>https</code> 默认 <code>443</code>。如果是 <code>https</code> 请求，还需要建立 <code>TLS</code> 连接；</p></li><li><p>等待 <code>TCP</code> 队列：<code>Chrome</code> 有个机制，同一个域名同时最多只能建立 <code>6</code> 个 <code>TCP</code> 连接，如果在同一个域名下同时有 <code>10 </code>个请求发生，那么其中 <code>4</code> 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于<code>6</code>个，会直接建立 <code>TCP</code> 连接；</p></li><li><p>建立 <code>TCP</code> 连接：<code>TCP</code> 三次握手与服务器建立连接，然后进行数据的传输，最后；</p></li><li><p>发送 <code>HTTP</code> 请求：浏览器首先会向服务器发送请求行，它包含了请求方法、请求 <code>URI</code> 和 <code>HTTP</code> 协议的版本；另外还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核，请求域名、<code>Cookie</code> 等；如果需要传递参数，则还需要发送请求体；</p></li><li><p>服务器处理请求：服务器首先返回响应行，包括协议版本和状态码，比如状态码 <code>200</code> 表示继续处理该请求；（如果是 <code>301</code>，则表示重定向，将会在响应头的 <code>Locaiton</code> 字段中加上重定向的地址信息，接下来浏览器获取这个地址，将会重新导航。）服务器也会向浏览器发送响应头，包含了一些信息，比如服务器生成返回数据的时间、返回的数据类型（<code>JSON</code>、<code>HTML</code>、<code>流媒体</code>等类型），以及服务器要在客户端保存的 <code>Cookie</code> 等；继续发送响应体的数据；(服务器处理请求完毕后，会返回 HTTP 报文)</p></li><li><p>断开 <code>TCP</code> 连接：数据传输完成，正常情况下 <code>TCP</code> 将四次挥手断开连接。但是如果浏览器或者服务器在<code>HTTP</code>头部加上 <code>Connection: keep-alive</code>，<code>TCP</code> 就会一直保持连接。保持 <code>TCP</code> 连接可以省下下次需要建立连接的时间，提示资源加载速度；</p></li></ol><h2 id="准备渲染进程阶段"><a href="#准备渲染进程阶段" class="headerlink" title="准备渲染进程阶段"></a>准备渲染进程阶段</h2><blockquote><p>将获取到的数据包进行解析</p></blockquote><ol><li><p>网络进程将获取到的数据包进行解析，根据响应头中的 <code>Content-type</code> 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是 <code>text/html</code> 类型，就通知浏览器进程获取到的是 <code>HTML</code>，应该准备渲染进程了；</p></li><li><p>正常情况下每个浏览器的 <code>tab</code> 会对应一个渲染进程，但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程，否则就会创建一个新的渲染进程；</p></li></ol><h2 id="提交文档阶段"><a href="#提交文档阶段" class="headerlink" title="提交文档阶段"></a>提交文档阶段</h2><ol><li><p>渲染进程准备好后，浏览器会发出 <code>&quot;提交文档&quot;</code> 的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的 <code>&quot;管道&quot;</code>，文档数据传输完成后，渲染进程会返回<code>&quot;确认提交&quot;</code>的消息给浏览器进程；</p></li><li><p>浏览器收到 <code>&quot;确认提交&quot;</code> 的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 <code>web</code> 页面，此时的 <code>web</code> 页面是空白页；</p></li></ol><h2 id="页面渲染阶段"><a href="#页面渲染阶段" class="headerlink" title="页面渲染阶段"></a>页面渲染阶段</h2><ol><li><p>文档一旦提交，渲染进程将开始页面解析和子资源加载；渲染阶段比较复杂，所以将分为多个子阶段，按照渲染的时间顺序可以分为：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成；</p></li><li><p>构建 DOM 树：HTML 经过解析器后输出一个以 document 为顶层节点的树状结构的 DOM；</p></li><li><p>样式计算：这里有 3 个步骤：</p><ul><li>将 3 个来源（<code>&lt;link&gt;</code> 标签引入的外部样式、<code>&lt;style&gt;</code> 标签里定义的样式、以及元素的 <code>style</code> 属性上的样式）的 <code>CSS</code> 转化成浏览器能够理解的结构 <code>styleSheets</code>；</li><li>转换样式表中的属性值，使其标准化；比如 <code>font-weight: bold</code>; 会转成 <code>font-weight: 700</code>;， <code>color: blue</code>; 会转成 <code>color: rgb(0, 0, 255)</code>; 等；</li><li>依据 <code>CSS</code> 的继承和层叠规则计算出 <code>DOM</code> 树中每个节点的具体样式；</li></ul></li><li><p>布局阶段：<code>DOM</code> 树中依然存在许多不可见的元素（比如 <code>head</code>），这些元素对于布局是丝毫没用的，所以又会生成一棵只包含可见元素的布局树；然后再根据布局树的每个节点计算出其具体位置和尺寸大小；</p></li><li><p>分层：页面中有很多复杂的效果，如一些复杂的 <code>3D</code> 变换、页面滚动，或者使用 <code>z-index</code> 做 <code>z</code> 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树；关于层叠上下文的知识，具体可以参考这里彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、<code>z-index</code>；</p></li><li><p>绘制：为每个图层生成绘制列表，并将其提交到合成线程；</p></li><li><p>光栅化：通常一个页面很大，而视口很局限，所以合成线程会按照视口附近的图块来优先生成位图，并在光栅化线程池中将图块转换成位图；</p></li><li><p>合成：一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令 <code>DrawQuad</code>，然后将该命令提交给浏览器进程；之后浏览器将开始生成显示页面。</p></li></ol><h2 id="渲染过程（此为面试回答）"><a href="#渲染过程（此为面试回答）" class="headerlink" title="渲染过程（此为面试回答）"></a>渲染过程（此为面试回答）</h2><h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><ul><li>解析 <code>HTML</code>，生成 <code>DOM</code> 树</li><li>解析 <code>CSS</code>，生成 <code>CSS</code> 规则树（<code>CSS Rule Tree</code>）</li><li>将 <code>DOM Tree</code> 和 <code>CSS Rule Tree</code> 相结合，生成 渲染树（<code>Render Tree</code>）</li><li>从根节点开始，计算每一个元素的大小、位置，给出每个节点所应该出现的屏幕精确坐标，(计算每个节点的位置)从而得到基于渲染树的 布局渲染树（<code>Layout of the render tree</code>）。</li><li>遍历渲染树，将每个节点用 <code>UI</code> 渲染引擎来绘制，从而将整棵树绘制到页面上，这个步骤叫 绘制渲染树（<code>Painting the render tree</code>）(调用 GPU 绘制，合成图层，显示在屏幕上)</li></ul><h3 id="在解析渲染过程中，可能会产生-回流-和-重绘："><a href="#在解析渲染过程中，可能会产生-回流-和-重绘：" class="headerlink" title="在解析渲染过程中，可能会产生 回流 和 重绘："></a>在解析渲染过程中，可能会产生 回流 和 重绘：</h3><ul><li><p>重绘(repaint)：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此损耗较少。</p></li><li><p>回流(reflow)：又叫重排（layout）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。</p></li></ul><h3 id="渲染过程碰到-JS-文件"><a href="#渲染过程碰到-JS-文件" class="headerlink" title="渲染过程碰到 JS 文件"></a>渲染过程碰到 JS 文件</h3><blockquote><p>JavaScript 的加载、解析和执行会阻塞 DOM 的构建。</p></blockquote><p>在构建 <code>DOM</code> 的时候，<code>HTML</code> 解析器如果碰到 <code>JavaScript</code>，那么就会停止构建 <code>DOM</code>，将控制权交给 <code>JavaScript</code> 引擎，等 <code>JavaScript</code> 运行完毕，浏览器再从中断的地方恢复 <code>DOM</code> 构建。</p><p>也就是说：首屏渲染越快，就越不应该在首屏的时候加载 JS 文件，这也就是建议将 script 标签放到 body 标签底部，或者给 script 标签添加 defer/async 属性的原因。</p><h3 id="为什么操作-DOM-慢"><a href="#为什么操作-DOM-慢" class="headerlink" title="为什么操作 DOM 慢"></a>为什么操作 DOM 慢</h3><ol><li>涉及 JS 引擎和渲染引擎两个线程间的通信，损耗性能。</li><li>操作 DOM 可能会重复回流，加剧性能损耗。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6909258409250553869">「面试常问」从输入 URL 到显示发生了什么（ 99 分答案）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改（浏览器的工作原理）&lt;/p&gt;
&lt;h2 id=&quot;整体过程&quot;&gt;&lt;a href=&quot;#整体过程&quot; class=&quot;headerlink&quot; title=&quot;整体过程&quot;&gt;&lt;/a&gt;整体过程&lt;/h
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之从重绘和重排</title>
    <link href="http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/"/>
    <id>http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/</id>
    <published>2021-01-29T16:00:00.000Z</published>
    <updated>2021-01-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><blockquote><p>回流必将引起重绘，重绘不一定会引起回流</p></blockquote><h2 id="浏览器的渲染"><a href="#浏览器的渲染" class="headerlink" title="浏览器的渲染"></a>浏览器的渲染</h2><ol><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display:将像素发送给GPU，展示在页面上。</li></ol><h2 id="回流-Reflow-重绘"><a href="#回流-Reflow-重绘" class="headerlink" title="回流 (Reflow)(重绘)"></a>回流 (Reflow)(重绘)</h2><p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p><h3 id="会导致回流的操作："><a href="#会导致回流的操作：" class="headerlink" title="会导致回流的操作："></a>会导致回流的操作：</h3><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除可见的DOM元素</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法</li></ul><h3 id="一些常用且会导致回流的属性和方法："><a href="#一些常用且会导致回流的属性和方法：" class="headerlink" title="一些常用且会导致回流的属性和方法："></a>一些常用且会导致回流的属性和方法：</h3><ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>scrollIntoView()、scrollIntoViewIfNeeded()</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li><li>scrollTo()</li></ul><h2 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘 (Repaint)"></a>重绘 (Repaint)</h2><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><h3 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h3><p>回流比重绘的代价要更高。</p><p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</p><p>现代浏览器会对频繁的回流或重绘操作进行优化：</p><p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p><p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p><ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>width、height</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li></ul><p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p><h3 id="如何触发重绘？"><a href="#如何触发重绘？" class="headerlink" title="如何触发重绘？"></a>如何触发重绘？</h3><ul><li>修改背景色、颜色（background、color）</li><li>设置可见度（visibility）</li><li>设置背景图（background-image）</li></ul><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><p>CSS</p><ul><li>避免使用table布局。</li><li>尽可能在DOM树的最末端改变class。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到position属性为absolute或fixed的元素上。</li><li>避免使用CSS表达式（例如：calc()）。</li></ul><p>JavaScript</p><ul><li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li><li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li><li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><h2 id="减少重绘和回流的细节："><a href="#减少重绘和回流的细节：" class="headerlink" title="减少重绘和回流的细节："></a>减少重绘和回流的细节：</h2><ol><li>使用 translate 替代 top</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>尽量算出结果再去重绘把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame  Load 和 DOMContentLoaded 区别。Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000017329980">你真的了解回流和重绘吗</a></li><li><a href="https://juejin.cn/post/6844903569087266823">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></li><li><a href="https://juejin.cn/post/6844903569087266823">回流与重绘：CSS性能让JavaScript变慢？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;回流必将引起重绘，重绘不一定会引起回流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;浏览器的渲染&quot;&gt;&lt;a href=&quot;#浏览器
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之本地存储</title>
    <link href="http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <id>http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</id>
    <published>2021-01-27T16:00:00.000Z</published>
    <updated>2021-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="HTTP无状态"><a href="#HTTP无状态" class="headerlink" title="HTTP无状态"></a>HTTP无状态</h2><blockquote><p>HTTP无状态协议，是指协议对于交互性场景没有记忆能力。</p></blockquote><p><code>HTTP</code> 是无状态的，即它不会记住用户的操作，服务器单纯从网络连接上无从知道客户身份, 这让我们在记住用户状态等场景被限制</p><p>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。</p><p>比如服务器不知道某个用户是否已登录过了。因为愚蠢的服务器不知道客户端是否已登录过了,所以每次都要在交互场景(会话)中请求中带上上一次的请求信息，如账号、密码。明明只需要在<code>/login</code>接口中，才需要对比数据库中的账号密码和客户端传的是否一致来确定合法性。这下在添加购物车中也需要再一次的进行同样的重复且没有必要的操作，即降低了响应速度，又对用户不友好（因为每次都需要填账号，密码）。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><code>Cookie</code> 最开始被设计出来其实并不是来做本地存储的，而是为了弥补 <code>HTTP</code> 在状态管理上的不足。</p><p><code>Cookie</code> 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。</p><p>向同一个域名下发送请求，都会携带相同的 <code>Cookie</code>，服务器拿到 <code>Cookie</code> 进行解析，便能拿到客户端的状态。</p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol><li><p>A: 首先，客户端会发送一个<code>http</code>请求到服务器端。</p></li><li><p>B: 服务器端接受客户端请求后，发送一个<code>http</code>响应到客户端，这个响应头，其中就包含<code>Set-Cookie</code>头部。</p></li><li><p>C: 在客户端发起的第二次请求（注意：如果服务器需要我们带上<code>Cookie</code>，我们就需要在B步骤上面拿到这个<code>Cookie</code>然后作为请求头一起发起第二次请求），提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了<code>cookies</code>。尽管，用户可能在和应用程序交互的过程中突然禁用<code>cookies</code>的使用，但是，这个情况基本是不太可能发生的，所以可以不加以考虑，这在实践中也被证明是对的。</p></li></ol><h3 id="Cookie的不可跨域名性"><a href="#Cookie的不可跨域名性" class="headerlink" title="Cookie的不可跨域名性"></a>Cookie的不可跨域名性</h3><p><code>Cookie</code>具有不可跨域名性。根据<code>Cookie</code>规范，浏览器访问<code>Google</code>只会携带<code>Google</code>的<code>Cookie</code>，而不会携带<code>Baidu</code>的<code>Cookie</code>。<code>Google</code>也只能操作<code>Google</code>的<code>Cookie</code>，而不能操作<code>Baidu</code>的<code>Cookie</code>。</p><p><code>Cookie</code>在客户端是由浏览器来管理的。浏览器能够保证<code>Google</code>只会操作<code>Google</code>的<code>Cookie</code>而不会操作<code>Baidu</code>的<code>Cookie</code>，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站<code>Cookie</code>的依据是域名。<code>Google</code>与<code>Baidu</code>的域名不一样，因此<code>Google</code>不能操作<code>Baidu</code>的<code>Cookie</code>。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>cookie, 如果不设置过期时间，cookie保存在内存中，生命周期随浏览器的关闭而结束，如果设置了过期时间，cookie保存在硬盘中，关闭浏览器，cookie数据直到过期时间而消失；cookie是服务器发给客户端的特殊信息，cookie是以文本的形式保存在客户端，每次请求都会带上它；</p><h3 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h3><ul><li>容量缺陷。体积上线 4kb，只能存储少量信息。用户禁用cookie,就会使其功能受限</li><li>性能缺陷。Cookie 请求每次都会携带上完整的 Cookie，随着请求数增多，造成性能浪费。</li><li>安全缺陷。以纯文本的形式在浏览器和服务器中传递，容易被非法截获和篡改。</li></ul><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><h3 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h3><p><code>Local Storge</code> 相对 <code>Cookie</code> 而言，它也是针对同一个域名。<br>同一个域名下，会存储相同的一段 <code>Local Storage</code>。</p><h4 id="设置与取值"><a href="#设置与取值" class="headerlink" title="设置与取值"></a>设置与取值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置：</span></span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jsliang&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;jsliang&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&quot;info&quot;</span>, <span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值：</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> info = <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;info&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="相比-Cookie-优势"><a href="#相比-Cookie-优势" class="headerlink" title="相比 Cookie 优势"></a>相比 Cookie 优势</h4><ol><li>容量。体积上线 <code>5M</code>，大于 <code>Cookie</code> 的 <code>4kb</code>。</li><li>只存在客户端。不参与和服务端的通讯，避免 <code>Cookie</code> 的性能缺陷和安全缺陷。</li><li>接口封装。有 <code>setItem</code> 和 <code>getItem</code> 两个<code>API</code>接口。</li></ol><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ol><li>以 <code>Base64</code> 方式存储官方 <code>Logo</code> 等图片。</li></ol><h3 id="Session-Storage"><a href="#Session-Storage" class="headerlink" title="Session Storage"></a>Session Storage</h3><p>基本上和 <code>Local Stoarge</code> 一致。</p><h4 id="相比Local-Storage："><a href="#相比Local-Storage：" class="headerlink" title="相比Local Storage："></a>相比Local Storage：</h4><p>会话级别的存储。不同于 <code>Local Storage</code> 的持续化存储，<code>Session Storage</code> 当页面关闭的时候就不复存在了。</p><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><ol><li><p>对表单信息做维护。用户刷新页面不丢失。</p></li><li><p>存储本次浏览记录。看过的页面不怕找不到。</p><h3 id="localStorage和sessionStorage："><a href="#localStorage和sessionStorage：" class="headerlink" title="localStorage和sessionStorage："></a>localStorage和sessionStorage：</h3></li><li><p>生命周期：localStorage的生命周期是永久的，关闭页面也不会消失，除非是主动删除；sessionStorage的生命周期是仅在当前会话下有效</p></li><li><p>存储大小：localStorage和sessionStorage的存储数据一般都是5mb;</p></li><li><p>存储内容类型：都只能存储字符串类型；</p></li><li><p>获取方式：localStorage: window.localStorage; sessionStorage: window.sessionStorage;</p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexedDB 是运行在浏览器中的 非关系型数据库。</p></li></ol><p>因为本质上是数据库，所以一般来说容量是没有上线的。</p><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token只能被保存在客户端的cookie或localstorage中，因为用户的状态在服务端的内存中是不能存储的，所以这是一种无状态的认证机制；</p><h3 id="为什么需要token"><a href="#为什么需要token" class="headerlink" title="为什么需要token"></a>为什么需要token</h3><p>众所周知，HTTP 是无状态协议，即它对于交互性场景没有记忆能力。</p><p>但是，如果碰到某些场景，就有点无奈了：</p><ul><li>输入账号密码进行登录</li><li>将商品加入购物车</li><li>点击支付，发现用户要重新登录</li></ul><p>我们可以通过 token 来维持用户的登录态</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><blockquote><p>用户 id + 过期时间 + SecretKey</p></blockquote><p><code>&quot;用户 id&quot; + &quot;过期时间&quot; + SHA1(&quot;用户 id&quot; + &quot;用户口令&quot; + &quot;过期时间&quot; + &quot;SecretKey&quot;)</code></p><p>这样，当浏览器发送请求给服务器，token 会通过 cookie 等形式将上面实例内容传输给服务器。</p><p>服务器拿到数据后，根据用户 id 查找用户口令，并进一步计算是否已过期，从而判断用户是否需要重新登录。</p><p>需要重新登录则跳转到登录页面，不需要重新登录则进行支付流程。</p><h4 id="token认证流程"><a href="#token认证流程" class="headerlink" title="token认证流程"></a>token认证流程</h4><ol><li>用户登录校验，校验成功后就返回<code>Token</code>给客户端;</li><li>客户端收到数据后就保存在客户端;</li><li>客户端每次访问<code>api</code>就携带<code>Token</code>到服务端 ;</li><li>服务端采用<code>filter</code>过滤器校验，校验成功后返回请求数据，校验失败则返回校验码；<h4 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h4></li></ol><p>A：当用户首次登录成功（注册也是一种可以适用的场景）之后, 服务器端就会生成一个token值，这个值，会在服务器保存token值(保存在数据库中)，再将这个token值返回给客户端。</p><p>B：客户端拿到token值之后,进行本地保存（SP存储是大家能够比较支持和易于理解操作的存储）。</p><p>C：当客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个token值附带到参数中发送给服务器。</p><p>D：服务器接收到客户端的请求之后,会取出token值与保存在本地(数据库)中的token值做对比:</p><ul><li>对比一：如果两个 token 值相同， 说明用户登录成功过!当前用户处于登录状态！</li><li>对比二：如果没有这个 token 值, 则说明没有登录成功。</li><li>对比三：如果 token 值不同: 说明原来的登录信息已经失效,让用户重新登录。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ul><ul><li><a href="https://blog.csdn.net/qq_36632174/article/details/102402203">cookie、Session、Token、sessionStorage、localStorage简介</a></li><li><a href="https://blog.csdn.net/yinge0508/article/details/95761173">session,cookie,sessionStorage,localStorage,token的区别？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;HTTP无状态&quot;&gt;&lt;a href=&quot;#HTTP无状态&quot; class=&quot;headerlink&quot; title=&quot;HTTP无状态&quot;&gt;&lt;/a&gt;HTTP无状态&lt;
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之跨域</title>
    <link href="http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E8%B7%A8%E5%9F%9F/"/>
    <id>http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E8%B7%A8%E5%9F%9F/</id>
    <published>2021-01-27T16:00:00.000Z</published>
    <updated>2021-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><blockquote><p>所谓 源，可以指 URL。</p></blockquote><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>简单来看某个 URL 组成；</p><p><code>https://lonelyzou.github.io/longin</code></p><ul><li>名称    举例</li><li>协议    <code>http</code>、<code>https</code></li><li>域名    <code>lonelyzou.github.io</code></li><li>端口    80、443</li><li>其中，如果 URL 上未标明端口，那么 http 默认是 80 端口，https 默认是 443 端口。</li></ul><p>而所谓的同源策略，是指这 3 个（协议、域名、端口）一致的情况下，才属于同源。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>对于下面的 URL，我们判断下哪些属于同源哪些属于不同源：</p><ul><li><a href="https://github.com/LiangJunrong/document-library">https://github.com/LiangJunrong/document-library</a><table><thead><tr><th align="left">URL</th><th align="left">是否同源</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left"><a href="http://github.com/">http://github.com</a></td><td align="left">否</td><td align="left">协议不同</td></tr><tr><td align="left"><a href="https://github2.com/">https://github2.com</a></td><td align="left">否</td><td align="left">域名不同</td></tr><tr><td align="left"><a href="https://github.com:80/LiangJunrong">https://github.com:80/LiangJunrong</a></td><td align="left">否</td><td align="left">https 默认端口为 443</td></tr><tr><td align="left"><a href="https://money.github.com/">https://money.github.com</a></td><td align="left">是</td><td align="left">多级域名和主域名一致</td></tr></tbody></table></li></ul><p>在上面，如果两个页面对应的地址不同源，那么浏览器就会判定跨域，从而导致下面问题：</p><ul><li>Ajax 请求不能发送</li><li>无法获取 DOM 元素并进行操作</li><li>无法读取 Cookie、LocalStorage 和 IndexDB<blockquote><p>有些请求是不受到跨域限制。例如：WebSocket，script、img、iframe、video、audio标签的src属性等。</p></blockquote><h3 id="出于怎样的考虑，浏览器才要设置跨域？"><a href="#出于怎样的考虑，浏览器才要设置跨域？" class="headerlink" title="出于怎样的考虑，浏览器才要设置跨域？"></a>出于怎样的考虑，浏览器才要设置跨域？</h3></li></ul><ol><li><p>首先，跨域只存在于浏览器端，因为我们知道浏览器的形态是很开放的，所以我们需要对它有所限制。</p></li><li><p>其次，同源策略主要是为了保证用户信息的安全，可分为两种：Ajax 同源策略和 DOM 同源策略。</p></li><li><p>Ajax 同源策略主要是使得不同源的页面不能获取 Cookie 且不能发起 Ajax 请求，这样在一定层度上防止了 CSRF 攻击。</p></li><li><p>DOM 同源策略也一样，它限制了不同源页面不能获取 DOM，这样可以防止一些恶意网站在自己的网站中利用 iframe 嵌入正规的网站并迷惑用户，以此来达到窃取用户信息。</p></li></ol><h3 id="实际开发场景为什么会出现跨域："><a href="#实际开发场景为什么会出现跨域：" class="headerlink" title="实际开发场景为什么会出现跨域："></a>实际开发场景为什么会出现跨域：</h3><ul><li>前后端部署的机子，不属于同一台云服务器。</li><li>同一台云服务器，但是你在 <a href="https://github.com/">https://github.com</a> 请求的是 <a href="https://github2.com/">https://github2.com</a> 上的资源。</li></ul><h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><ol><li>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</li><li>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。</li><li>这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？</li></ol><p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p><h2 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h2><h3 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1.jsonp"></a>1.jsonp</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 <code>JSON </code>数据。<code>JSONP</code>请求一定需要对方的服务器做支持才可以。</p><h4 id="JSONP和AJAX对比"><a href="#JSONP和AJAX对比" class="headerlink" title="JSONP和AJAX对比"></a><code>JSONP</code>和<code>AJAX</code>对比</h4><p><code>JSONP</code>和<code>AJAX</code>相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但<code>AJAX</code>属于同源策略，<code>JSONP</code>属于非同源策略（跨域请求)</p><h4 id="JSONP优缺点"><a href="#JSONP优缺点" class="headerlink" title="JSONP优缺点"></a>JSONP优缺点</h4><ul><li>优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</li><li>缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</li></ul><h3 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2.CORS"></a>2.CORS</h3><h4 id="CORS-跨域的原理。"><a href="#CORS-跨域的原理。" class="headerlink" title="CORS 跨域的原理。"></a>CORS 跨域的原理。</h4><p>跨域资源共享（CORS）是一种机制，是 W3C 标准。它允许浏览器向跨源服务器，发出 XMLHttpRequest 或 Fetch 请求。并且整个 CORS 通信过程都是浏览器自动完成的，不需要用户参与。</p><p>而使用这种跨域资源共享的前提是，浏览器必须支持这个功能，并且服务器端也必须同意这种 “跨域” 请求。因此实现 CORS 的关键是服务器需要服务器。</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。</p><p>该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><h4 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h4><p>当你使用 IE&lt;=9, Opera&lt;12, or Firefox&lt;3.5 或者更加老的浏览器，这个时候请使用 JSONP</p><h4 id="CORS方法优点-amp-缺点："><a href="#CORS方法优点-amp-缺点：" class="headerlink" title="CORS方法优点&amp;缺点："></a>CORS方法优点&amp;缺点：</h4><p>优点</p><ul><li>简单，几乎不需要什么开发量，只需要简单配置相应的请求与响应头信息即可。</li><li>支持各种类型的请求（get, post, put等等）。</li></ul><p>缺点</p><ul><li>需要对跨域的服务接口进行一定的改造。如果该服务因为某些原因无法改造，则无法实现。但这种改造还是相对较小的。</li><li>不兼容一些“古董”浏览器。</li></ul><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。</p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>不会触发 CORS 预检请求。这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：</p><ol><li>情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)</li></ol><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><ol start="2"><li>情况二: 人为设置以下集合外的请求头</li></ol><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code> （需要注意额外的限制）</li><li><code>DPR</code></li><li><code>Downlink</code></li><li><code>Save-Data</code></li><li><code>Viewport-Width</code></li><li><code>Width</code></li></ul><ol start="3"><li>情况三：<code>Content-Type</code>的值仅限于下列三者之一：(例如 <code>application/json </code>为非简单请求)</li></ol><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><ol start="4"><li><p>情况四:<br>请求中的任意<code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；<code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。</p></li><li><p>情况五:<br>请求中没有使用 ReadableStream 对象。</p></li></ol><h3 id="3-postMessage"><a href="#3-postMessage" class="headerlink" title="3.postMessage"></a>3.postMessage</h3><blockquote><p>postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一。</p></blockquote><p>它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的 iframe 消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>postMessage() 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><blockquote><p><code>otherWindow.postMessage(message, targetOrigin, [transfer])</code>;</p></blockquote><ul><li>message: 将要发送到其他 window的数据。</li><li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><h4 id="案列"><a href="#案列" class="headerlink" title="案列"></a>案列</h4><p>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递<code>“我爱你”</code>,然后后者传回<code>&quot;我不爱你&quot;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.html</span><br><span class="line">  &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;b.html&quot; frameborder&#x3D;&quot;0&quot; id&#x3D;&quot;frame&quot; onload&#x3D;&quot;load()&quot;&gt;&lt;&#x2F;iframe&gt; &#x2F;&#x2F;等它加载完触发一个事件</span><br><span class="line">  &#x2F;&#x2F;内嵌在http:&#x2F;&#x2F;localhost:3000&#x2F;a.html</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      function load() &#123;</span><br><span class="line">        let frame &#x3D; document.getElementById(&#39;frame&#39;)</span><br><span class="line">        frame.contentWindow.postMessage(&#39;我爱你&#39;, &#39;http:&#x2F;&#x2F;localhost:4000&#39;) &#x2F;&#x2F;发送数据</span><br><span class="line">        window.onmessage &#x3D; function(e) &#123; &#x2F;&#x2F;接受返回数据</span><br><span class="line">          console.log(e.data) &#x2F;&#x2F;我不爱你</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; b.html</span><br><span class="line">  window.onmessage &#x3D; function(e) &#123;</span><br><span class="line">    console.log(e.data) &#x2F;&#x2F;我爱你</span><br><span class="line">    e.source.postMessage(&#39;我不爱你&#39;, e.origin)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4.WebSocket"></a>4.WebSocket</h3><p>WebSocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。</p><p>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。</p><p>简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。</p><p>这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>前端部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  </span><br><span class="line">  <span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:8080&quot;</span>);socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">   socket.send(<span class="string">&quot;秋风的笔记&quot;</span>);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(e.data);  </span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>后端部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&quot;ws&quot;</span>);<span class="keyword">const</span> server = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);server.on(<span class="string">&quot;connection&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;  </span><br><span class="line">  socket.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;    </span><br><span class="line">    socket.send(data);  </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-Node-正向代理"><a href="#5-Node-正向代理" class="headerlink" title="5.Node 正向代理"></a>5.Node 正向代理</h3><blockquote><p>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</p></blockquote><p>代理服务器实现步骤：</p><ul><li>接受客户端请求 。</li><li>将请求 转发给服务器。</li><li>拿到服务器 响应 数据。</li><li>将 响应 转发给客户端。</li></ul><h4 id="cli-工具中的代理"><a href="#cli-工具中的代理" class="headerlink" title="cli 工具中的代理"></a>cli 工具中的代理</h4><ol><li>Webpack (4.x)<br>在webpack中可以配置proxy来快速获得接口代理的能力。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">  entry: &#123;    <span class="attr">index</span>: <span class="string">&quot;./index.js&quot;</span>  &#125;,  </span><br><span class="line">  output: &#123;    </span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,    </span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>)  </span><br><span class="line">  &#125;,  </span><br><span class="line">  devServer: &#123;    </span><br><span class="line">    port: <span class="number">8000</span>,    </span><br><span class="line">    proxy: &#123;      </span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;        </span><br><span class="line">        target: <span class="string">&quot;http://localhost:8080&quot;</span>      </span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  plugins: [    </span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;     </span><br><span class="line">       filename: <span class="string">&quot;index.html&quot;</span>,      </span><br><span class="line">      template: <span class="string">&quot;webpack.html&quot;</span>    </span><br><span class="line">    &#125;)  </span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>修改前端接口请求方式，改为不带域名。（因为现在是同域请求了）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;getlist&quot;</span>&gt;获取列表&lt;button&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;login&quot;</span>&gt;登录&lt;/button&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;  </span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;  </span><br><span class="line">getlist.onclick = <span class="function">() =&gt;</span> &#123;    </span><br><span class="line">  axios.get(<span class="string">&quot;/api/corslist&quot;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;      </span><br><span class="line">    <span class="built_in">console</span>.log(res.data);    </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;;  </span><br><span class="line">login.onclick = <span class="function">() =&gt;</span> &#123;    axios.post(<span class="string">&quot;/api/login&quot;</span>);  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>Vue-cli 2.x<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/index.js</span></span><br><span class="line">...proxyTable: &#123;  <span class="string">&#x27;/api&#x27;</span>: &#123;     <span class="attr">target</span>: <span class="string">&#x27;http://localhost:8080&#x27;</span>,  &#125;&#125;,</span><br><span class="line">..</span><br></pre></td></tr></table></figure></li><li>Vue-cli 3.x<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js 如果没有就新建</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">  devServer: &#123;    </span><br><span class="line">    port: <span class="number">8000</span>,    </span><br><span class="line">    proxy: &#123;      </span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;        </span><br><span class="line">        target: <span class="string">&quot;http://localhost:8080&quot;</span>      </span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li>Parcel (2.x)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .proxyrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;http://localhost:8080&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="charles"><a href="#charles" class="headerlink" title="charles"></a>charles</h4>这是一个测试、开发的神器。<a href="https://juejin.cn/post/6844903665304600589">介绍与使用</a></li></ol><p>利用 charles 进行跨域，本质就是请求的拦截与代理。</p><p>在 tools/map remote 中设置代理</p><h3 id="6-Nginx-反向代理"><a href="#6-Nginx-反向代理" class="headerlink" title="6.Nginx 反向代理"></a>6.Nginx 反向代理</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。<br>只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>先下载nginx，然后将nginx目录下的nginx.conf修改如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass   http:&#x2F;&#x2F;www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http:&#x2F;&#x2F;www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过命令行nginx -s reload启动nginx</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 向前台写cookie</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>   <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="7-window-name-iframe"><a href="#7-window-name-iframe" class="headerlink" title="7.window.name + iframe"></a>7.window.name + iframe</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。<br>其中<code>a.html</code>和<code>b.html</code>是同域的，都是<code>http://localhost:3000;而c.html是http://localhost:4000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html(http://localhost:3000/b.html)</span></span><br><span class="line"> &lt;iframe src=<span class="string">&quot;http://localhost:4000/c.html&quot;</span> frameborder=<span class="string">&quot;0&quot;</span> onload=<span class="string">&quot;load()&quot;</span> id=<span class="string">&quot;iframe&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="keyword">let</span> first = <span class="literal">true</span></span><br><span class="line">   <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(first)&#123;</span><br><span class="line">     <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">       <span class="keyword">let</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">       iframe.src = <span class="string">&#x27;http://localhost:3000/b.html&#x27;</span>;</span><br><span class="line">       first = <span class="literal">false</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span><br><span class="line">       <span class="built_in">console</span>.log(iframe.contentWindow.name);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>b.html为中间代理页，与a.html同域，内容为空。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.html(http://localhost:4000/c.html)</span></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="built_in">window</span>.name = <span class="string">&#x27;我不爱你&#x27;</span></span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="8-location-hash-iframe"><a href="#8-location-hash-iframe" class="headerlink" title="8. location.hash +  iframe"></a>8. location.hash +  iframe</h3><p>实现原理： <code>a.html</code>欲与<code>c.html</code>跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用<code>iframe</code>的<code>location.hash</code>传值，相同域之间直接js访问来通信。<br>具体实现步骤：一开始<code>a.html</code>给<code>c.html</code>传一个<code>hash</code>值，然后<code>c.html</code>收到<code>hash</code>值后，再把<code>hash</code>值传递给<code>b.html</code>，最后<code>b.html</code>将结果放到<code>a.html</code>的<code>hash</code>值中。<br>同样的，<code>a.html</code>和<code>b.html</code>是同域的，都是<code>http://localhost:3000</code>;而<code>c.html</code>是<code>http://localhost:4000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html</span></span><br><span class="line"> &lt;iframe src=<span class="string">&quot;http://localhost:4000/c.html#iloveyou&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//检测hash的变化</span></span><br><span class="line">     <span class="built_in">console</span>.log(location.hash);</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.html</span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.parent.parent.location.hash = location.hash </span><br><span class="line">    <span class="comment">//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span></span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.html</span></span><br><span class="line"> <span class="built_in">console</span>.log(location.hash);</span><br><span class="line">  <span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">  iframe.src = <span class="string">&#x27;http://localhost:3000/b.html#idontloveyou&#x27;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(iframe);</span><br></pre></td></tr></table></figure><h3 id="9-document-domain-iframe"><a href="#9-document-domain-iframe" class="headerlink" title="9.document.domain + iframe"></a>9.document.domain + iframe</h3><p>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。<br>只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。<br>实现原理：两个页面都通过js强制设置<code>document.domain</code>为基础主域，就实现了同域。<br>我们看个例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中<code>a</code>的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line"> helloa</span><br><span class="line">  &lt;iframe src=<span class="string">&quot;http://b.zf1.cn:3000/b.html&quot;</span> frameborder=<span class="string">&quot;0&quot;</span> onload=<span class="string">&quot;load()&quot;</span> id=<span class="string">&quot;frame&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="built_in">document</span>.domain = <span class="string">&#x27;zf1.cn&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(frame.contentWindow.a);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.html</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">   hellob</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">     <span class="built_in">document</span>.domain = <span class="string">&#x27;zf1.cn&#x27;</span></span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h2 id="正向代理与反向代理比较"><a href="#正向代理与反向代理比较" class="headerlink" title="正向代理与反向代理比较"></a>正向代理与反向代理比较</h2><p>从用途上来讲：</p><ul><li>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。</li><li>反向代理的典型用途是为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。</li></ul><p>从安全性来讲：</p><ul><li>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。</li><li>反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</li></ul><p>从使用方来看：</p><ul><li>正向代理是浏览器端进行配置的，与服务器端无关，甚至可以对服务端隐藏。</li><li>反向代理是服务器端配置的，对浏览器端是透明的。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ul><ol><li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li><li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li><li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li><li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903767226351623">九种跨域方式实现原理（完整版）</a></li><li><a href="https://juejin.cn/post/6844904148022870023#heading-0">面试题：nginx有配置过吗?反向代理知道吗?</a></li><li><a href="https://juejin.cn/post/6844904126246027278#heading-0">10种跨域解决方案（附终极大招）</a></li><li><a href="https://segmentfault.com/a/1190000010719058">前端开发如何独立解决跨域问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JS之ES6语法知识点二</title>
    <link href="http://github.com/2021/01/25/JS%E4%B9%8BES6%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"/>
    <id>http://github.com/2021/01/25/JS%E4%B9%8BES6%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/</id>
    <published>2021-01-24T16:00:00.000Z</published>
    <updated>2021-01-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="新增类型"><a href="#新增类型" class="headerlink" title="新增类型"></a>新增类型</h2><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>Symbol 是一个新的原始类型，用来表示一个独一无二的值，可以通过 Symbol() 函数来创建一个 Symbol 类型的值，为了加以区分，可以传入一个字符串作为其描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">s1 === s2  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Symbol 类型无法通过数学运算符进行隐式类型转换，但是可以通过 String() 显示转成字符串或者通过 Boolean() 显示转成布尔值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">String</span>(s)     <span class="comment">// &quot;Symbol(&#x27;foo&#x27;)&quot;</span></span><br><span class="line">s.toString()  <span class="comment">// &quot;Symbol(&#x27;foo&#x27;)&quot;</span></span><br><span class="line"><span class="built_in">Boolean</span>(s)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>引入 Symbol 最大的初衷其实就是为了让它作为对象的属性名而使用，这样就可以有效避免属性名的冲突了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [foo]: <span class="string">&#x27;foo1&#x27;</span>,</span><br><span class="line">    foo: <span class="string">&#x27;foo2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[foo]  <span class="comment">// &#x27;foo1&#x27;</span></span><br><span class="line">obj.foo   <span class="comment">// &#x27;foo2&#x27;</span></span><br></pre></td></tr></table></figure><p>Symbol 属性的不可枚举性，不会被 for…in、for…of、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 等枚举：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;age&#x27;</span>)]: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(person)  <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(person)  <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(person)  <span class="comment">// &#x27;&#123;&quot;name&quot;:&quot;布兰&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>但是可以通过 Object.getOwnPropertySymbols() 获取到对象的所有 Symbol 属性名，返回一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(person)  <span class="comment">// [Symbol(age)]</span></span><br></pre></td></tr></table></figure><h3 id="静态方法："><a href="#静态方法：" class="headerlink" title="静态方法："></a>静态方法：</h3><ol><li><p>Symbol.for() 按照描述去全局查找 Symbol，找不到则在全局登记一个：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p> Symbol.for() 的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p></li><li><p>Symbol.keyFor() 根据已经在全局登记的 Symbol 查找其描述：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s)  <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Symbol-的内置值："><a href="#Symbol-的内置值：" class="headerlink" title="Symbol 的内置值："></a>Symbol 的内置值：</h3><ul><li><code>Symbol.hasInstance</code>：指向一个内部方法，当其他对象使用 <code>instanceof</code> 运算符判断是否为此对象的实例时会调用此方法；</li><li><code>Symbol.isConcatSpreadable</code>：指向一个布尔，定义对象用于 <code>Array.prototype.concat()</code> 时是否可展开；</li><li><code>Symbol.species：</code>指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数；</li><li><code>Symbol.match：</code>指向一个函数，当实例对象被 <code>String.prototype.match()</code> 调用时会重新定义<code>match()</code>的行为；</li><li><code>Symbol.replace：</code>指向一个函数，当实例对象被 <code>String.prototype.replace()</code> 调用时会重新定义 <code>replace()</code> 的行为；</li><li><code>Symbol.search：</code>指向一个函数，当实例对象被<code>String.prototype.search()</code>调用时会重新定义 <code>search()</code> 的行为；</li><li><code>Symbol.split</code>：指向一个函数，当实例对象被 <code>String.prototype.split()</code> 调用时会重新定义 <code>split() </code>的行为；</li><li><code> Symbol.iterator：</code>指向一个默认遍历器方法，当实例对象执行 <code>for...of </code>时会调用指定的默认遍历器；</li><li><code>Symbol.toPrimitive：</code>指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值；</li><li><code>Symbol.toStringTag：</code>指向一个函数，当实例对象被 <code>Object.prototype.toString()</code> 调用时其返回值会出现在 <code>toString()</code> 返回的字符串之中表示对象的类型；</li><li><code>Symbol.unscopables：</code>指向一个对象，指定使用 <code>with </code>时哪些属性会被 <code>with </code>环境排除；</li><li><code>Symbol.prototype.description</code> : 描述属性  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let symbol &#x3D; Symbol(&#39;foo&#39;)</span><br><span class="line">symbol.description  &#x2F;&#x2F; &#39;foo&#39;</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2></li></ul><p>Set 是一种新的数据结构，类似数组，但是它没有键只有值，且值都是唯一的。可以通过构造函数生成一个新实例，接收一个数组或者可迭代数据结构作为参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">&#x27;abc&#x27;</span>)      <span class="comment">// Set &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>Set 判断两个值是不是相等用的是 sameValueZero 算法，类似于 ===，唯一的区别是，在 Set 里 NaN 之间被认为是相等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span></span><br><span class="line">set.add(a)</span><br><span class="line">set.add(b)</span><br><span class="line">set.size  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>相同对象的不同实例也被 Set 认为是不相等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line">set.add(a)</span><br><span class="line">set.add(b)</span><br><span class="line">set.size  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>Set 是有顺序的，将按照插入的顺序进行迭代，可以使用 for…of 迭代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">set.add(<span class="number">5</span>)</span><br><span class="line">set.add(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set-实例属性和方法："><a href="#Set-实例属性和方法：" class="headerlink" title="Set 实例属性和方法："></a>Set 实例属性和方法：</h3><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是 <code>Set</code> 函数；</li><li><code>Set.prototype.size</code>：返回 <code>Set</code> 实例的成员总数；</li><li><code>Set.prototype.add(value)</code>：添加某个值，返回 <code>Set</code> 结构本身；</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功；</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员；</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值；</li><li><code>Set.prototype.keys()</code>：返回键名的遍历器；</li><li><code>Set.prototype.values()</code>：返回键值的遍历器；</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器；</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">set.add(<span class="number">5</span>)     <span class="comment">// Set &#123;1, 3, 5&#125;</span></span><br><span class="line">set.size       <span class="comment">// 3</span></span><br><span class="line">set.delete(<span class="number">1</span>)  <span class="comment">// true，1 已被删除</span></span><br><span class="line">set.has(<span class="number">1</span>)     <span class="comment">// false</span></span><br><span class="line">set.keys()     <span class="comment">// SetIterator &#123;3, 5&#125;</span></span><br><span class="line">set.clear()</span><br><span class="line">set.size       <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="Set-应用场景："><a href="#Set-应用场景：" class="headerlink" title="Set 应用场景："></a>Set 应用场景：</h3></li></ul><ol><li><p>数组去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>])]         <span class="comment">// [1, 3, 6]</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>]))  <span class="comment">// [1, 3, 6]</span></span><br></pre></td></tr></table></figure></li><li><p>字符串去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&#x27;abcbacd&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>)  <span class="comment">// &#x27;abcd&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>求两个集合的交集/并集/差集：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b])  <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)))  <span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)))  <span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>遍历修改集合成员的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>))     <span class="comment">// Set &#123;2, 3, 6&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(set, <span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>))  <span class="comment">// Set &#123;2, 4, 6&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p><code>WeakSet</code> 对象允许将弱保持对象存储在一个集合中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123;&#125;</span><br><span class="line">ws.add(foo)  <span class="comment">// WeakSet &#123;&#123;&#125;&#125;</span></span><br><span class="line">ws.has(foo)  <span class="comment">// true</span></span><br><span class="line">ws.delete(foo)  <span class="comment">// WeakSet &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>和 Set 的区别：</p><ul><li><code>WeakSet</code> 只能是对象的集合，而不能是任何类型的任意值；</li><li><code>WeakSet</code> 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 <code>WeakSet</code> 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 <code>WeakSet</code> 中没有存储当前对象的列表。正因为这样，WeakSet 是不可枚举的，也就没有 <code>size</code> 属性，没有 <code>clear</code> 和遍历的方法。</li></ul><p>实例方法：</p><ul><li><code>WeakSet.prototype.add(value)</code>：添加一个新元素 <code>value</code>；</li><li><code>WeakSet.prototype.delete(value)</code>：从该 WeakSet 对象中删除 <code>value</code> 这个元素；</li><li><code>WeakSet.prototype.has(value)</code>：返回一个布尔值,  表示给定的值 <code>value </code>是否存在于这个 <code>WeakSet</code> 中；</li></ul><p>应用场景</p><ul><li>储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li><li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在WeakSet结构中的引用就会自动消</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>Map</code> 是一种类似于 <code>Object</code> 的这种键值对的数据结构，区别是对象的键只能是字符串或者 <code>Symbol</code>，而 <code>Map </code>的键可以是任何类型（原始类型、对象或者函数），可以通过 <code>Map</code> 构造函数创建一个实例，入参是具有 <code>Iterator</code> 接口且每个成员都是一个双元素数组 <code>[key, value] </code>的数据结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map1.set(&#123;&#125;, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;布兰&#x27;</span>], [<span class="string">&#x27;age&#x27;</span>, <span class="number">12</span>]]</span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(arr)</span><br></pre></td></tr></table></figure><p>Map 中的键和 Set 里的值一样也必须是唯一的，遵循 sameValueZero 算法，对于同一个键后面插入的会覆盖前面的，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123;<span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span>&#125;</span><br><span class="line">map.set(foo, <span class="string">&#x27;foo1&#x27;</span>)</span><br><span class="line">map.set(foo, <span class="string">&#x27;foo2&#x27;</span>)</span><br><span class="line">map.get(foo)  <span class="comment">// &#x27;foo2&#x27; </span></span><br></pre></td></tr></table></figure><p>对于键名同为 NaN 以及相同对象而不同实例的处理同 Set 的值一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(a, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">map.set(b, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">map.size    <span class="comment">// 1</span></span><br><span class="line">map.get(a)  <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> d = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">map.set(c, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">map.set(d, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">map.size    <span class="comment">// 3</span></span><br><span class="line">map.get(c)  <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="实例属性和方法："><a href="#实例属性和方法：" class="headerlink" title="实例属性和方法："></a>实例属性和方法：</h3><ul><li><p><code>Map.prototype.size</code>：返回 <code>Map </code>对象的键值对数量；</p></li><li><p><code>Map.prototype.set(key, value)</code>：设置 <code>Map</code> 对象中键的值。返回该 <code>Map</code> 对象；</p></li><li><p><code>Map.prototype.get(key)</code>： 返回键对应的值，如果不存在，则返回 <code>undefined</code>；</p></li><li><p><code>Map.prototype.has(key)</code>：返回一个布尔值，表示<code>Map</code>实例是否包含键对应的值；</p></li><li><p><code>Map.prototype.delete(key)</code>： 如果 <code>Map</code> 对象中存在该元素，则移除它并返回 <code>true</code>；</p></li><li><p><code>Map.prototype.clear()</code>： 移除 <code>Map</code> 对象的所有键/值对；</p></li><li><p><code>Map.prototype.keys()</code>：返回一个新的 <code>Iterator</code> 对象， 它按插入顺序包含了 <code>Map</code> 对象中每个元素的键；</p></li><li><p><code>Map.prototype.values()</code>：返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map </code>对象中每个元素的值；</p></li><li><p><code>Map.prototype.entries()</code>：返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map </code>对象中每个元素的<code>[key, value]</code>数组；</p></li><li><p><code>Map.prototype.forEach(callbackFn[, thisArg])</code>：按插入顺序遍历 <code>Map</code>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">map.set(&#123;<span class="attr">a</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;a: 1&#125; &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#123;a: 2&#125; &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"><span class="comment">// &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2></li><li><p>定义：和Map结构类似，成员键只能是对象</p></li><li><p>声明：<code>const set = new WeakMap(arr)</code></p></li><li><p>入参：具有<code>Iterator</code>接口且每个成员都是一个双元素数组的数据结构<br>属性</p></li><li><p><code>constructor</code>：构造函数，返回<code>WeakMap</code></p></li></ul><p>方法</p><ul><li><code>get()</code>：返回键值对</li><li><code>set()</code>：添加键值对，返回实例</li><li><code>delete()</code>：删除键值对，返回布尔</li><li><code>has()</code>：检查键值对，返回布尔</li></ul><p>应用场景</p><ul><li>储存<code>DOM</code>节点：<code>DOM</code>节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li><li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li></ul><p>特点</p><ul><li>成员键都是弱引用，垃圾回收机制不考虑<code>WeakMap</code>结构对此成员键的引用</li><li>成员键不适合引用，它会随时消失，因此<code>ES6</code>规定<code>WeakMap</code>结构不可遍历</li><li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap</code>结构中</li><li>一旦不再需要，成员会自动消失，不用手动删除引用</li><li>弱引用的只是键而不是值，值依然是正常引用</li><li>即使在外部消除了成员键的引用，内部的成员值依然存在</li></ul><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p><code>Proxy</code> 用来定义基本操作的的自定义行为，可以理解为当对目标对象<code>target</code>进行某个操作之前会先进行拦截（执行 <code>handler </code>里定义的方法），必须要对 <code>Proxy</code> 实例进行操作才能触发拦截，对目标对象操作是不会拦截的，可以通过如下方式定义一个代理实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>&#125;, &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`hello, <span class="subst">$&#123;target.name&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">instance.name  <span class="comment">// &#x27;hello, 布兰&#x27;</span></span><br></pre></td></tr></table></figure><p>如果 <code>handle</code> 没有设置任何拦截，那么对实例的操作就会转发到目标对象身上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;)</span><br><span class="line">proxy.name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">target.name  <span class="comment">// &#x27;布兰&#x27;</span></span><br></pre></td></tr></table></figure><p>目标对象被 <code>Proxy</code> 代理的时候，内部的 this 会指向代理的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span> === proxy)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">target.m()  <span class="comment">// false</span></span><br><span class="line">proxy.m()   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="静态方法：-1"><a href="#静态方法：-1" class="headerlink" title="静态方法："></a>静态方法：</h3><p>Proxy.revocable() 用以定义一个可撤销的 Proxy：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(target, handler)</span><br><span class="line">  </span><br><span class="line">proxy.foo = <span class="number">123</span></span><br><span class="line">proxy.foo  <span class="comment">// 123</span></span><br><span class="line">revoke()</span><br><span class="line">proxy.foo  <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h3 id="handle-对象的方法："><a href="#handle-对象的方法：" class="headerlink" title="handle 对象的方法："></a>handle 对象的方法：</h3><ul><li><code>get(target, propKey, receiver)</code>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li><li><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置，比如 <code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li><code>has(target, propKey)</code>：拦截 <code>propKey in proxy </code>的操作，返回一个布尔值。</li><li><code>deleteProperty(target, propKey)</code>：拦截 <code>delete proxy[propKey]</code> 的操作，返回一个布尔值。</li><li><code>ownKeys(target)</code>：拦截 <code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in </code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 <code>Object.keys() </code>的返回结果仅包括目标对象自身的可遍历属性。</li><li><code>getOwnPropertyDescriptor(target, propKey)</code>：拦截<code>Object</code>.- <code>getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li><code>defineProperty(target, propKey, propDesc)</code>：拦截 <code>Object</code>.<code>defineProperty(proxy, propKey, propDesc)</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li><code>preventExtensions(target)</code>：拦截 <code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li><code>getPrototypeOf(target)</code>：拦截 <code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li><code>isExtensible(target)</code>：拦截 <code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li><code>setPrototypeOf(target, proto)</code>：拦截 <code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li><code>apply(target, object, args)</code>：拦截<code> Proxy</code> 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li><code>construct(target, args)</code>：拦截 <code>Proxy</code> 实例作为构造函数调用的操作，比如 <code>new proxy(...args)</code>。<h3 id="与Object-defineProperty对比"><a href="#与Object-defineProperty对比" class="headerlink" title="与Object.defineProperty对比"></a>与Object.defineProperty对比</h3><code>Object.defineProperty</code>：数据劫持：直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</li></ul><p>在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。数据劫持最典型的应用 —–&gt; 双向的数据绑定</p><ul><li><p>Object.defineProperty</p><p>  只能监听对象(Object)，不能监听数组的变化，无法触发push, pop, shift, unshift,splice, sort, reverse。<br>  必须遍历对象的每个属性<br>  只能劫持当前对象属性，如果想深度劫持，必须深层遍历嵌套的对象</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> value = <span class="number">1</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;listenA&#x27;</span>, &#123;</span><br><span class="line">writable: <span class="literal">true</span>,  <span class="comment">//可修改</span></span><br><span class="line">enumerable: <span class="literal">true</span>,  <span class="comment">// 可枚举   for...in...   Object.keys()</span></span><br><span class="line">configurable: <span class="literal">true</span>,  <span class="comment">// 可配置，可删除</span></span><br><span class="line">get: <span class="function">() =&gt;</span> value,</span><br><span class="line">set: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`set obj.listenA .. <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">    value = val</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">obj.listenA = <span class="number">2</span> <span class="comment">//set obj.listenA .. 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.listenA)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>Proxy</p><ul><li>可以直接监听对象而非属性</li><li>可以直接监听数组的变化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 代理整个对象</span><br><span class="line">let proxyObj &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">get: (target, key, receiver) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;getting $&#123;key&#125;!&#96;);</span><br><span class="line">    return target[key];</span><br><span class="line">&#125;,</span><br><span class="line">set: (target, key, value, receiver) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(target, key, value, receiver);</span><br><span class="line">    return target[key] &#x3D; value;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxyObj.val &#x3D; 1;    &#x2F;&#x2F; &#123;&#125; val 1 &#123;&#125;</span><br><span class="line">proxyObj.val;       &#x2F;&#x2F; getting val!</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;代理数组</span><br><span class="line">let proxyArr &#x3D; new Proxy([], &#123;</span><br><span class="line">get: (target, key, receiver) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;getting $&#123;key&#125;!&#96;);</span><br><span class="line">    return target[key];</span><br><span class="line">&#125;,</span><br><span class="line">set: (target, key, value, receiver) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(target, key, value, receiver);</span><br><span class="line">    return (target[key] &#x3D; value);</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxyArr[0] &#x3D; 1; &#x2F;&#x2F;  &#123;&#125; val 1 &#123;&#125;</span><br><span class="line">console.log(proxyArr[0]); &#x2F;&#x2F;  getting val!  &#x2F;&#x2F; 1</span><br><span class="line">console.log(proxyArr); &#x2F;&#x2F; [1]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903959283367950#heading-0">1.5万字概括ES6全部特性(已更新ES2020)</a></li><li><a href="https://juejin.cn/post/6895898051559456776#heading-0">送你一份精心总结的3万字ES6实用指南（上）</a></li><li><a href="https://juejin.cn/post/6896986598999588872#heading-0">「建议收藏」送你一份精心总结的3万字ES6实用指南（下）</a></li><li><a href="https://juejin.cn/post/6844903775329583112#heading-1">近一万字的ES6语法知识点补充</a></li><li><a href="https://juejin.cn/post/6844903679976275976#heading-1">ES6、ES7、ES8特性一锅炖(ES6、ES7、ES8学习指南)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;新增类型&quot;&gt;&lt;a href=&quot;#新增类型&quot; class=&quot;headerlink&quot; title=&quot;新增类型&quot;&gt;&lt;/a&gt;新增类型&lt;/h2&gt;&lt;h3 id=&quot;S
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之ES6语法知识点一</title>
    <link href="http://github.com/2021/01/23/JS%E4%B9%8BES6%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"/>
    <id>http://github.com/2021/01/23/JS%E4%B9%8BES6%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/</id>
    <published>2021-01-22T16:00:00.000Z</published>
    <updated>2021-01-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><blockquote><p>声明方法：var、const、let、function、class、import</p></blockquote><h3 id="let-const特性"><a href="#let-const特性" class="headerlink" title="let,const特性"></a>let,const特性</h3><ol><li><p>const：声明一个常量，let：声明一个变量；const/let 声明的常量/变量都只能作用于代码块（块级作用域或函数作用域）里；</p></li><li><p>const/let 不存在变量提升，所以在代码块里必须先声明然后才可以使用，这叫暂时性死区；</p></li><li><p>const/let 不允许在同一个作用域内，重复声明；</p></li><li><p>const 声明时必须初始化，且后期不能被修改，但如果初始化的是一个对象，那么不能修改的是该对象的内存地址；</p></li><li><p>const/let 在全局作用域中声明的常量/变量不会挂到顶层对象（浏览器中是 window ）的属性中；</p></li></ol><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h3 id="解构类型："><a href="#解构类型：" class="headerlink" title="解构类型："></a>解构类型：</h3><ol><li><p>字符串解构</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c = <span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;12&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)  <span class="comment">// &#x27;1&#x27; &#x27;2&#x27; &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数值解构</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toFixed</span>: tf&#125; = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log( tf.call(<span class="built_in">Math</span>.PI, <span class="number">2</span>) )  <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure></li><li><p>布尔值解构</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: ts&#125; = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log( ts.call(<span class="literal">false</span>) )  <span class="comment">// &#x27;false&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数组解构：等号右侧的数据具有 Iterator 接口可以进行数组形式的解构赋值；</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构不成功的变量值为 undefined</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)  <span class="comment">// 1, 2, undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以设置默认值</span></span><br><span class="line"><span class="keyword">let</span> [x, y, z = <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>]</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z)  <span class="comment">// 1, 2, null</span></span><br></pre></td></tr></table></figure><p> 什么样的数据具有 Iterator 接口呢？如果一个对象能够通过 [Symbol.iterator] 访问，且能够返回一个符合迭代器协议的对象，那么该对象就是可迭代的。目前内置的可迭代对象有：String、Array、TypeArray、Map、Set、arguments 和 NodeList 等。</p></li><li><p>对象解构：与数组按照索引位置进行解构不同，对象解构是按照属性名进行解构赋值，如果在当前对象属性匹配不成功则会去对象的原型属性上查找：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认写法</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: name, <span class="attr">age</span>: age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改名且设置默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: name1, <span class="attr">age</span>: age1 = <span class="number">12</span> &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name1, age1)  <span class="comment">// &#x27;布兰&#x27; 12</span></span><br></pre></td></tr></table></figure></li><li><p>函数参数解构：其实就是运用上面的对象解构和数组解构规则；</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([x, y])</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;)  <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;)        <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;)            <span class="comment">// [0, 0]</span></span><br><span class="line">move()              <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="解构要点："><a href="#解构要点：" class="headerlink" title="解构要点："></a>解构要点：</h3><ul><li>只要等号两边的模式相同（同是对象或同是数组），则左边的变量会被赋予对应的值；</li><li>解构不成功的变量值为 undefined；</li><li>默认值生效的前提是当等号右边对应的值全等于 undefined 的时候；</li><li>只要等号右边的值不是对象或者数组，则会进行自动装箱将其转成对象；</li><li>null 和 undefined 都无法转成对象，所以无法解构。</li></ul><h3 id="解构应用："><a href="#解构应用：" class="headerlink" title="解构应用："></a>解构应用：</h3><ol><li>交换变量的值； <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x]</span><br><span class="line"><span class="built_in">console</span>.log(x, y)  <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure></li><li>通过函数返回对象属性 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">        age: <span class="number">12</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name, age&#125; = getParams()</span><br></pre></td></tr></table></figure></li><li>通过定义函数参数来声明变量 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">init(person)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 普通用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;name, age&#125; = person</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 更简洁用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">&#123;name, age&#125;</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>指定函数参数默认值 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPerson</span>(<span class="params">&#123;name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name, age)</span><br><span class="line">&#125;</span><br><span class="line">initPerson()  <span class="comment">// &#x27;布兰&#x27; 12</span></span><br><span class="line">initPerson(&#123;<span class="attr">age</span>: <span class="number">20</span>&#125;)  <span class="comment">// &#x27;布兰&#x27; 20</span></span><br></pre></td></tr></table></figure></li><li>提取 JSON 数据 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> responseData = &#123;</span><br><span class="line">    code: <span class="number">1000</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    message: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> &#123; code, data = &#123;&#125; &#125; = responseData</span><br></pre></td></tr></table></figure></li><li>遍历 Map 结构 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line">map.set(<span class="string">&#x27;xiamen&#x27;</span>, <span class="string">&#x27;厦门&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>输入模块的指定方法和属性 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile, writeFile &#125; = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h2></li></ol><ul><li>模板字符串: <code>`$&#123;name&#125;`</code></li><li>Unicode表示法：大括号包含表示Unicode字符(\u{0xXX}或\u{0XXX})</li><li>字符串遍历：可通过for-of遍历字符串</li><li>字符串模板：可单行可多行可插入变量的增强版字符串</li><li>标签模板：函数参数的特殊调用</li><li>String.raw()：返回把字符串所有变量替换且对斜杠进行转义的结果</li><li>String.fromCodePoint()：返回码点对应字符</li><li>codePointAt()：返回字符对应码点(String.fromCodePoint()的逆操作)</li><li>normalize()：把字符的不同表示方法统一为同样形式，返回新字符串-(Unicode正规化)</li><li>repeat()：把字符串重复n次，返回新字符串</li><li>matchAll()：返回正则表达式在字符串的所有匹配</li><li>includes()：是否存在指定字符串</li><li>startsWith()：是否存在字符串头部指定字符串</li><li>endsWith()：是否存在字符串尾部指定字符串</li></ul><h2 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h2><ul><li>二进制表示法：0b或0B开头表示二进制(0bXX或0BXX)</li><li>八进制表示法：0o或0O开头表示二进制(0oXX或0OXX)</li><li>Number.EPSILON：数值最小精度</li><li>Number.MIN_SAFE_INTEGER：最小安全数值(-2^53)</li><li>Number.MAX_SAFE_INTEGER：最大安全数值(2^53)</li><li>Number.parseInt()：返回转换值的整数部分</li><li>Number.parseFloat()：返回转换值的浮点数部分</li><li>Number.isFinite()：是否为有限数值</li><li>Number.isNaN()：是否为NaN</li><li>Number.isInteger()：是否为整数</li><li>Number.isSafeInteger()：是否在数值安全范围内</li><li>Math.trunc()：返回数值整数部分</li><li>Math.sign()：返回数值类型(正数1、负数-1、零0)</li><li>Math.cbrt()：返回数值立方根</li><li>Math.clz32()：返回数值的32位无符号整数形式</li><li>Math.imul()：返回两个数值相乘</li><li>Math.fround()：返回数值的32位单精度浮点数形式</li><li>Math.hypot()：返回所有数值平方和的平方根</li><li>Math.expm1()：返回e^n - 1</li><li>Math.log1p()：返回1 + n的自然对数(Math.log(1 + n))</li><li>Math.log10()：返回以10为底的n的对数</li><li>Math.log2()：返回以2为底的n的对数</li><li>Math.sinh()：返回n的双曲正弦</li><li>Math.cosh()：返回n的双曲余弦</li><li>Math.tanh()：返回n的双曲正切</li><li>Math.asinh()：返回n的反双曲正弦</li><li>Math.acosh()：返回n的反双曲余弦</li><li>Math.atanh()：返回n的反双曲正切</li></ul><h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><ol><li><p>对象属性简写</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;aa&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name,</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;aa&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性名表达式：在用对象字面量定义对象的时候，允许通过属性名表达式来定义对象属性</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    [name]: <span class="string">&#x27;aa&#x27;</span>,</span><br><span class="line">    [<span class="string">&#x27;get&#x27;</span>+ name]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Object.is()：用来判断两个值是否相等，表现基本和 === 一样，除了以下两种情况：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span>            <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>          <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>Object.assign()：合并对象(浅拷贝)，返回原对象</p><p> Object.assign() 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target），如果有同名属性，则后面的会直接替换前面的：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> source1 = &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">d</span>: &#123;<span class="attr">e</span>: <span class="number">1</span>, <span class="attr">f</span>: <span class="number">2</span>&#125; &#125;</span><br><span class="line"><span class="keyword">let</span> source2 = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: &#123;<span class="attr">g</span>: <span class="number">3</span>&#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2)</span><br><span class="line">target  <span class="comment">// &#123; a: 3, b: 3, c: 4, d: &#123;g: 3&#125; &#125;</span></span><br></pre></td></tr></table></figure><p> Object.assign() 实行的是浅拷贝，如果源对象某个属性是对象，那么拷贝的是这个对象的引用：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> source = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line">target.a.b = <span class="number">3</span></span><br><span class="line">source.a.b  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p>__proto__：返回或设置对象的原型对象</p></li><li><p>Object.values()</p><p> 返回一个由对象自身所有可遍历属性的属性值组成的数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="number">12</span>,</span><br><span class="line">    enumrable: <span class="literal">false</span>  <span class="comment">// age 属性将不可遍历</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(person))  <span class="comment">// [&#x27;布兰&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似 str.split(&#x27;&#x27;) 效果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(<span class="string">&#x27;abc&#x27;</span>))  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>Object.entries()</p><p> 返回一个由对象自身所有可遍历属性的键值对组成的数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(person))  <span class="comment">// [[&quot;name&quot;, &quot;布兰&quot;], [&quot;age&quot;, 12]]</span></span><br></pre></td></tr></table></figure><p> 利用这个方法可以很好的将对象转成正在的 Map 结构：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(person))</span><br><span class="line"><span class="built_in">console</span>.log(map)  <span class="comment">// Map &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Object.fromEntries()</p><p>Object.fromEntries() 方法是 Object.entries() 的逆操作，用于将一个键值对数组转为对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> keyValueArr = <span class="built_in">Object</span>.entries(person)   <span class="comment">// [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(arr)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Object.getOwnPropertyDescriptors()</p><p>Object.getOwnPropertyDescriptor() 会返回指定对象某个自身属性的的描述对象，而 Object.getOwnPropertyDescriptors() 则是返回指定对象自身所有属性的描述对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person))</span><br><span class="line"><span class="comment">//&#123; </span></span><br><span class="line"><span class="comment">//  name: &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;,</span></span><br><span class="line"><span class="comment">//  age: &#123;configurable: false, enumerable: false, value: 12, writable: false&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>配合 Object.create() 可以实现浅克隆：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="built_in">Object</span>.create(</span><br><span class="line">    <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>Object.setPrototypeOf()与Object.getPrototypeOf()</p><p>Object.setPrototypeOf() 用于设置对象原型，Object.getPrototypeOf() 用于读取对象原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, &#123;<span class="attr">name</span>: <span class="string">&#x27;动物&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person)  <span class="comment">// &#123;name: &#x27;动物&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h2><ol><li><p>数组扩展运算符</p><p> 数组扩展运算符（…）将数组展开成用逗号分隔的参数序列，只能展开一层数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用一：函数传参</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用二：数组合并</span></span><br><span class="line"><span class="keyword">let</span> merge = [...[<span class="number">1</span>, <span class="number">2</span>], ...[<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, <span class="number">6</span>]  <span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用三：浅克隆</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> clone = [...a]</span><br><span class="line">a === clone  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用四：数组解构</span></span><br><span class="line"><span class="keyword">const</span> [x, ...y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x  <span class="comment">// 1</span></span><br><span class="line">y  <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.from()</p><p> Array.from()可以将类数组对象（ NodeList，arguments）和可迭代对象转成数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用一：字符串转数组</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;foo&#x27;</span>)  <span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用二：数组合并去重</span></span><br><span class="line"><span class="keyword">let</span> merge = [...[<span class="number">1</span>, <span class="number">2</span>], ...[<span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(merge))  <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用三：arguments 转数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p> 如果 Array.from() 带第二个参数 mapFn，将对生成的新数组执行一次 map 操作：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x )    <span class="comment">// [1, 4, 9]</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> ++i)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.of()</p><p> Array.of()将一组参数转成数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayOf</span>(<span class="params">...params</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].slice.call(params)</span><br><span class="line">&#125;</span><br><span class="line">arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.copyWithin()</p><p> Array.copyWithin()在当前数组内部，将制定位置的成员复制到其他位置（会覆盖原来位置的成员），最后返回一个新数组。接收 3 个参数，参数为负数表示右边开始计算：</p><ul><li>target（必选）：替换位置的索引；</li><li>start（可选）：从该位置开始读取数据，默认为 0；</li><li>end（可选）：从该位置结束读取数据（不包括该位置的数据），默认为原数组长度；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-1</span>)         <span class="comment">// [1, 2, 3, 4, 1]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1</span>)          <span class="comment">// [1, 1, 2, 3, 4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)    <span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-3</span>, <span class="number">-1</span>)  <span class="comment">// [3, 4, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查找第一个出现的子成员：find() 和 findIndex()：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出第一个偶数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>].find(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span> val % <span class="number">2</span> === <span class="number">0</span>)       <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出第一个偶数的索引位置</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>].findIndex(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span> val % <span class="number">2</span> === <span class="number">0</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>fill() 使用给定的值来填充数组，有 3 个参数：</p><ul><li>value：填充值；</li><li>start（可选），开始索引，默认为 0；</li><li>end（可选）：结束索引，默认为数组长度，不包括该索引位置的值；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化空数组</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">1</span>)  <span class="comment">// [1, 1, 1]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].fill(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>)  <span class="comment">// [1, 2, &#x27;a&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过 keys()（键名）、entries()（键值）和 values()（键值对） 获取数组迭代器对象，可以被 for…of 迭代，</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)  <span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)  <span class="comment">// [0, &#x27;a&#x27;] [0, &#x27;b&#x27;] [0, &#x27;c&#x27;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组空位</p><p> 指数组没有值，比如：[,,]，而像这种 [undefined] 是不包含空位的。由于 ES6 之前的一些 API 对空位的处理规则很不一致，所以实际操作的时候应该尽量避免空位的出现，而为了改变这个现状，ES6 的 API 会默认将空位处理成 undefined：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[<span class="number">1</span>, , <span class="number">3</span>].values()]  <span class="comment">// [1, undefined, 3]</span></span><br><span class="line">[<span class="number">1</span>, , <span class="number">3</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> x === <span class="literal">undefined</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.includes</p><p> 判断一个数组是否包含某个元素，之前一般是这么做的：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) &gt;= <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (~arr.indexOf(el)) &#123;&#125;</span><br></pre></td></tr></table></figure><p> 而现在你可以这么做了：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.includes(el)) &#123;&#125;</span><br></pre></td></tr></table></figure><p> indexOf 会返回找到元素在数组中的索引位置，判断的逻辑是是否严格相等，所以他在遇到 NaN 的时候不能正确返回索引，但是 includes 解决了这个问题：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">3</span>].indexOf(<span class="literal">NaN</span>)   <span class="comment">// -1</span></span><br><span class="line">[<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">3</span>].includes(<span class="literal">NaN</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.prototype.flat()</code>: 扁平化嵌套数组和移除数组中的空项:</p><p>arr.flat(depth) 按照 depth （不传值的话默认是 1）深度拍平一个数组，并且将结果以新数组形式返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// depth 默认是 1</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(arr1.flat())  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Infinity，可展开任意深度的嵌套数组；自动跳过空数组；</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, , [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]]]]</span><br><span class="line"><span class="built_in">console</span>.log(arr2.flat(<span class="literal">Infinity</span>))</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>用 reduce 实现拍平一层数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> newStr = arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc.concat(cur), [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">const</span> flattened = <span class="function"><span class="params">arr</span> =&gt;</span> [].concat(...arr)</span><br><span class="line">flattened(arr)</span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.flatMap()</p><p>flatMap(callback) 使用映射函数 callback 映射每个元素，callback 每次的返回值组成一个数组，并且将这个数组执行类似 arr.flat(1) 的操作进行拍平一层后最后返回结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// 将 [[2], [4], [6], [8]] 数组拍平一层得到最终结果：[2, 4, 6, 8]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h2><ol><li><p>函数参数默认值</p><ul><li><p>参数不能有同名的</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, x, y = <span class="number">1</span></span>) </span>&#123;&#125;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li><li><p>函数体内不能用 let 和 const 声明同参数名的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>length：返回没有指定默认值的参数个数</p><p>  如果设置默认值的参数不是尾参数，则 length 不再计入后面的参数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>)</span>&#123;&#125;).length      <span class="comment">// 2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">1</span></span>)</span>&#123;&#125;).length  <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>)</span>&#123;&#125;).length  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>rest/spread参数(…)：返回函数多余参数</p><ul><li>形式：以数组的形式存在，之后不能再有其他参数</li><li>作用：代替Arguments对象</li><li>length：返回没有指定默认值的参数个数但不包括rest/spread参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, ...y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> y) &#123;</span><br><span class="line">        coonsole.log(val)  <span class="comment">// 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>严格模式：在严格条件下运行JS</p><ul><li>应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式</li><li>规避限制的办法有两个：设置全局的严格模式或者在函数体外在包一个立即执行函数并且声明严格模式：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">2</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二</span></span><br><span class="line"><span class="keyword">let</span> f = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y = <span class="number">2</span></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>箭头函数(=&gt;)</p><p> 箭头函数语法比函数表达式更简洁，并且没有自己的 this、arguments，不能用作构造函数和用作生成器。</p><ul><li>箭头函数误区<ul><li>函数体内的this是定义时所在的对象而不是使用时所在的对象</li><li>可让this指向固定化，这种特性很有利于封装回调函数</li><li>不可当作构造函数，因此箭头函数不可使用new命令</li><li>不可使用yield命令，因此箭头函数不能用作Generator函数</li><li>不可使用Arguments对象，此对象在函数体内不存在(可用rest/spread参数代替)</li><li>返回对象时必须在对象外面加上括号</li></ul></li></ul></li><li><p>尾调用优化：只保留内层函数的调用帧</p><ul><li>尾调用<ul><li>定义：某个函数的最后一步是调用另一个函数</li><li>形式：function f(x) { return g(x); }</li></ul></li><li>尾递归<ul><li>定义：函数尾调用自身</li><li>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</li><li>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</li></ul></li></ul></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903959283367950#heading-0">1.5万字概括ES6全部特性(已更新ES2020)</a></li><li><a href="https://juejin.cn/post/6895898051559456776#heading-0">送你一份精心总结的3万字ES6实用指南（上）</a></li><li><a href="https://juejin.cn/post/6896986598999588872#heading-0">「建议收藏」送你一份精心总结的3万字ES6实用指南（下）</a></li><li><a href="https://juejin.cn/post/6844903775329583112#heading-1">近一万字的ES6语法知识点补充</a></li><li><a href="https://juejin.cn/post/6844903679976275976#heading-1">ES6、ES7、ES8特性一锅炖(ES6、ES7、ES8学习指南)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;声
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之模块化</title>
    <link href="http://github.com/2021/01/23/JS%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://github.com/2021/01/23/JS%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2021-01-22T16:00:00.000Z</published>
    <updated>2021-01-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统。参见阮一峰老师的文章<a href="https://es6.ruanyifeng.com/#docs/module-loader">module-loader</a> 。</p><h3 id="原生模块化"><a href="#原生模块化" class="headerlink" title="原生模块化"></a>原生模块化</h3><p>一个函数就是一个模块</p><ol><li><p>一个函数就是一个模块</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">m1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">m2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 缺点：污染了全局变量，无法保证不会与其它模块发生冲突，而且模块成员之间看不出直接关系。</p></li><li><p>一个对象就是一个模块</p><p> 对象写法 为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> module1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">    _sum: <span class="number">0</span>,</span><br><span class="line">    foo1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    foo2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 缺点：会暴露所有模块成员，内部的状态可能被改写。</p><p> 例如，我们如果只是想暴露出两个方法而不暴露出<code>_sum</code>，就做不到。<br> 而此时，<code>_sum</code>可能被外部改写：<br> <code>module1._sum = 2;</code></p></li><li><p>立即执行函数为一个模块</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> foo1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> foo2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo1: foo1,</span><br><span class="line">      foo2: foo2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> 利用立即执行函数内的作用域已经闭包来实现模块功能，导出我们想要导出的成员。<br> 此时外部代码就不能读取到_sum了：</p><p> <code>console.log(module1._sum) // undefined </code></p><h3 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h3><p>Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。</p></li></ol><h4 id="暴露-定义-模块"><a href="#暴露-定义-模块" class="headerlink" title="暴露(定义)模块"></a>暴露(定义)模块</h4><p>暴露模块有两种方式：</p><ol><li><code>module.exports = &#123;&#125;</code></li><li><code>exports.xxx = &#39;xxx&#39;</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种暴露方式：</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name: <span class="string">&#x27;aa&#x27;</span>,</span><br><span class="line">    sex: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种暴露方式：</span></span><br><span class="line"><span class="built_in">exports</span>.name = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line"><span class="built_in">exports</span>.sex = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.name = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.sex = <span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="引用-引入-模块"><a href="#引用-引入-模块" class="headerlink" title="引用(引入)模块"></a>引用(引入)模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用自定义的模块时，参数包含路径，可省略.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用核心模块时，不需要带路径</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">http.createService(...).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;js</span><br><span class="line">var m1Url &#x3D; &#39;.&#x2F;m1.js&#39;;</span><br><span class="line">var m1 &#x3D; require(m1Url);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 甚至做一些字符串拼接：</span><br><span class="line">var m1 &#x3D; require(&#39;.&#x2F;m&#39; + &#39;1.js&#39;);</span><br></pre></td></tr></table></figure><p>这个传参可以为表达式并不是<code>require</code>特有的。因为JS语言是传值调用，函数或者方法在调用的时候参数会被先计算出来，因此在我们使用require方法并传入表达式的时候，会先计算出表达式的值再传递给<code>require</code>。</p><h4 id="模块标识符-标识"><a href="#模块标识符-标识" class="headerlink" title="模块标识符(标识)"></a>模块标识符(标识)</h4><blockquote><p>模块标识符其实就是你在引入模块时调用require()函数的参数</p></blockquote><p>引入不同模块</p><ul><li>核心模块(Node.js自带的模块(<code>const path = require(&#39;path&#39;);</code>)</li><li>路径模块(相对或绝对定位开始的模块)(<code>const m1 = require(&#39;./m1.js&#39;);</code>)</li><li>自定义模块(node_modules里的模块)(<code>const lodash = require(&#39;lodash&#39;);</code>)</li></ul><p>三种模块的查找方式：</p><ul><li>核心模块: 直接跳过路径分析和文件定位</li><li>路径模块: 直接得出相对路径就好了</li><li>自定义模块: 先在当前目录的node_modules里找这个模块，如果没有，它会往上一级目录查找，查找上一级的node_modules，依次往上，直到根目录下都没有, 就抛出错误。</li></ul><h4 id="CommonJS规范的特点"><a href="#CommonJS规范的特点" class="headerlink" title="CommonJS规范的特点"></a>CommonJS规范的特点</h4><ol><li>所有代码都运行在模块作用域，不会污染全局作用域；</li><li>模块是同步加载的，即只有加载完成，才能执行后面的操作；</li><li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存；</li><li>CommonJS输出是值的拷贝(即，require返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值)。<blockquote><p>CommonJS输出是值的拷贝，这个对于引用类型的变量来说还是会有一点歧义的，比如下面的advantage那个例子，大家知道就行了。</p></blockquote></li></ol><p>CommonJS输出是值的拷贝案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js:</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> sex = <span class="string">&#x27;boy&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> advantage = [<span class="string">&#x27;handsome&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  sex = <span class="string">&#x27;girl&#x27;</span>;</span><br><span class="line">  advantage.push(<span class="string">&#x27;cute&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.name = name;</span><br><span class="line"><span class="built_in">exports</span>.sex = sex;</span><br><span class="line"><span class="built_in">exports</span>.advantage = advantage;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js:</span></span><br><span class="line"><span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;./m1&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;read count after 1000ms in commonjs is&#x27;</span>, m1.sex)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;read count after 1000ms in commonjs is&#x27;</span>, m1.advantage)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>执行node test.js之后的执行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read count after 1000ms in commonjs is boy</span><br><span class="line">read count after 1000ms in commonjs is [ &#39;handsome&#39;, &#39;cute&#39; ]</span><br></pre></td></tr></table></figure><p>也就是说，在开始var m1 = require(‘./m1’)的时候，m1已经被引入进来了，但是过了500ms后我改变了原本m1里的一些属性，sex这种基本数据类型是不会被改变的，但是advantage这种引用类型共用的还是同一个内存地址。（这种复制的关系让我想到了之前学原型链继承的时候，它那里也是，会影响Father.prototype上的引用类型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果advantage重新赋值</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  sex = <span class="string">&#x27;girl&#x27;</span>;</span><br><span class="line">  advantage = [<span class="string">&#x27;cute&#x27;</span>];</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 commonjs is [ &#x27;handsome&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><blockquote><p>为了能让我们采用异步的方式加载模块。</p></blockquote><ol><li>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</li><li>AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。<h4 id="用require-config-指定引用路径"><a href="#用require-config-指定引用路径" class="headerlink" title="用require.config()指定引用路径"></a>用require.config()指定引用路径</h4></li></ol><p>首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置require.config()并规定项目中用到的基础模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 网页中引入require.js及main.js **/</span></span><br><span class="line">&lt;script src=<span class="string">&quot;js/require.js&quot;</span> data-main=<span class="string">&quot;js/main&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  baseUrl: <span class="string">&quot;js/lib&quot;</span>,</span><br><span class="line">  paths: &#123;</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery.min&quot;</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">&quot;underscore&quot;</span>: <span class="string">&quot;underscore.min&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;jquery&quot;</span>,<span class="string">&quot;underscore&quot;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$,_</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="暴露-定义-模块-1"><a href="#暴露-定义-模块-1" class="headerlink" title="暴露(定义)模块"></a>暴露(定义)模块</h4><p><code>define(id?, dependencies?, factory)</code></p><ul><li>id: 一个字符串，表示模块的名称，但是是可选的</li><li>dependencies: 一个数组，是我们当前定义的模块要依赖于哪些模块，数组中的每一项表示的是要依赖模块的相对路径，且这个参数也是可选的</li><li>factory: 工厂方法，一个函数，这里面就是具体的模块内容了</li></ul><p>如果我们定义的模块本身依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义math.js模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add,</span><br><span class="line">        basicNum :basicNum</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义一个依赖underscore.js的模块</span></span><br><span class="line">define([<span class="string">&#x27;underscore&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">_</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> classify = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">    _.countBy(list,<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num &gt; <span class="number">30</span> ? <span class="string">&#x27;old&#x27;</span> : <span class="string">&#x27;young&#x27;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    classify :classify</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="引用模块"><a href="#引用模块" class="headerlink" title="引用模块"></a>引用模块</h4><p>引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入requirejs模块</span></span><br><span class="line"><span class="keyword">var</span> requirejs = <span class="built_in">require</span>(<span class="string">&quot;requirejs&quot;</span>);</span><br><span class="line"></span><br><span class="line">requirejs([<span class="string">&#x27;math&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(math)</span><br><span class="line">  <span class="built_in">console</span>.log(math.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用模块，将模块放在[]内</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;math&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$, math</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = math.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">  $(<span class="string">&quot;#sum&quot;</span>).html(sum);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h3><blockquote><p>CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。</p></blockquote><p>require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** AMD写法 **/</span></span><br><span class="line">define([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 等于在最前面声明并初始化了要用到的所有模块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span></span><br><span class="line">      b.foo()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行，只有到require时依赖模块才执行。此规范其实是在sea.js推广过程中产生的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** CMD写法 **/</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>); <span class="comment">//在需要时申明</span></span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line">        b.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** sea.js **/</span></span><br><span class="line"><span class="comment">// 定义模块 math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery.js&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exports</span>.add = add;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">&#x27;math.js&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = math.add(<span class="number">1</span>+<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="AMD和CMD的区别。"><a href="#AMD和CMD的区别。" class="headerlink" title="AMD和CMD的区别。"></a>AMD和CMD的区别。</h4><blockquote><p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同，二者皆为异步加载模块。</p></blockquote><p>虽然它们的define()方法的参数都相同，但是:</p><p>AMD中会把当前模块的依赖模块放到dependencies中加载，并在factory回调中拿到加载成功的依赖CMD一般不在dependencies中加载，而是写在factory中，使用require加载某个依赖模块<br>因此才有了我们常常看到的一句话：</p><p>还是上面那句话，让我们来看个小例子理解一下。</p><p>同样是math模块中需要加载m1模块。</p><p>在AMD中我们会这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define([<span class="string">&#x27;m1&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是math, 我被加载了...&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(m1.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    add: add,</span><br><span class="line">    print: print</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是对于CMD，我们会这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我是math, 我被加载了...&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;m1&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(m1.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add: add,</span><br><span class="line">    print: print</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>假如此时m1.js中有一个语句是在m1模块被加载的时候打印出”我是m1, 我被加载了…”。</p><p>执行结果区别：</p><p>AMD，会先加载m1，”我是m1”会先执行CMD，我是”我是math”会先执行，因为本题中console.log(‘我是math, 我被加载了…’)是放在require(‘m1’)前面的。<br>现在可以很明显的看到区别了。<br>AMD依赖前置，js很方便的就知道要加载的是哪个模块了，因为已经在define的dependencies参数中就定义好了，会立即加载它。</p><p>CMD是就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块。<br>OK👌，来看个总结：</p><p>两者之间，最明显的区别就是在模块定义时对依赖的处理不同</p><ul><li>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</li><li>CMD推崇就近依赖，只有在用到某个模块的时候再去require</li></ul><h3 id="ES6-Modules规范"><a href="#ES6-Modules规范" class="headerlink" title="ES6 Modules规范"></a>ES6 Modules规范</h3><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p><h4 id="export导出模块"><a href="#export导出模块" class="headerlink" title="export导出模块"></a>export导出模块</h4><p>export有两种模块导出方式：</p><ul><li>命名式导出(名称导出)</li><li>默认导出(自定义导出)</li></ul><ol><li><p>命名式导出</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种为错误</span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为正确</span></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; a &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 接口名与模块内部变量之间，建立了一一对应的关系</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 接口名与模块内部变量之间，建立了一一对应的关系</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者用 as 来命名</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; a <span class="keyword">as</span> outA &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; a <span class="keyword">as</span> outA, b <span class="keyword">as</span> outB &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 容易混淆的可能是2和4两种写法了，看着很像，但是2却不行。2直接导出一个值为1的变量是和情况一一样，没有什么意义，因为你在后面要用的时候并不能完成解构。</p><p> 但是4中，接口名与模块内部变量之间，建立了一一对应的关系，所以可以。</p></li><li><p>默认导出</p><p> 默认导出会在export后面加上一个default：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; a &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 可以导出一个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span>()</span>&#123;&#125;; <span class="comment">// 也可以出一个类</span></span><br><span class="line">复制代码</span><br><span class="line">其实，默认导出可以理解为另一种形式上的命名导出，也就是说a这个属性名相当于是被我重写了成了<span class="keyword">default</span>：</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> defalut a;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">export</span> &#123; a <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br></pre></td></tr></table></figure><p> 所以，我们才可以用const a = 1; export default a;这种方式导出一个值。</p><h4 id="import导入模块"><a href="#import导入模块" class="headerlink" title="import导入模块"></a>import导入模块</h4><p>import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。</p></li><li><p>写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 某个模块的导出 moudule.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块导入</span></span><br><span class="line"><span class="comment">// 1. 这里的a得和被加载的模块输出的接口名对应</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 as 换名</span></span><br><span class="line"><span class="keyword">import</span> &#123; a <span class="keyword">as</span> myA &#125; <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 若是只想要运行被加载的模块可以这样写，但是即使加载2次也只是运行一次</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./module&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 整体加载</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. default接口和具名接口</span></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">module</span>, &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span></span><br></pre></td></tr></table></figure><p>第四种写法会获取到module中所有导出的东西，并且赋值到module这个变量下，这样我们就可以用module.a这种方式来引用a了。</p></li><li><p>export … from…</p></li></ol><p>其实还有一种写法，可以将export和from结合起来用。<br>例如，我有三个模块a、b、c。<br>c模块现在想要引入a模块，但是它不不直接引用a，而是通过b模块来引用，那么你可能会想到b应该这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; someVariable &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; someVariable &#125;;</span><br></pre></td></tr></table></figure><p>引入someVariable然后再导出。<br>这还只是一个变量，我们得导入再导出，若是有很多个变量需要这样，那无疑会增加很多代码量。<br>所以这时候可以用下面这种方式来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; someVariable &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>不过这种方式有一点需要注意：</p><p>这样的方式不会将数据添加到该聚合模块的作用域, 也就是说, 你无法在该模块(也就是b)中使用someVariable。</p><h4 id="ES6-Modules规范的特点"><a href="#ES6-Modules规范的特点" class="headerlink" title="ES6 Modules规范的特点"></a>ES6 Modules规范的特点</h4><p>总结一下它的特点哈：</p><ul><li>输出使用export</li><li>输入使用import</li><li>可以使用export…from…这种写法来达到一个”中转”的效果</li><li>输入的模块变量是不可重新赋值的，它只是个可读引用，不过却可以改写属性</li><li>export命令和import命令可以出现在模块的任何位置，只要处于模块顶层就可以。 如果处于块级作用域内，就会报错，这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。</li><li>import命令具有提升效果，会提升到整个模块的头部，首先执行。</li></ul><h4 id="Bable下的ES6模块转换"><a href="#Bable下的ES6模块转换" class="headerlink" title="Bable下的ES6模块转换"></a>Bable下的ES6模块转换</h4><p>还有一点就是，如果你有使用过一些ES6的Babel的话，你会发现当使用export/import的时候，Babel也会把它转换为exports/require的形式。<br>例如我的输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>我的输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index.js:</span><br><span class="line"><span class="keyword">import</span> &#123;count&#125; <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(count)</span><br></pre></td></tr></table></figure><p>当使用Babel编译之后，各自会被转换为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m1.js:</span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123;</span><br><span class="line">  value: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">exports</span>.count = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exports</span>.count = count;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index.js:</span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _m = <span class="built_in">require</span>(<span class="string">&quot;./m1.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_m.count);</span><br></pre></td></tr></table></figure><p>正是因为这种转换关系，才能让我们把exports和import结合起来用：<br>也就是说你可以这样用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出模块 m1.js</span></span><br><span class="line"><span class="built_in">exports</span>.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js中引入</span></span><br><span class="line"><span class="keyword">import</span> &#123;count&#125; <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(count)</span><br></pre></td></tr></table></figure><h3 id="CommonJS与ES6-Modules规范的区别"><a href="#CommonJS与ES6-Modules规范的区别" class="headerlink" title="CommonJS与ES6 Modules规范的区别"></a>CommonJS与ES6 Modules规范的区别</h3><ol><li><p>CommonJS输出是值的拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变</p><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul></li><li><p>CommonJS模块是运行时加载，ES6 Modules是编译时输出接口</p><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li></ul></li></ol><pre><code>- 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</code></pre><ol start="3"><li>CommonJS加载的是整个模块，将所有的接口全部加载进来，ES6 Module可以单独加载其中的某个接口；</li><li>CommonJs导入的模块路径可以是一个表达式，因为它使用的是require()方法；而ES6 Modules只能是字符串</li><li>CommonJS this指向当前模块，ES6 Modules this指向undefined</li><li>且ES6 Modules中没有这些顶层变量：arguments、require、module、exports、__filename、__dirname</li></ol><p>关于第2个差异，是因为CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>目前浏览器对ES6 Module兼容还不太好，我们平时在webpack中使用的export/import，会被打包为exports/require。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903576309858318">前端模块化：CommonJS,AMD,CMD,ES6</a></li><li><a href="https://juejin.cn/post/6844904145443356680">CommonJS和ES6模块规范讲解</a></li><li><a href="https://juejin.cn/post/6844903520865386510#heading-1">import、require、export、module.exports 混合使用详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;模块化&quot;&gt;&lt;a href=&quot;#模块化&quot; class=&quot;headerlink&quot; title=&quot;模块化&quot;&gt;&lt;/a&gt;模块化&lt;/h2&gt;&lt;p&gt;模块化的开发方式可以
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之Promise</title>
    <link href="http://github.com/2021/01/20/JS%E4%B9%8BPromise/"/>
    <id>http://github.com/2021/01/20/JS%E4%B9%8BPromise/</id>
    <published>2021-01-19T16:00:00.000Z</published>
    <updated>2021-01-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="Promise-初探"><a href="#Promise-初探" class="headerlink" title="Promise 初探"></a>Promise 初探</h2><h3 id="什么是-Promise？"><a href="#什么是-Promise？" class="headerlink" title="什么是 Promise？"></a>什么是 Promise？</h3><p>Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。现已被 ES6 纳入进规范中。</p><p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p><h3 id="Promise-出现的原因"><a href="#Promise-出现的原因" class="headerlink" title="Promise 出现的原因"></a>Promise 出现的原因</h3><ol><li>为了解决回调地狱带来的负面作用<ul><li>代码臃肿。</li><li>可读性差。</li><li>耦合度过高，可维护性差。</li><li>代码复用性差。</li><li>容易滋生 bug。</li><li>只能在回调里处理异常。</li></ul></li><li>解决异步嵌套的问题。</li></ol><h3 id="Promise-如何使用？常用的方法有哪些？它们的作用是什么？"><a href="#Promise-如何使用？常用的方法有哪些？它们的作用是什么？" class="headerlink" title="Promise 如何使用？常用的方法有哪些？它们的作用是什么？"></a>Promise 如何使用？常用的方法有哪些？它们的作用是什么？</h3><h4 id="1-new-Promise"><a href="#1-new-Promise" class="headerlink" title="1. new Promise"></a>1. new Promise</h4><p>首先，我们先看看如何走一个 new Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(resolve); <span class="comment">// [Function]</span></span><br><span class="line">  <span class="built_in">console</span>.log(reject); <span class="comment">// [Function]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise); <span class="comment">// Promise &#123; &lt;pending&gt; &#125;</span></span><br></pre></td></tr></table></figure><p>然后，我们对这几个概念进行区分：</p><ol><li><p>Promise 对象是一个构造函数，用来生成 Promise 实例，所以 new Promise() 不足奇怪。</p></li><li><p>new Promise() 传入一个函数，这个函数可以带 2 个参数：resolve 和 reject。</p></li><li><p>resolve 的作用是将 Promise 对象的状态从 “未完成” 变为 “成功”（pending -&gt; resolved）</p></li><li><p>reject 的作用是将 Promise 对象的状态从 “未完成” 变为 “失败”（pending -&gt; rejected）</p></li><li><p>在没有执行 resolve 和 reject 之前，它们还是 pending 的。</p><h4 id="2-Promise-状态"><a href="#2-Promise-状态" class="headerlink" title="2. Promise 状态"></a>2. Promise 状态</h4></li><li><p>Promise 有 3 种状态：pending、fulfilled、rejected</p><ul><li><p>初始状态：pending</p></li><li><p>成功状态：fulfilled（实际打印会看到 resolved）</p></li><li><p>失败状态：rejected</p><p>如果你在 new Promise 中用了 resolve()，那么它就会走 .then()；</p><p>如果你用的是 reject()，那么它就走 .catch()。</p></li></ul></li><li><p>Promise 的状态一经改变就不能再进行更改。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;成功 1&#x27;</span>);</span><br><span class="line">  reject(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">  resolve(<span class="string">&#x27;成功 2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;res：&#x27;</span>, res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err：&#x27;</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出啥？=&gt; res： 成功 1</span></span><br></pre></td></tr></table></figure></li><li><p>Promise 也是不允许返回的：</p><p> 你将状态改为了 resolved，那么就不能再改了，只能.then()！</p></li></ol><h3 id="Promise也有一些缺点。"><a href="#Promise也有一些缺点。" class="headerlink" title="Promise也有一些缺点。"></a>Promise也有一些缺点。</h3><ol><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ol><p>如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。</p><h3 id="基本用法-API"><a href="#基本用法-API" class="headerlink" title="基本用法(API)"></a>基本用法(API)</h3><ol><li>Promise.resolve(value)<blockquote><p>类方法，该方法返回一个以 value 值解析后的 Promise 对象</p></blockquote></li></ol><ul><li>如果这个值是个 thenable（即带有 then 方法），返回的 Promise 对象会“跟随”这个 thenable 的对象，采用它的最终状态（指 resolved/rejected/pending/settled）</li><li>如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。</li><li>其他情况以该值为成功状态返回一个 Promise 对象。</li></ul><p>上面是 resolve 方法的解释，传入不同类型的 value 值，返回结果也有区别。</p><ol><li><p>如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="number">123</span>);</span><br><span class="line">    &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p0 = <span class="keyword">new</span> <span class="built_in">Promise</span>(fn);</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(p0);</span><br><span class="line"><span class="comment">// 返回为true，返回的 Promise 即是 入参的 Promise 对象。</span></span><br><span class="line"><span class="built_in">console</span>.log(p0 === p1);</span><br></pre></td></tr></table></figure><ol start="2"><li>传入 thenable 对象，返回 Promise 对象跟随 thenable 对象的最终状态。</li></ol><p>ES6 Promises 里提到了 Thenable 这个概念，简单来说它就是一个非常类似 Promise 的东西。最简单的例子就是 jQuery.ajax，它的返回值就是 thenable 对象。但是要谨记，并不是只要实现了 then 方法就一定能作为 Promise 对象来使用。</p><p>如果传入的 value 本身就是 thenable 对象，返回的 promise 对象会跟随 thenable 对象的状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">&#x27;/test/test.json&#x27;</span>));<span class="comment">// =&gt; promise对象</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>返回一个状态已变成 resolved 的 Promise 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">123</span>); </span><br><span class="line"><span class="comment">//打印p1 可以看到p1是一个状态置为resolved的Promise对象</span></span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br></pre></td></tr></table></figure><ol start="2"><li>Promise.reject</li></ol><p>类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。</p></li></ol><ol start="3"><li><p>Promise.prototype.then</p><p> 实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。</p></li><li><p>Promise.prototype.catch</p><p> 实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息。</p></li><li><p>Promise.prototype.finally()</p><p> finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。finally方法里面的操作，是与状态无关的，不依赖于 Promise 的执行结果。该方法是 ES2018 引入标准的。</p></li></ol><ol start="6"><li><p>Promise.race()</p><p> 类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败。<br> 。</p></li><li><p>Promise.all()</p><p> 类方法，多个 Promise 任务同时执行。<br> 如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。  如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p2])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;等到两个异步完成后，再执行&#x27;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>Promise.any()</p><p> ES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</p><p> Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。</p></li><li><p>Promise.allSettled()</p><p> Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 ES2020 引入。</p></li></ol><h2 id="Promise的一些应用"><a href="#Promise的一些应用" class="headerlink" title="Promise的一些应用"></a>Promise的一些应用</h2><ol><li><p>加载图片</p><p> 我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>用Promise对象实现的 Ajax 操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="built_in">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">&quot;/posts.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Contents: &#x27;</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="co-Generator-方式"><a href="#co-Generator-方式" class="headerlink" title="co + Generator 方式"></a>co + Generator 方式</h2><p>利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> r1 = <span class="keyword">yield</span> readFilePromise(<span class="string">&#x27;1.json&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> r2 = <span class="keyword">yield</span> readFilePromise(<span class="string">&#x27;2.json&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> r3 = <span class="keyword">yield</span> readFilePromise(<span class="string">&#x27;3.json&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> r4 = <span class="keyword">yield</span> readFilePromise(<span class="string">&#x27;4.json&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h2><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><blockquote><p>async 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用await 表明当前函数是异步函数 不会阻塞线程导致后续代码停止运行。</p></blockquote><p>async 函数的返回值很特殊: 不管在函数体内 return 了什么值, async 函数的实际返回值总是一个 Promise 对象. 详细讲就是:若在 async 函数中 return 了一个值 a, 不管 a 值是什么类型, async 函数的实际返回值总是 Promise.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve(a)<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(asyncFn())</span><br><span class="line"><span class="comment">//Promise &#123;&lt;resolved&gt;: &quot;hello world&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>如果函数内部抛出异常或者是返回reject，都会使函数的promise状态为失败reject。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;has Error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">asyncFn()</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// Error: has Error</span></span><br></pre></td></tr></table></figure><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>await意思是async wait(异步等待)。这个关键字只能在使用async定义的函数里面使用。任何async函数都会默认返回promise，并且这个promise解析的值都将会是这个函数的返回值，而async函数必须等到内部所有的 await 命令的 Promise 对象执行完，才会发生状态改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsonAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> axios.get(<span class="string">&#x27;api/user&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">getJsonAsync()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.data)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>笔试题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncfn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">await</span> asyncfn2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncfn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">asyncfn1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><ol><li>打印 “1” </li><li>遇到setTimeout,setTimeout是宏任务,将它放在宏任务队列中</li><li>执行 asyncfn1  打印 “2”遇到await关键字，先执行关键字后面的 asyncfn2函数 打印：”4”,因为await关键字将这块代码asyncContext挂起并执行上级 上下文 所以先打印了”5”,执行完后回到 async context 打印 “3” </li><li>最后打印 “setTimeout”</li></ol><p>加入Promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p>重点：</p><ol><li>执行到 await async2()，发现 async2 也是个 async 定义的函数，所以直接执行了“console.log(‘async2’)”，同时async2返回了一个Promise，划重点：此时返回的Promise会被放入到回调队列中等待，await会让出线程（js是单线程还用我介绍吗），接下来就会跳出 async1函数 继续往下执行。</li><li>然后执行到 new Promise，前面说过了promise是立即执行的，所以先打印出来“promise1”，然后执行到 resolve 的时候，resolve这个任务就被放到回调队列中等待，然后跳出Promise继续往下执行，输出“script end”。 </li><li>同步的事件都循环执行完了，调用栈现在已经空出来了，那么事件循环就会去回调队列里面取任务继续放到调用栈里面了。</li></ol><h3 id="async-await-能代替Promise吗"><a href="#async-await-能代替Promise吗" class="headerlink" title="async/await 能代替Promise吗"></a>async/await 能代替Promise吗</h3><p>使用Async / Await时，我们仍在使用Promise。从长远来看，对Promise的良好理解实际上对您有很大的好处。<br>甚至有一些用例Async / Await并不能解决问题，我们不得不回到Promise上<br>一个这样的场景</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903625609707534">面试精选之Promise</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise">ECMAScript 6 入门(阮一峰)</a></li><li><a href="https://blog.csdn.net/weixin_37719279/article/details/80950713">ES6之Promise常见面试题</a></li><li><a href="https://juejin.cn/post/6844903509934997511">Promise 必知必会（十道题）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;Promise-初探&quot;&gt;&lt;a href=&quot;#Promise-初探&quot; class=&quot;headerlink&quot; title=&quot;Promise 初探&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之EventLoop(事件循环)</title>
    <link href="http://github.com/2021/01/20/JS%E4%B9%8BEventLoop(%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF)/"/>
    <id>http://github.com/2021/01/20/JS%E4%B9%8BEventLoop(%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF)/</id>
    <published>2021-01-19T16:00:00.000Z</published>
    <updated>2021-01-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="一-浏览器中的Event-Loop"><a href="#一-浏览器中的Event-Loop" class="headerlink" title="一 浏览器中的Event Loop"></a>一 浏览器中的Event Loop</h2><blockquote><p>Event Loop 即事件循环，是指浏览器或 Node 的一种解决 JavaScript 单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。</p></blockquote><h3 id="单线程和多线程"><a href="#单线程和多线程" class="headerlink" title="单线程和多线程"></a>单线程和多线程</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>JavaScript 是一个单线程的语言。</p><p>单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。</p><p>以 Chrome 浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程。</p><p>一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。</p><p>当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p><h4 id="浏览器内核是怎样的？"><a href="#浏览器内核是怎样的？" class="headerlink" title="浏览器内核是怎样的？"></a>浏览器内核是怎样的？</h4><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用 CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p><p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p><ul><li>GUI 渲染线程：解析 HTML、CSS 等。在 JavaScript 引擎线程运行脚本期间，GUI 渲染线程处于挂起状态，也就是被 “冻结” 了。</li><li>JavaScript 引擎线程：负责处理 JavaScript 脚本。</li><li>定时触发器线程：setTimeout、setInterval 等。事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行。</li><li>事件触发线程：负责将准备好的事件交给 JS 引擎执行。</li><li>异步 http 请求线程：负责执行异步请求之类函数的线程，例如 Promise.then()、ajax 等。</li></ul><ol><li><p>GUI 渲染线程</p><p> 主要负责页面的渲染，解析 HTML、CSS，构建 DOM 树，布局和绘制等。<br> 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。<br> 该线程与 JS 引擎线程互斥，当执行 JS 引擎线程时，GUI 渲染会被挂起，当任务队列空闲时，JS 引擎才会去执行 GUI 渲染。</p></li><li><p>JS 引擎线程</p><p> 该线程当然是主要负责处理 JavaScript 脚本，执行代码。<br> 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS 引擎线程的执行。<br> 当然，该线程与 GUI 渲染线程互斥，当 JS 引擎线程执行 JavaScript 脚本时间过长，将导致页面渲染的阻塞。</p></li><li><p>定时器触发线程</p><p> 负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。<br> 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行。</p></li><li><p>事件触发线程</p><p> 主要负责将准备好的事件交给 JS 引擎线程执行。<br> 比如 setTimeout 定时器计数结束， ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS 引擎线程的执行。</p></li><li><p>异步 http 请求线程</p><p> 负责执行异步请求一类的函数的线程，如： Promise，axios，ajax 等。<br> 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待 JS 引擎线程执行。</p><h4 id="为什么不设计成多线程？"><a href="#为什么不设计成多线程？" class="headerlink" title="为什么不设计成多线程？"></a>为什么不设计成多线程？</h4><p>JS是可以去操作DOM的。</p></li></ol><p>假设有个 DOM 节点，现在有线程 A 操作它，删除了这个 DOM；<br>然后线程 B 又操作它，修改了这个 DOM 某部分。<br>这肯定不可以。（多线程可以互不干预的操作一段内存空间）<br>所以干脆设计成一个单线程，安全稳妥不出事。</p><p>哪怕后期 HTML5 出了个 Web Worker 也是不允许操作 DOM 结构的，可以完成一些分布式的计算。</p><p>对于dom结构我们必须顺序操纵，坚决不允许出现对同一个dom同时进行操作。</p><h4 id="为什么需要异步？"><a href="#为什么需要异步？" class="headerlink" title="为什么需要异步？"></a>为什么需要异步？</h4><p>这时候又有问题了，如果调用某个接口（Ajax），或者加载某张图片的时候，我们卡住了，这样页面是不是就一直不能渲染？</p><p>然后因为单线程只能先让前面的程序走完，即便这个接口或者图片缓过来了，我下面还有其他任务没做呢，这不就卡死了么？</p><p>所以这时候异步来了：</p><p>在涉及某些需要等待的操作的时候，我们就选择让程序继续运行。</p><p>等待接口或者图片返回过来后，就通知程序我做好了，你可以继续调用了。</p><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><h4 id="为什么会有-Event-Loop？"><a href="#为什么会有-Event-Loop？" class="headerlink" title="为什么会有 Event Loop？"></a>为什么会有 Event Loop？</h4><p>JavaScript 线程一次只能做一件事。<br>如果碰到一些需要等待的程序，例如 setTimeout 等，那就歇菜了。<br>所以，JavaScript 为了协调事件、用户交互、脚本、渲染、网络等，就搞出来一个 事件循环（Event Loop）。</p><h4 id="什么是-Event-Loop？"><a href="#什么是-Event-Loop？" class="headerlink" title="什么是 Event Loop？"></a>什么是 Event Loop？</h4><p>JavaScript 从 script 开始读取，然后不断循环，从 “<code>任务队列</code>” 中读取执行事件的过程，就是 事件循环（<code>Event Loop</code>）。</p><h4 id="Event-Loop-执行过程"><a href="#Event-Loop-执行过程" class="headerlink" title="Event Loop 执行过程"></a>Event Loop 执行过程</h4><p>Event Loop 执行过程如下：</p><ol><li>一开始整个脚本 script 作为一个宏任务执行</li><li>执行过程中，同步代码 直接执行，宏任务 进入宏任务队列，微任务 进入微任务队列。</li><li>当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完毕。</li><li>执行浏览器 UI 线程的渲染工作。</li><li>检查是否有 Web Worker 任务，有则执行。</li><li>执行完本轮的宏任务，回到步骤 2，依次循环，直到宏任务和微任务队列为空。</li></ol><p>事件循环中的异步队列有两种：宏任务队列（MacroTask）和 微任务队列（MicroTask）。</p><p>Web Worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。</p><h4 id="宏任务队列可以有多个，微任务队列只有一个。"><a href="#宏任务队列可以有多个，微任务队列只有一个。" class="headerlink" title="宏任务队列可以有多个，微任务队列只有一个。"></a>宏任务队列可以有多个，微任务队列只有一个。</h4><p>宏任务 包括：</p><ul><li>script</li><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I/O</li><li>UI rendering</li></ul><p>微任务 包括：</p><ul><li>MutationObserver(html5 新特性)</li><li>Promise.then()/catch()</li><li>以 Promise 为基础开发的其他技术，例如 fetch API</li><li>V8 的垃圾回收过程</li><li>Node 独有的 process.nextTick</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ol><li><p>案例一</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise1&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p> 最后输出结果是 Promise1，setTimeout1，Promise2，setTimeout2</p><p> 一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出 Promise1，同时会生成一个宏任务 setTimeout2<br> 然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1<br> 在执行宏任务 setTimeout1 时会生成微任务 Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2<br> 清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</p></li><li><p>案例二</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： script start</span></span><br><span class="line"><span class="comment">//       async2 end</span></span><br><span class="line"><span class="comment">//       Promise</span></span><br><span class="line"><span class="comment">///      script end</span></span><br><span class="line"><span class="comment">//       async1 end</span></span><br><span class="line"><span class="comment">//       promise1</span></span><br><span class="line"><span class="comment">//       promise2</span></span><br><span class="line"><span class="comment">//       setTimeout</span></span><br></pre></td></tr></table></figure></li></ol><p>这里需要先理解async/await。<br>async/await 在底层转换成了 promise 和 then 回调函数。<br>也就是说，这是 promise 的语法糖。<br>每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。<br>async/await 的实现，离不开 Promise。从字面意思来理解，async 是“异步”的简写，而 await 是 async wait 的简写可以认为是等待异步方法执行完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> p</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化理解为：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> RESOLVE(p).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="node中的event-loop"><a href="#node中的event-loop" class="headerlink" title="node中的event loop"></a>node中的event loop</h2><h3 id="三大关键阶段"><a href="#三大关键阶段" class="headerlink" title="三大关键阶段"></a>三大关键阶段</h3><p>首先，梳理一下 nodejs 三个非常重要的执行阶段:</p><ol><li>执行 定时器回调 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout、setInterval。这个阶段暂且叫它timer。</li></ol><ol start="2"><li><p>轮询(英文叫poll)阶段。因为在node代码中难免会有异步操作，比如文件I/O，网络I/O等等，那么当这些异步操作做完了，就会来通知JS主线程，怎么通知呢？就是通过’data’、’connect’等事件使得事件循环到达 poll 阶段。到达了这个阶段后:</p><p> 如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到timer阶段。</p><p> 如果没有定时器, 会去看回调函数队列。</p><p> 如果队列不为空，拿出队列中的方法依次执行</p><p> 如果队列为空，检查是否有 setImmdiate 的回调</p><p> 有则前往check阶段(下面会说)</p><p> 没有则继续等待，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后自动进入 check 阶段。</p></li><li><p>check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。</p></li></ol><p>这三个阶段为一个循环过程。不过现在的eventLoop并不完整，我们现在就来一一地完善。</p><h3 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h3><p>首先，当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 I/O异常的回调阶段。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。</p><p>并且在 check 阶段结束后还会进入到 关闭事件的回调阶段。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()，<br>‘close’ 事件的回调就会在这个阶段执行。</p><p>梳理一下，nodejs 的 eventLoop 分为下面的几个阶段:</p><ol><li>timer 阶段</li><li>I/O 异常回调阶段</li><li>空闲、预备状态(第2阶段结束，poll 未触发之前)</li><li>poll 阶段</li><li>check 阶段</li><li>关闭事件的回调阶段</li></ol><h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这里我要说，node版本 &gt;= 11和在 11 以下的会有不同的表现。<br>首先说 node 版本 &gt;= 11的，它会和浏览器表现一致，一个定时器运行完立即运行相应的微任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">time2</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure><p>而 node 版本小于 11 的情况下，对于定时器的处理是:</p><p>若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务。</p><p>因此会打印出这样的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure><h3 id="关于process-nextTick的一点说明"><a href="#关于process-nextTick的一点说明" class="headerlink" title="关于process.nextTick的一点说明"></a>关于process.nextTick的一点说明</h3><p>process.nextTick 是一个独立于 eventLoop 的任务队列。<br>在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。</p><h2 id="nodejs-和-浏览器关于eventLoop的主要区别"><a href="#nodejs-和-浏览器关于eventLoop的主要区别" class="headerlink" title="nodejs 和 浏览器关于eventLoop的主要区别"></a>nodejs 和 浏览器关于eventLoop的主要区别</h2><p>两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。</p><h3 id="为啥会有-浏览器-Event-Loop-和-Node-js-Event-Loop？"><a href="#为啥会有-浏览器-Event-Loop-和-Node-js-Event-Loop？" class="headerlink" title="为啥会有 浏览器 Event Loop 和 Node.js Event Loop？"></a>为啥会有 浏览器 Event Loop 和 Node.js Event Loop？</h3><p>简单来说：</p><p>你的页面放到了浏览器去展示，你的数据放到了后台处理（将 Node.js 看成 PHP、Java 等后端语言），这两者能没有区别么？！<br>再仔细一点：</p><ul><li>Node.js：Node.js 的 Event Loop 是基于 libuv。libuv 已经对 Node.js 的 Event Loop 作出了实现。</li><li>浏览器：浏览器的 Event Loop 是基于 HTML5 规范 的。而 HTML5 规范中只是定义了浏览器中的 Event Loop 的模型，具体实现留给了浏览器厂商。<blockquote><p>libuv 是一个多平台支持库，主要用于异步 I/O。它最初是为 Node.js 开发的，现在 Luvit、Julia、pyuv 和其他的框架也使用它。</p></blockquote></li></ul><h2 id="浏览器与Node执行顺序的对比"><a href="#浏览器与Node执行顺序的对比" class="headerlink" title="浏览器与Node执行顺序的对比"></a>浏览器与Node执行顺序的对比</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">浏览器输出：</span></span><br><span class="line"><span class="comment">time1</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">time2</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Node输出：</span></span><br><span class="line"><span class="comment">time1</span></span><br><span class="line"><span class="comment">time2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><ul><li><p>在这个例子中，Node的逻辑如下：</p><p>最初timer1和timer2就在timers阶段中。开始时首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；<br>至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2。</p><p>而浏览器则因为两个setTimeout作为两个MacroTask, 所以先输出timer1, promise1，再输出timer2，promise2。</p></li><li><p>为了证明我们的理论，把代码改成下面的样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Node输出：</span></span><br><span class="line"><span class="comment">timer1               timer2</span></span><br><span class="line"><span class="comment">promise1    或者     promise2</span></span><br><span class="line"><span class="comment">timer2               timer1</span></span><br><span class="line"><span class="comment">promise2             promise1</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></li></ul><p>按理说setTimeout(fn,0)应该比setImmediate(fn)快，应该只有第二种结果，为什么会出现两种结果呢？<br>这是因为Node 做不到0毫秒，最少也需要1毫秒。实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。</p><p>另外，如果已经过了Timer阶段，那么setImmediate会比setTimeout更快，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;test.js&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line">  setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，setImmediate才会早于setTimeout执行。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000013861128">一篇文章教会你Event loop——浏览器和Node</a></li><li><a href="https://juejin.cn/post/6844904004007247880#heading-10">原生JS灵魂之问(下)</a></li><li><a href="https://zhuanlan.zhihu.com/p/54882306">浏览器与Node的事件循环(Event Loop)有何区别?</a></li><li><a href="https://juejin.cn/post/6844903764202094606#heading-0">一次弄懂Event Loop（彻底解决此类面试问题）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;一-浏览器中的Event-Loop&quot;&gt;&lt;a href=&quot;#一-浏览器中的Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;一 
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之作用域和执行上下文篇</title>
    <link href="http://github.com/2021/01/15/JS%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AF%87/"/>
    <id>http://github.com/2021/01/15/JS%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AF%87/</id>
    <published>2021-01-14T16:00:00.000Z</published>
    <updated>2021-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h3 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>1.概念</p><ul><li><p>作用域是指程序源代码中定义变量的区域。</p><p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p></li><li><p>静态作用域与动态作用域区别</p><p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p><p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p></li></ul><ol start="2"><li>案例理解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value &#x3D; 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结果是 1</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>静态作用域分析</p><p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p></li><li><p>动态作用域分析</p><p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p></li></ul><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><blockquote><p>JavaScript引擎并非一行一行地分析和执行程序，而是一段一段地分析，顺序执行。</p></blockquote><ul><li><p>概念</p><p>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p></li><li><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul></li><li><p>可执行代码</p><ul><li><p>js的可执行代码(executable code)的类型：全局代码、函数代码、eval代码。</p></li><li><p>举个例子</p><p>当javaScript引擎执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution contexts)”</p></li></ul></li><li><p>JavaScript 中有 3 种执行上下文类型：</p><ol><li>全局执行上下文：这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li>函数执行上下文：每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤。</li><li>Eval 函数执行上下文：执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。</li></ol></li></ul><h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>执行栈，也就是在其它编程语言中所说的 “调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。</p><p>当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p><p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><h4 id="模拟理解"><a href="#模拟理解" class="headerlink" title="模拟理解"></a>模拟理解</h4><p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [];</span><br></pre></td></tr></table></figure><p>  试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>JavaScript 遇到下面的这段代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fun3() &#123;</span><br><span class="line">    console.log(&#39;fun3&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun2() &#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure><p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 伪代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun1()</span><br><span class="line">ECStack.push(&lt;fun1&gt; functionContext);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun1中竟然调用了fun2，还要创建fun2的执行上下文</span><br><span class="line">ECStack.push(&lt;fun2&gt; functionContext);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 擦，fun2还调用了fun3！</span><br><span class="line">ECStack.push(&lt;fun3&gt; functionContext);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun3执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun2执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun1执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span><br></pre></td></tr></table></figure><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><blockquote><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p></blockquote><p>因为不同执行上下文下的变量对象稍有不同，所以有全局上下文下的变量对象和函数上下文下的变量对象。</p><p>全局上下文中的变量对象就是全局对象</p><h4 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h4><ul><li><p>概念</p><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p><p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p></li><li><p>执行过程</p><ul><li>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做： 1.进入执行上下文   2.代码执行</li></ul></li><li><p>进入执行上下文</p><p>  当进入执行上下文时，这时候还没有执行代码，</p><p>变量对象会包括：</p><ol><li><p>函数的所有形参 (如果是函数上下文)</p><p> 由名称和对应值组成的一个变量对象的属性被创建<br> 没有实参，属性值设为 undefined</p></li><li><p>函数声明</p><p> 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建<br> 如果变量对象已经存在相同名称的属性，则完全替换这个属性</p></li><li><p>变量声明</p><p> 由名称和对应值（undefined）组成一个变量对象的属性被创建；<br> 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</p></li></ol></li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  var b &#x3D; 2;</span><br><span class="line">  function c() &#123;&#125;</span><br><span class="line">  var d &#x3D; function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b &#x3D; 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(1);</span><br></pre></td></tr></table></figure><p>在进入执行上下文后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: undefined,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行<br>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p><p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 3,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p><p>全局上下文的变量对象初始化是全局对象</p><p>函数上下文的变量对象初始化只包括 Arguments 对象</p><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p><p>在代码执行阶段，会再次修改变量对象的属性值</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><blockquote><p>本文参考网站：</p></blockquote><ul><li><a href="https://juejin.cn/post/6844903479429824526">JavaScript深入系列15篇</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h3 id=&quot;词法作用域和动态作用域&quot;&gt;&lt;a href=&quot;#词法作用域和动态作用域&quot; class=&quot;headerlink&quot; title=&quot;词法作用域和动态作用域&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之闭包篇</title>
    <link href="http://github.com/2021/01/15/JS%E4%B9%8B%E9%97%AD%E5%8C%85%E7%AF%87/"/>
    <id>http://github.com/2021/01/15/JS%E4%B9%8B%E9%97%AD%E5%8C%85%E7%AF%87/</id>
    <published>2021-01-14T16:00:00.000Z</published>
    <updated>2021-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结(copy)，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h3 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h3><h4 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h4><blockquote><p>红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，</p></blockquote><blockquote><p>MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。<br>（其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）</p></blockquote><p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量。</p><p>当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。</p><p>简单来说：</p><p>在函数 A 中还有函数 B，函数 B 调用了函数 A 中的变量，那么函数 B 就称为函数 A 的闭包。</p><h4 id="闭包产生的原因"><a href="#闭包产生的原因" class="headerlink" title="闭包产生的原因?"></a>闭包产生的原因?</h4><ul><li>首先要明白作用域链的概念，其实很简单，在ES5中只存在两种作用域————全局作用域和函数作用域，</li><li>当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，</li><li>值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。</li></ul><p>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">function f1() &#123;</span><br><span class="line">  var a &#x3D; 2</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    var a &#x3D; 3;</span><br><span class="line">    console.log(a);&#x2F;&#x2F;3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，f1的作用域指向有全局作用域(window)和它本身，而f2的作用域指向全局作用域(window)、f1和它本身。而且作用域是从最底层向上找，直到找到全局作用域window为止，如果全局还没有的话就会报错。</p><h4 id="闭包产生的本质"><a href="#闭包产生的本质" class="headerlink" title="闭包产生的本质"></a>闭包产生的本质</h4><p>闭包产生的本质就是，当前环境中存在指向父级作用域的引用。</p><p>还是举上面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var a &#x3D; 2</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    console.log(a);&#x2F;&#x2F;2</span><br><span class="line">  &#125;</span><br><span class="line">  return f2;</span><br><span class="line">&#125;</span><br><span class="line">var x &#x3D; f1();</span><br><span class="line">x();</span><br></pre></td></tr></table></figure><p>这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。<br>那是不是只有返回函数才算是产生了闭包呢？、<br>回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f3;</span><br><span class="line">function f1() &#123;</span><br><span class="line">  var a &#x3D; 2</span><br><span class="line">  f3 &#x3D; function() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line">f3();</span><br></pre></td></tr></table></figure><p>让f1执行，给f3赋值后，等于说现在f3拥有了window、f1和f3本身这几个作用域的访问权限，还是自底向上查找，最近是在f1中找到了a,因此输出2。<br>在这里是外面的变量f3存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变。</p><h3 id="闭包好处和坏处"><a href="#闭包好处和坏处" class="headerlink" title="闭包好处和坏处"></a>闭包好处和坏处</h3><ul><li><p>好处：</p><p>  缓存。将变量隐藏起来不被 GC 回收。<br>  实现柯里化。利用闭包特性完成柯里化。</p></li><li><p>坏处：</p><p>  内存消耗。闭包产生的变量无法被销毁。<br>  性能问题。由于闭包内部变量优先级高于外部变量，所以需要多查找作用域链的一个层次，一定程度影响查找速度。</p><h3 id="闭包有哪些表现形式"><a href="#闭包有哪些表现形式" class="headerlink" title="闭包有哪些表现形式?"></a>闭包有哪些表现形式?</h3><p>哪些地方能体现闭包的存在？</p></li><li><p>返回一个函数。<br>刚刚已经举例。<br>作为函数参数传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">function foo()&#123;</span><br><span class="line">  var a &#x3D; 2;</span><br><span class="line">  function baz()&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(baz);</span><br><span class="line">&#125;</span><br><span class="line">function bar(fn)&#123;</span><br><span class="line">  &#x2F;&#x2F; 这就是闭包</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出2，而不是1</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></li><li><p>在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。</p><p>以下的闭包保存的仅仅是window和当前作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定时器</span><br><span class="line">setTimeout(function timeHandler()&#123;</span><br><span class="line">  console.log(&#39;111&#39;);</span><br><span class="line">&#125;，100)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 事件监听</span><br><span class="line">$(&#39;#app&#39;).click(function()&#123;</span><br><span class="line">  console.log(&#39;DOM Listener&#39;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2;</span><br><span class="line">(function IIFE()&#123;</span><br><span class="line">  &#x2F;&#x2F; 输出2</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ul><p>如何解决下面的循环输出问题？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 1; i &lt;&#x3D; 5; i ++)&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>为什么会全部输出6？如何改进，让它输出1，2，3，4，5？(方法越多越好)</p><p>因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。</p></li><li><p>解决方法：</p><p>1、利用IIFE(立即执行函数表达式)当每次for循环时，把此时的i变量传递到定时器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 1;i &lt;&#x3D; 5;i++)&#123;</span><br><span class="line">  (function(j)&#123;</span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line">      console.log(j)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、给定时器传入第三个参数, 作为timer函数的第一个函数参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i&#x3D;1;i&lt;&#x3D;5;i++)&#123;</span><br><span class="line">  setTimeout(function timer(j)&#123;</span><br><span class="line">    console.log(j)</span><br><span class="line">  &#125;, 0, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用ES6中的let</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i &#x3D; 1; i &lt;&#x3D; 5; i++)&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let使JS发生革命性的变化，让JS有函数作用域变为了块级作用域，用let后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; i &#x3D; 1</span><br><span class="line">&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; i &#x3D; 2</span><br><span class="line">&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; i &#x3D; 3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因此能输出正确的结果。</p></li></ul><blockquote><p>本文参考(copy)网站：</p></blockquote><ul><li><p><a href="https://juejin.cn/post/6844903974378668039">J原生JS灵魂之问</a></p></li><li><p><a href="https://juejin.cn/post/6844903769646317576#heading-1">发现 JavaScript 中闭包的强大威力</a></p></li><li><p><a href="http://blog.leapoahead.com/2015/09/15/js-closure/">JavaScript闭包的底层运行机制</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结(copy)，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h3 id=&quot;闭包的理解&quot;&gt;&lt;a href=&quot;#闭包的理解&quot; class=&quot;headerlink&quot; title=&quot;闭包的理解&quot;&gt;&lt;/a&gt;闭包的理解&lt;/h3
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之类型篇</title>
    <link href="http://github.com/2021/01/15/JS%E4%B9%8B%E7%B1%BB%E5%9E%8B%E7%AF%87/"/>
    <id>http://github.com/2021/01/15/JS%E4%B9%8B%E7%B1%BB%E5%9E%8B%E7%AF%87/</id>
    <published>2021-01-14T16:00:00.000Z</published>
    <updated>2021-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="JS数据类型基础概念"><a href="#JS数据类型基础概念" class="headerlink" title="JS数据类型基础概念"></a>JS数据类型基础概念</h2><h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><p>JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：</p><h3 id="JS原始数据类型和引用数据类型"><a href="#JS原始数据类型和引用数据类型" class="headerlink" title="JS原始数据类型和引用数据类型"></a>JS原始数据类型和引用数据类型</h3><ol><li>7种JS原始数据类型</li></ol><ul><li>boolean</li><li>null</li><li>undefined</li><li>number</li><li>string</li><li>symbol</li><li>bigint</li></ul><ol start="2"><li>引用数据类型:</li></ol><ul><li>对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）</li></ul><h4 id="说出下面运行的结果，解释原因。"><a href="#说出下面运行的结果，解释原因。" class="headerlink" title="说出下面运行的结果，解释原因。"></a>说出下面运行的结果，解释原因。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function test(person) &#123;</span><br><span class="line">  person.age &#x3D; 26</span><br><span class="line">  person &#x3D; &#123;</span><br><span class="line">    name: &#39;hzj&#39;,</span><br><span class="line">    age: 18</span><br><span class="line">  &#125;</span><br><span class="line">  return person</span><br><span class="line">&#125;</span><br><span class="line">const p1 &#x3D; &#123;</span><br><span class="line">  name: &#39;fyq&#39;,</span><br><span class="line">  age: 19</span><br><span class="line">&#125;</span><br><span class="line">const p2 &#x3D; test(p1)</span><br><span class="line">console.log(p1) &#x2F;&#x2F; -&gt; ?</span><br><span class="line">console.log(p2) &#x2F;&#x2F; -&gt; ?</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结果:</span><br><span class="line">p1：&#123;name: “fyq”, age: 26&#125;</span><br><span class="line">p2：&#123;name: “hzj”, age: 18&#125;</span><br></pre></td></tr></table></figure><p>原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用person.age = 26确实改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。</p><h4 id="typeof-null-输出-object问题？"><a href="#typeof-null-输出-object问题？" class="headerlink" title="typeof null 输出 object问题？"></a>typeof null 输出 object问题？</h4><p>结论: 。<br>解释: 首先null不是对象，typeof null 会输出 object，这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。</p><h4 id="‘1’-toString-为什么可以调用？"><a href="#‘1’-toString-为什么可以调用？" class="headerlink" title="‘1’.toString()为什么可以调用？"></a>‘1’.toString()为什么可以调用？</h4><p>其实在这个语句运行的过程中做了这样几件事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; new Object(&#39;1&#39;);</span><br><span class="line">s.toString();</span><br><span class="line">s &#x3D; null;</span><br></pre></td></tr></table></figure><ol><li>第一步: 创建Object类实例。注意为什么不是String ？ 由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。</li><li>第二步: 调用实例方法。</li><li>第三步: 执行完方法立即销毁这个实例。<br>整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean, Number和String。</li></ol><blockquote><p>参考:《JavaScript高级程序设计(第三版)》P118</p></blockquote><h4 id="0-1-0-2为什么不等于0-3？"><a href="#0-1-0-2为什么不等于0-3？" class="headerlink" title="0.1+0.2为什么不等于0.3？"></a>0.1+0.2为什么不等于0.3？</h4><p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p><h3 id="如何理解BigInt"><a href="#如何理解BigInt" class="headerlink" title="如何理解BigInt?"></a>如何理解BigInt?</h3><h4 id="什么是BigInt"><a href="#什么是BigInt" class="headerlink" title="什么是BigInt?"></a>什么是BigInt?</h4><p>BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。</p><h4 id="为什么需要BigInt"><a href="#为什么需要BigInt" class="headerlink" title="为什么需要BigInt?"></a>为什么需要BigInt?</h4><p>在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？</p><p>这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(999999999999999);</span><br><span class="line">&#x2F;&#x2F; 输出10000000000000000</span><br></pre></td></tr></table></figure><p>同时也会有一定的安全性问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9007199254740992 &#x3D;&#x3D;&#x3D; 9007199254740993;    &#x2F;&#x2F; → true 居然是true!</span><br></pre></td></tr></table></figure><h4 id="如何创建并使用BigInt？"><a href="#如何创建并使用BigInt？" class="headerlink" title="如何创建并使用BigInt？"></a>如何创建并使用BigInt？</h4><p>要创建BigInt，只需要在数字末尾追加n即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log( 9007199254740995n );    &#x2F;&#x2F; → 9007199254740995n    </span><br><span class="line">console.log( 9007199254740995 );     &#x2F;&#x2F; → 9007199254740996</span><br></pre></td></tr></table></figure><p>另一种创建BigInt的方法是用BigInt()构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInt(&quot;9007199254740995&quot;);    &#x2F;&#x2F; → 9007199254740995n</span><br></pre></td></tr></table></figure><p>简单使用如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">10n + 20n;    &#x2F;&#x2F; → 30n    </span><br><span class="line">10n - 20n;    &#x2F;&#x2F; → -10n    </span><br><span class="line">+10n;         &#x2F;&#x2F; → TypeError: Cannot convert a BigInt value to a number    </span><br><span class="line">-10n;         &#x2F;&#x2F; → -10n    </span><br><span class="line">10n * 20n;    &#x2F;&#x2F; → 200n    </span><br><span class="line">20n &#x2F; 10n;    &#x2F;&#x2F; → 2n    </span><br><span class="line">23n % 10n;    &#x2F;&#x2F; → 3n    </span><br><span class="line">10n ** 3n;    &#x2F;&#x2F; → 1000n    </span><br><span class="line"></span><br><span class="line">const x &#x3D; 10n;    </span><br><span class="line">++x;          &#x2F;&#x2F; → 11n    </span><br><span class="line">--x;          &#x2F;&#x2F; → 9n</span><br><span class="line">console.log(typeof x);   &#x2F;&#x2F;&quot;bigint&quot;</span><br></pre></td></tr></table></figure><p>值得警惕的点</p><ul><li>BigInt不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js代码。</li></ul><ul><li><p>因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 + 10n;    &#x2F;&#x2F; → TypeError</span><br></pre></td></tr></table></figure></li><li><p>不能将BigInt传递给Web api和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(2n, 4n, 6n);    &#x2F;&#x2F; → TypeError</span><br></pre></td></tr></table></figure></li><li><p>当 Boolean 类型与 BigInt 类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(0n)&#123;&#x2F;&#x2F;条件判断为false</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if(3n)&#123;&#x2F;&#x2F;条件为true</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>元素都为BigInt的数组可以进行sort。</p></li></ul><p>  BigInt可以正常地进行位运算，如|、&amp;、&lt;&lt;、&gt;&gt;和^</p><p>浏览器兼容性</p><ul><li>其实现在的兼容性并不怎么好，只有chrome67、firefox、Opera这些主流实现</li></ul><h3 id="JS数据类型检测"><a href="#JS数据类型检测" class="headerlink" title="JS数据类型检测"></a>JS数据类型检测</h3><ol><li>typeof 是否能正确判断类型？<br>对于原始类型来说，除了 null 都可以调用typeof显示正确的类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 &#x2F;&#x2F; &#39;number&#39;</span><br><span class="line">typeof &#39;1&#39; &#x2F;&#x2F; &#39;string&#39;</span><br><span class="line">typeof undefined &#x2F;&#x2F; &#39;undefined&#39;</span><br><span class="line">typeof true &#x2F;&#x2F; &#39;boolean&#39;</span><br><span class="line">typeof Symbol() &#x2F;&#x2F; &#39;symbol&#39;</span><br></pre></td></tr></table></figure>但对于引用数据类型，除了函数之外，都会显示”object”。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof [] &#x2F;&#x2F; &#39;object&#39;</span><br><span class="line">typeof &#123;&#125; &#x2F;&#x2F; &#39;object&#39;</span><br><span class="line">typeof console.log &#x2F;&#x2F; &#39;function&#39;</span><br></pre></td></tr></table></figure>因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const Person &#x3D; function() &#123;&#125;</span><br><span class="line">const p1 &#x3D; new Person()</span><br><span class="line">p1 instanceof Person &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">var str1 &#x3D; &#39;hello world&#39;</span><br><span class="line">str1 instanceof String &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">var str2 &#x3D; new String(&#39;hello world&#39;)</span><br><span class="line">str2 instanceof String &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li><li>instanceof能否判断基本数据类型？<br>能。比如下面这种方式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class PrimitiveNumber &#123;</span><br><span class="line">  static [Symbol.hasInstance](x) &#123;</span><br><span class="line">    return typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(111 instanceof PrimitiveNumber) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>如果你不知道Symbol，可以看看MDN上关于hasInstance的解释。<br>其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。</li><li>能不能手动实现一下instanceof的功能？<br>核心: 原型链的向上查找。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">    &#x2F;&#x2F;基本数据类型直接返回false</span><br><span class="line">    if(typeof left !&#x3D;&#x3D; &#39;object&#39; || left &#x3D;&#x3D;&#x3D; null) return false;</span><br><span class="line">    &#x2F;&#x2F;getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象</span><br><span class="line">    let proto &#x3D; Object.getPrototypeOf(left);</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        &#x2F;&#x2F;查找到尽头，还没找到</span><br><span class="line">        if(proto &#x3D;&#x3D; null) return false;</span><br><span class="line">        &#x2F;&#x2F;找到相同的原型对象</span><br><span class="line">        if(proto &#x3D;&#x3D; right.prototype) return true;</span><br><span class="line">        proto &#x3D; Object.getPrototypeOf(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>测试:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(myInstanceof(&quot;111&quot;, String)); &#x2F;&#x2F;false</span><br><span class="line">console.log(myInstanceof(new String(&quot;111&quot;), String));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure></li><li>constructor检测类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 123;</span><br><span class="line">var str &#x3D; &#39;abcdef&#39;;</span><br><span class="line">var bool &#x3D; true;</span><br><span class="line">var arr &#x3D; [1, 2, 3, 4];</span><br><span class="line">var json &#x3D; &#123; name: &#39;jsliang&#39;, age: 25 &#125;;</span><br><span class="line">var func &#x3D; function () &#123; console.log(&#39;this is function&#39;); &#125;</span><br><span class="line">var und &#x3D; undefined;</span><br><span class="line">var nul &#x3D; null;</span><br><span class="line">var date &#x3D; new Date();</span><br><span class="line">var reg &#x3D; &#x2F;^[a-zA-Z]&#123;5,20&#125;$&#x2F;;</span><br><span class="line">var error &#x3D; new Error();</span><br><span class="line"></span><br><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var Tom &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  Tom.constructor &#x3D;&#x3D;&#x3D; Person,</span><br><span class="line">  num.constructor &#x3D;&#x3D;&#x3D; Number,</span><br><span class="line">  str.constructor &#x3D;&#x3D;&#x3D; String,</span><br><span class="line">  bool.constructor &#x3D;&#x3D;&#x3D; Boolean,</span><br><span class="line">  arr.constructor &#x3D;&#x3D;&#x3D; Array,</span><br><span class="line">  json.constructor &#x3D;&#x3D;&#x3D; Object,</span><br><span class="line">  func.constructor &#x3D;&#x3D;&#x3D; Function,</span><br><span class="line">  date.constructor &#x3D;&#x3D;&#x3D; Date,</span><br><span class="line">  reg.constructor &#x3D;&#x3D;&#x3D; RegExp,</span><br><span class="line">  error.constructor &#x3D;&#x3D;&#x3D; Error</span><br><span class="line">);</span><br></pre></td></tr></table></figure>得到的所有结果都是 true，除了 undefined 和 null，其他类型基本可以通过 constructor 判断。</li></ol><p>不过因为 constructor 的属性是可以被修改的，可能导致检测出的结果不正确。</p><ol start="5"><li><p>Array.prototype.toString.call检测类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 123;</span><br><span class="line">var str &#x3D; &#39;abcdef&#39;;</span><br><span class="line">var bool &#x3D; true;</span><br><span class="line">var arr &#x3D; [1, 2, 3, 4];</span><br><span class="line">var json &#x3D; &#123; name: &#39;jsliang&#39;, age: 25 &#125;;</span><br><span class="line">var func &#x3D; function () &#123; console.log(&#39;this is function&#39;); &#125;</span><br><span class="line">var und &#x3D; undefined;</span><br><span class="line">var nul &#x3D; null;</span><br><span class="line">var date &#x3D; new Date();</span><br><span class="line">var reg &#x3D; &#x2F;^[a-zA-Z]&#123;5,20&#125;$&#x2F;;</span><br><span class="line">var error &#x3D; new Error();</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  Object.prototype.toString.call(num), &#x2F;&#x2F; [object Number]</span><br><span class="line">  Object.prototype.toString.call(str), &#x2F;&#x2F; [object String]</span><br><span class="line">  Object.prototype.toString.call(bool), &#x2F;&#x2F; [object Boolean]</span><br><span class="line">  Object.prototype.toString.call(arr), &#x2F;&#x2F; [object Array]</span><br><span class="line">  Object.prototype.toString.call(json), &#x2F;&#x2F; [object Object]</span><br><span class="line">  Object.prototype.toString.call(func), &#x2F;&#x2F; [object Function]</span><br><span class="line">  Object.prototype.toString.call(und), &#x2F;&#x2F; [object Undefined]</span><br><span class="line">  Object.prototype.toString.call(nul), &#x2F;&#x2F; [object Null]</span><br><span class="line">  Object.prototype.toString.call(date), &#x2F;&#x2F; [object Date]</span><br><span class="line">  Object.prototype.toString.call(reg), &#x2F;&#x2F; [object RegExp]</span><br><span class="line">  Object.prototype.toString.call(error), &#x2F;&#x2F; [object Error]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一个完美的判断方法，可以检测上面提到的所有类型，只需要将它的结果 result.slice(8, -1) 就能得到具体的类型。</p></li><li><p>Object.is和===的区别？<br>Object在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。<br>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function is(x, y) &#123;</span><br><span class="line">  if (x &#x3D;&#x3D;&#x3D; y) &#123;</span><br><span class="line">    &#x2F;&#x2F;运行到1&#x2F;x &#x3D;&#x3D;&#x3D; 1&#x2F;y的时候x和y都为0，但是1&#x2F;+0 &#x3D; +Infinity， 1&#x2F;-0 &#x3D; -Infinity, 是不一样的</span><br><span class="line">    return x !&#x3D;&#x3D; 0 || y !&#x3D;&#x3D; 0 || 1 &#x2F; x &#x3D;&#x3D;&#x3D; 1 &#x2F; y;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;NaN&#x3D;&#x3D;&#x3D;NaN是false,这是不对的，我们在这里做一个拦截，x !&#x3D;&#x3D; x，那么一定是 NaN, y 同理</span><br><span class="line">    &#x2F;&#x2F;两个都是NaN的时候返回true</span><br><span class="line">    return x !&#x3D;&#x3D; x &amp;&amp; y !&#x3D;&#x3D; y;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="JS数据类型转换"><a href="#JS数据类型转换" class="headerlink" title="JS数据类型转换"></a>JS数据类型转换</h3></li><li><p>[] == ![]结果是什么？为什么？<br>解析:<br>== 中，左右两边都需要转换为数字然后进行比较。<br>[]转换为数字为0。<br>![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true,<br>因此![]为false，进而在转换成数字，变为0。<br>0 == 0 ， 结果为true</p></li><li><p>JS中类型转换有哪几种？<br>JS中，类型转换只有三种：</p></li></ol><p>转换成数字<br>转换成布尔值<br>转换成字符串</p><p>转换具体规则如下:</p><p>注意”Boolean 转字符串”这行结果指的是 true 转字符串的例子</p><ol start="3"><li>== 和 ===有什么区别？<br>===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如’1’===1的结果是false，因为一边是string，另一边是number。<br>复制代码<br>==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下：</li></ol><p>两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false<br>判断的是否是null和undefined，是的话就返回true<br>判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较<br>判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较<br>如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#123;a: 1&#125; &#x3D;&#x3D; true);&#x2F;&#x2F;false</span><br><span class="line">console.log(&#123;a: 1&#125; &#x3D;&#x3D; &quot;[object Object]&quot;);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><ol start="4"><li>对象转原始类型是根据什么流程运行的？<br>对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</li></ol><p>如果Symbol.toPrimitive()方法，优先调用再返回<br>调用valueOf()，如果转换为原始类型，则返回<br>调用toString()，如果转换为原始类型，则返回<br>如果都没有返回原始类型，会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  value: 3,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return 4;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;5&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line">    return 6</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj + 1); &#x2F;&#x2F; 输出7</span><br></pre></td></tr></table></figure><ol start="5"><li>如何让if(a == 1 &amp;&amp; a == 2)条件成立？<br>13 使 a == 1 &amp;&amp; a == 2 成立</li></ol><ul><li><p>方法一</p><p>在类型转换的时候，我们知道了对象如何转换成原始数据类型。如果部署了 [Symbol.toPrimitive]，那么返回的就是 Symbol.toPrimitive 的返回值。</p><p>当然，我们也可以把此函数部署在 valueOf 或者是 toString 接口上，效果相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;利用闭包延长作用域的特性</span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">  [Symbol.toPrimitive]: (function () &#123;</span><br><span class="line">    let i &#x3D; 1;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      return i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二</p><p>利用 Object.defineProperty 在 window/global 上定义 a 属性，获取 a 属性时，会调用 get</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let val &#x3D; 1;</span><br><span class="line">Object.defineProperty(window, &#39;a&#39;, &#123;</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    return val++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>方法三</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3];</span><br><span class="line">a.join &#x3D; a.shift;</span><br></pre></td></tr></table></figure><p>数组的 toString 方法返回一个字符串，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</p><p>因此，我们可以重新 join 方法。返回第一个元素，并将其删除。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;JS数据类型基础概念&quot;&gt;&lt;a href=&quot;#JS数据类型基础概念&quot; class=&quot;headerlink&quot; title=&quot;JS数据类型基础概念&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之类型篇</title>
    <link href="http://github.com/2021/01/15/JS%E4%B9%8Bthis%E7%AF%87/"/>
    <id>http://github.com/2021/01/15/JS%E4%B9%8Bthis%E7%AF%87/</id>
    <published>2021-01-14T16:00:00.000Z</published>
    <updated>2021-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="this问题"><a href="#this问题" class="headerlink" title="this问题"></a>this问题</h2><p>先记住 1 句话：</p><ul><li><strong><code>this</code> 永远指向最后调用它的那个对象</strong></li></ul><p>再牢记 2 句话：</p><ul><li>普通函数中 <code>this</code> 的指向，是 <code>this</code> <strong>执行时</strong>的上下文</li><li>箭头函数中 <code>this</code> 的指向，是 <code>this</code> <strong>定义时</strong>的上下文</li></ul><p>作用域链和 <code>this</code> 是两套不同的系统，它们之间基本没太多联系。</p><p><code>this</code> 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 <code>this</code>。</p><p>执行上下文分为 3 种：</p><ul><li>全局执行上下文</li><li>函数执行上下文</li><li><code>eval</code> 执行上下文</li></ul><blockquote><p>注意这里是浏览器中的 <code>this</code>，和 Node 中的 <code>this</code> 是不一样的。</p></blockquote><h2 id="三-全局执行上下文中的-this"><a href="#三-全局执行上下文中的-this" class="headerlink" title="三 全局执行上下文中的 this"></a><a name="chapter-three" id="chapter-three"></a>三 全局执行上下文中的 this</h2><p>在 Chrome 控制台中输入：<code>this</code>，你会看到答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Window &#123;<span class="attr">postMessage</span>: ƒ, <span class="attr">blur</span>: ƒ, <span class="attr">focus</span>: ƒ, <span class="attr">close</span>: ƒ, <span class="attr">parent</span>: Window, …&#125;</span><br></pre></td></tr></table></figure><p>全局执行上下文中的 <code>this</code> 是指向 <code>Window</code> 的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>这段代码也是输出 <code>Window</code>，为什么？</p><p>记住 <code>this</code> 就是谁调用它就指向谁。</p><p>我们在全局对象中调用 <code>foo</code>，实际上就相当于 <code>window.foo()</code> 的一个调用，那么就是指向 <code>Window</code>。</p><blockquote><p>在执行上面代码之后，其实小伙伴可以在 Chrome 的控制台输入 <code>window</code>，会看到里面存在 <code>foo()</code> 方法。</p></blockquote><blockquote><p>注意这里是非严格模式。严格模式下的全局对象是 <code>undefined</code>，那就会报错误 <code>Uncaught TypeError: Cannot read property &#39;name&#39; of undefined</code></p></blockquote><h2 id="四-函数执行上下文中的-this"><a href="#四-函数执行上下文中的-this" class="headerlink" title="四 函数执行上下文中的 this"></a><a name="chapter-four" id="chapter-four"></a>四 函数执行上下文中的 this</h2><p>在上面我们知道，一般的调用方法，是调用 <code>window</code> 上的方法。</p><p>那怎么获取当前函数的 <code>this</code> 呢？</p><h3 id="4-1-通过-call-bind-apply-改变-this"><a href="#4-1-通过-call-bind-apply-改变-this" class="headerlink" title="4.1 通过 call/bind/apply 改变 this"></a><a name="chapter-four-one" id="chapter-four-one"></a>4.1 通过 call/bind/apply 改变 this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.myName = <span class="string">&#x27;jsliang&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.myName = <span class="string">&#x27;zhazhaliang&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.myName); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>这时候的 <code>this</code> 指向 <code>window</code>，所以输出结果为；</p><ul><li>zhazhaliang</li><li>undefined</li></ul><p>通过 <code>call</code> 绑定后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.myName = <span class="string">&#x27;jsliang&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.myName = <span class="string">&#x27;zhazhaliang&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo.call(foo);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.myName); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><ul><li>jsliang</li><li>zhazhaliang</li></ul><p>当然你也可以换成 <code>apply</code> 和 <code>bind</code>，这里不做累述。</p><h3 id="4-2-通过对象调用方法设置"><a href="#4-2-通过对象调用方法设置" class="headerlink" title="4.2 通过对象调用方法设置"></a><a name="chapter-four-two" id="chapter-four-two"></a>4.2 通过对象调用方法设置</h3><p>使用对象来调用其内部的一个方法，该方法的 <code>this</code> 是指向对象本身的。</p><ul><li><strong>案例 1</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis(); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>答案：输出 <code>jsliang</code>。</p><p>我们要时刻牢记：<strong>谁调用的指向谁</strong>。这里是通过 <code>myObj</code> 进行的一个调用，所以此刻的 <code>this</code> 指向 <code>myObj</code>。而 <code>myObj</code> 里面存有 <code>name: jsliang</code>，所以输出 <code>jsliang</code>。</p><p>当然，我们要有自知之明：</p><ul><li><strong>案例 2</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> foo = myObj.showThis;</span><br><span class="line">foo(); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>这时候它又变成 <code>window</code> 指向了，此刻 <code>let foo = myObj.showThis</code> 只是一个定义，真正执行是在 <code>foo()</code>。那么此刻 <code>foo()</code> 是咋搞的呢？<code>window.foo()</code> 啊！毋庸置疑输出 <code>undefined</code>。</p><ul><li><strong>案例 3</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> foo = myObj.showThis;</span><br><span class="line">foo(); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>一般来说，这段代码输出应该是 <code>undefined</code>。</p><p>但是，这里需要注意的是，<code>window.name</code> 是当前 <code>window</code> 的名称，它是 <code>window.open()</code> 打开新网页这个方法的第二个参数的值。</p><p>所以这里输出的 <code>window.name</code> 是个空值 <code>&#39;&#39;</code>，或者当前存在的 <code>window</code> 的名称。</p><p><strong>jsliang</strong> 通过一个例子带小伙伴们看看这个是怎么来的：</p><blockquote><p>index.html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>jsliang<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>打开新网页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.btn&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.open(<span class="string">&#x27;index.html&#x27;</span>, <span class="string">&#x27;jsliang 的网页&#x27;</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在新打开的网页中的控制台，输入 <code>window.name</code>，获取 <code>jsliang 的网页</code>。</p><p>结论：</p><ul><li>在全局环境中调用一个函数，函数内部的 <code>this</code> 指向的是全局变量 <code>window</code>。</li><li>通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 <code>this</code> 指向对象本身。</li></ul><h3 id="4-3-通过构造函数中设置"><a href="#4-3-通过构造函数中设置" class="headerlink" title="4.3 通过构造函数中设置"></a><a name="chapter-four-three" id="chapter-four-three"></a>4.3 通过构造函数中设置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;jsliang&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> Foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;zhazhaliang&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo.name); <span class="comment">// 输出啥？</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>答案是：</p><ul><li>zhazhaliang</li><li>jsliang</li></ul><p>在将这个答案的缘故之前，我们看下 <code>new Foo()</code> 中，JavaScript 引擎做了什么事：</p><ul><li>首先创建一个空对象 <code>tempObj = &#123;&#125;</code>。</li><li>接着调用 <code>Foo.apply</code> 方法，将 <code>tempObj</code> 作为 <code>apply</code> 方法的参数，这样当 <code>Foo</code> 的执行上下文创建时，它的 <code>this</code> 就指向 <code>tempObj</code> 对象。</li><li>然后执行 <code>Foo</code> 函数，此时的 <code>Foo</code> 函数执行上下文中的 <code>this</code> 指向了 <code>tempObj</code> 对象。</li><li>最后返回 <code>tempObj</code> 对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">func, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> tempObj = &#123;&#125;;</span><br><span class="line">  func.apply(tempObj, args);</span><br><span class="line">  <span class="keyword">return</span> tempObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;jsliang&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> Foo = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = myNew(Foo, <span class="string">&#x27;zhazhaliang&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.name); <span class="comment">// 输出啥？</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.age); <span class="comment">// 输出啥？</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>如上，我们可以看到此时 <code>this</code> 是属于 <code>tempObj</code> 的，绑定到 <code>foo</code> 上去了，从而获取到：</p><ul><li>zhazhaliang</li><li>25</li><li>jsliang</li></ul><p>当然，了解到这里，我们还是完善下 <code>new</code> 这个手写方法，免得误导小伙伴们觉得 <code>new</code> 就做了那么点事：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">func, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 判断方法体</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;第一个参数必须是方法体&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 创建新对象</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 这个对象的 __proto__ 指向 func 这个类的原型对象</span></span><br><span class="line">  <span class="comment">// 即实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性</span></span><br><span class="line">  obj.__proto__ = <span class="built_in">Object</span>.create(func.prototype);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了兼容 IE 可以让步骤 2 和 步骤 3 合并</span></span><br><span class="line">  <span class="comment">// const obj = Object.create(func.prototype);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 通过 apply 绑定 this 执行并且获取运行后的结果</span></span><br><span class="line">  <span class="keyword">let</span> result = func.apply(obj, args);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 5. 如果构造函数返回的结果是引用数据类型，则返回运行后的结果</span></span><br><span class="line">  <span class="comment">// 否则返回新创建的 obj</span></span><br><span class="line">  <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result !== <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> isFunction = <span class="keyword">typeof</span> result === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> isObject || isFunction ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 用来测试第 5 点</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;返回引用数据类型&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来测试第 2 点和第 3 点</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> me = myNew(Person, <span class="string">&#x27;jsliang&#x27;</span>); <span class="comment">// 用来测试第 4 点</span></span><br><span class="line">me.sayName(); <span class="comment">// My name is jsliang</span></span><br><span class="line"><span class="built_in">console</span>.log(me); <span class="comment">// Person &#123;name: &#x27;jsliang&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来测试第 1 点</span></span><br><span class="line"><span class="comment">// const you = myNew(&#123; name: &#x27;jsliang&#x27; &#125;, &#x27;jsliang&#x27;); // 报错：第一个参数必须是方法体</span></span><br></pre></td></tr></table></figure><p>这样，我们就知道构造函数中的 <code>new</code> 是怎么一回事了。</p><h2 id="五-this-设计缺陷和应对方案"><a href="#五-this-设计缺陷和应对方案" class="headerlink" title="五 this 设计缺陷和应对方案"></a><a name="chapter-five" id="chapter-five"></a>五 this 设计缺陷和应对方案</h2><h3 id="5-1-嵌套函数中的-this-不会从外层函数中继承"><a href="#5-1-嵌套函数中的-this-不会从外层函数中继承" class="headerlink" title="5.1 嵌套函数中的 this 不会从外层函数中继承"></a><a name="chapter-five-one" id="chapter-five-one"></a>5.1 嵌套函数中的 this 不会从外层函数中继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  myName: <span class="string">&quot;jsliang&quot;</span>, </span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis();</span><br></pre></td></tr></table></figure><p>答案是：</p><ol><li>jsliang</li><li>undefined</li></ol><p><strong>解决方法一：通过 <code>that</code> 控制 <code>this</code> 指向</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  myName: <span class="string">&quot;jsliang&quot;</span>, </span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(that.myName); <span class="comment">// 输出啥？</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis();</span><br></pre></td></tr></table></figure><p>这样都输出 <code>jsliang</code> 了。</p><p><strong>解决方法二：通过 ES6 的箭头函数解决问题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  myName: <span class="string">&quot;jsliang&quot;</span>, </span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line">    <span class="keyword">const</span> bar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis();</span><br></pre></td></tr></table></figure><p>这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 <code>this</code> 取决于它的外部函数，即谁调用它 <code>this</code> 就继承自谁。</p><h3 id="5-2-普通函数中-this-指向全局对象-window"><a href="#5-2-普通函数中-this-指向全局对象-window" class="headerlink" title="5.2 普通函数中 this 指向全局对象 window"></a><a name="chapter-five-two" id="chapter-five-two"></a>5.2 普通函数中 this 指向全局对象 window</h3><p>在实际工作中，我们并不希望函数执行上下文中的 <code>this</code> 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。</p><p>如果要让函数执行上下文中的 <code>this</code> 指向某个对象，最好的方式是通过 <code>call</code> 方法来显示调用。</p><p>这个问题可以通过设置 JavaScript 的 <strong>严格模式</strong> 来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 <code>this</code> 值是 <code>undefined</code>，这就解决上面的问题了。</p><h2 id="六-React-中-this-指向"><a href="#六-React-中-this-指向" class="headerlink" title="六 React 中 this 指向"></a><a name="chapter-six" id="chapter-six"></a>六 React 中 this 指向</h2><p>来源于：<code>this.handleClik = this.handleClick.bind(this);</code></p><p>为什么要这么操作呢？</p><p>我们先看一份代码比对：</p><blockquote><p>代码 1：对象调用字段中 this</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出 jsliang</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">test.getName();</span><br></pre></td></tr></table></figure><blockquote><p>代码 2：存放到全局变量中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出 undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> func = test.getName;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>所以，React 中对应的方法，如果没有进行绑定，那么 <code>this</code> 就会混乱指向全局对象 <code>window</code>。</p><p>那么如何修正这个问题呢？</p><blockquote><p>注：网友指出：<strong>下面这 4 种方法的比对其实是有误的，普通对象没法跟类做对比</strong></p></blockquote><blockquote><p>当然，<strong>jsliang</strong> 在这里还是想列举出来</p></blockquote><blockquote><p>具体结论，相信 <code>202X</code> 年我们再次复习的时候，有机会就去逐步解答内心疑惑。</p></blockquote><blockquote><p>所以，为了避免矛盾冲突，小伙伴们可以跳过本章</p></blockquote><h3 id="6-1-解决方案一：提前-bind-绑定-this"><a href="#6-1-解决方案一：提前-bind-绑定-this" class="headerlink" title="6.1 解决方案一：提前 bind 绑定 this"></a><a name="chapter-six-one" id="chapter-six-one"></a>6.1 解决方案一：提前 bind 绑定 this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出 jsliang</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">test.getName = test.getName.bind(test);</span><br><span class="line"><span class="keyword">const</span> func = test.getName;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>对应 React 中的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">  <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;btn <span class="number">1</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="6-2-解决方案二：调用时-bind-绑定-this"><a href="#6-2-解决方案二：调用时-bind-绑定-this" class="headerlink" title="6.2 解决方案二：调用时 bind 绑定 this"></a><a name="chapter-six-two" id="chapter-six-two"></a>6.2 解决方案二：调用时 bind 绑定 this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出 jsliang</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> func = test.getName.bind(test);</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>对应 React 中的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)&#125;&gt;btn <span class="number">2</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="6-3-解决方案三：返回一个箭头函数"><a href="#6-3-解决方案三：返回一个箭头函数" class="headerlink" title="6.3 解决方案三：返回一个箭头函数"></a><a name="chapter-six-three" id="chapter-six-three"></a>6.3 解决方案三：返回一个箭头函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出 jsliang</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> func = <span class="function">() =&gt;</span> test.getName();</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>对应 React 中的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.handleClick()&#125;&gt;btn <span class="number">3</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="6-4-解决方案四：将调用方法变成箭头函数（失败）"><a href="#6-4-解决方案四：将调用方法变成箭头函数（失败）" class="headerlink" title="6.4 解决方案四：将调用方法变成箭头函数（失败）"></a><a name="chapter-six-four" id="chapter-six-four"></a>6.4 <del>解决方案四：将调用方法变成箭头函数（失败）</del></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  getName: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> func = test.getName;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>对应 React 中的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handleClick2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;jsliang 2021&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123;<span class="built_in">this</span>.handleClick2&#125;&gt;btn <span class="number">4</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure><p><strong>但是，这种方法失败了，返回 <code>undefined</code>，是什么缘故呢？</strong></p><p>网友指出：</p><ul><li>这 4 种方法的比对其实是有误的，普通对象没法跟类做对比</li></ul><p>当然，<strong>jsliang</strong> 还是想列举出来，具体结论，相信后面有机会会逐步解答内心疑惑。</p><h3 id="6-5-React-的-this-指向实际内容"><a href="#6-5-React-的-this-指向实际内容" class="headerlink" title="6.5 React 的 this 指向实际内容"></a><a name="chapter-six-five" id="chapter-six-five"></a>6.5 React 的 this 指向实际内容</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line">    <span class="comment">// this.handleClick = this.handleClick.bind(this);</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.isToggleOn ? <span class="string">&#x27;ON&#x27;</span> : <span class="string">&#x27;OFF&#x27;</span>&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Toggle /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>已知上面方法，编译后变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...代码省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Toggle = <span class="comment">/*#__PURE__*/</span><span class="function"><span class="keyword">function</span> (<span class="params">_React$Component</span>) </span>&#123;</span><br><span class="line">  _inherits(Toggle, _React$Component);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> _super = _createSuper(Toggle);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Toggle</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this;</span><br><span class="line"></span><br><span class="line">    _classCallCheck(<span class="built_in">this</span>, Toggle);</span><br><span class="line"></span><br><span class="line">    _this = _super.call(<span class="built_in">this</span>, props);</span><br><span class="line">    _this.state = &#123;</span><br><span class="line">      isToggleOn: <span class="literal">true</span></span><br><span class="line">    &#125;; <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line">    <span class="comment">// this.handleClick = this.handleClick.bind(this);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(Toggle, [&#123;</span><br><span class="line">    key: <span class="string">&quot;handleClick&quot;</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// 输出是 undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    key: <span class="string">&quot;render&quot;</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span>React.createElement(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">        onClick: <span class="built_in">this</span>.handleClick</span><br><span class="line">      &#125;, <span class="built_in">this</span>.state.isToggleOn ? <span class="string">&#x27;ON&#x27;</span> : <span class="string">&#x27;OFF&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Toggle;</span><br><span class="line">&#125;(React.Component);</span><br></pre></td></tr></table></figure><p>主要看 <code>_createClass</code> 方法，第一个参数是被创建的类，第二个参数是一个数组，数组里面是这个被创建类中的方法。</p><p>很显然，代码中 <code>handleClick</code> 输出的 <code>this</code>，肯定是 <code>undefined</code>。</p><p>而 <code>render</code> 方法返回的是 <code>React.createElement</code>，在这个方法中，<code>this</code> 被指向了 <code>_createClass</code> 方法的第一个参数，也就是 <code>Toggle</code> 。</p><p>这时候，如果这个方法变成箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时箭头函数是 <code>this</code> 定义时的上下文。</p><p>当我们点击按钮的时候，会调用 <code>handleClick</code> 方法来处理事件，而 <code>handleClick</code> 是在 <code>Toggle</code> 方法中定义的，所以 <code>this</code> 指代 <code>Toggle</code> 这个类。</p><h3 id="6-6-React-的-this-指向解决方案"><a href="#6-6-React-的-this-指向解决方案" class="headerlink" title="6.6 React 的 this 指向解决方案"></a><a name="chapter-six-six" id="chapter-six-six"></a>6.6 React 的 this 指向解决方案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;jsliang 2020&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;jsliang 2021&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="comment">// 四种绑定方法</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&#x27;App&#x27;</span>&gt;</span><br><span class="line">        &#123;<span class="comment">/* 方法一：通过 constructor 中进行 bind 绑定 */</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;btn <span class="number">1</span>&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/* 方法二：在里边绑定 this */</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)&#125;&gt;btn <span class="number">2</span>&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/* 方法三：通过箭头函数返回事件 */</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.handleClick()&#125;&gt;btn <span class="number">3</span>&lt;/button&gt;</span><br><span class="line">        </span><br><span class="line">        &#123;<span class="comment">/* 方法四：让方法变成箭头函数 */</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick2&#125;&gt;btn <span class="number">4</span>&lt;/button&gt;</span><br><span class="line">        </span><br><span class="line">        &#123;<span class="comment">/* 额外：直接调用不需要绑定 this */</span>&#125;</span><br><span class="line">        &#123;<span class="built_in">this</span>.handleClick()&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h2 id="七-小结"><a href="#七-小结" class="headerlink" title="七 小结"></a>七 小结</h2><p>先记住 1 句话：</p><ul><li><strong><code>this</code> 永远指向最后调用它的那个对象</strong></li></ul><p>再牢记 2 句话：</p><ul><li>普通函数中 <code>this</code> 的指向，是 <code>this</code> <strong>执行时</strong>的上下文</li><li>箭头函数中 <code>this</code> 的指向，是 <code>this</code> <strong>定义时</strong>的上下文</li></ul><h2 id="八-题目"><a href="#八-题目" class="headerlink" title="八 题目"></a>八 题目</h2><h3 id="8-1-this-题目解析-5-步曲"><a href="#8-1-this-题目解析-5-步曲" class="headerlink" title="8.1 this 题目解析 5 步曲"></a><a name="chapter-eight-one" id="chapter-eight-one"></a>8.1 this 题目解析 5 步曲</h3><ul><li>第一题</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window name&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;jsliang&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// 输出啥？</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;inner：&#x27;</span> + <span class="built_in">this</span>); <span class="comment">// 输出啥？</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;outer：&#x27;</span> + <span class="built_in">this</span>); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window name</span><br><span class="line">inner：window name</span><br><span class="line">outer：window name</span><br></pre></td></tr></table></figure><p>解析：这里的 <code>a()</code> 可以看成 <code>window.a()</code>，所以是都指向 <code>window</code> 里面的。</p><ul><li>第二题</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window name&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// 输出啥？</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();</span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：jsliang</p><p>解析：现在是 <code>a.fn()</code>，所以这个指向 <code>a</code>，因此输出 <code>jsliang</code></p><ul><li>第三题</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window name&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="comment">// name: &#x27;jsliang&#x27;,</span></span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// 输出啥？</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();</span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：undefined</p><p>解析：很明显，<code>a</code> 里面并没有 <code>name</code> 方法了，所以 <code>a.fn()</code> 找不到 <code>a</code> 对象里面有 <code>name</code>，因此输出 <code>undefined</code></p><ul><li>第四题</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window name&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// 输出啥？</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = a.fn;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：<code>window name</code></p><p>解析：代码 <code>var f = a.fn</code> 并没有调用 <code>a.fn</code>，而是做了个定义。在 <code>f()</code> 的时候才调用了，此时的 <code>fn()</code> 是 <code>window.fn()</code>，所以指向了 <code>window</code>，因此输出 <code>window name</code></p><ul><li>第五题</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window name&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;jsliang&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  innerFn();</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>答案：<code>window name</code></p><p>解析：小伙伴理解理解看看</p><h3 id="8-2-let-const-的-this"><a href="#8-2-let-const-的-this" class="headerlink" title="8.2 let/const 的 this"></a><a name="chapter-eight-two" id="chapter-eight-two"></a>8.2 let/const 的 this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.b);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：<code>undefined</code>、<code>undefined</code>、<code>undefined</code></p><p>解析：如果把 <code>var</code> 改成了 <code>let</code> 或者 <code>const</code>，变量是不会被绑定到 <code>window</code> 上的，所以此时会打印出三个 <code>undefined</code>。</p><h3 id="8-3-箭头函数的-this"><a href="#8-3-箭头函数的-this" class="headerlink" title="8.3 箭头函数的 this"></a>8.3 箭头函数的 this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window name&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.func1();</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func1(); <span class="comment">// 输出啥？</span></span><br><span class="line">a.func2(); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jsliang</span><br><span class="line">jsliang</span><br></pre></td></tr></table></figure><p>解析：箭头函数的 <code>this</code> 指向函数定义时的 <code>this</code>，而非执行时。箭头函数中没有 <code>this</code> 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 <code>this</code> 绑定的是最近一层非箭头函数的 <code>this</code>，否则，<code>this</code> 为 <code>undefined</code>。</p><h3 id="8-4-求输出结果"><a href="#8-4-求输出结果" class="headerlink" title="8.4 求输出结果"></a>8.4 求输出结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, foo &#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> foo2 = obj.foo;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo2</span>: obj.foo &#125;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// 输出啥？</span></span><br><span class="line">foo2(); <span class="comment">// 输出啥？</span></span><br><span class="line">obj2.foo2(); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li><code>obj.foo()</code>：<code>obj</code> 调用 <code>foo()</code>，所以指向 <code>obj</code>，输出 <code>1</code></li><li><code>foo2()</code>：实际上是 <code>window.foo2()</code>，指向 <code>window</code>，输出 <code>2</code></li><li><code>obj2.foo2()</code>：<code>obj2</code> 调用 <code>foo2()</code>，指向 <code>obj2</code>，输出 <code>3</code></li></ul><h3 id="8-5-隐式绑定丢失问题"><a href="#8-5-隐式绑定丢失问题" class="headerlink" title="8.5 隐式绑定丢失问题"></a><a name="chapter-eight-five" id="chapter-eight-five"></a>8.5 隐式绑定丢失问题</h3><h4 id="8-5-1-求输出结果"><a href="#8-5-1-求输出结果" class="headerlink" title="8.5.1 求输出结果"></a><a name="chapter-eight-five-one" id="chapter-eight-five-one"></a>8.5.1 求输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, foo &#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">doFoo(obj.foo); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：<code>Window &#123;...&#125;</code>、<code>2</code></p><p>解析：<strong>隐式绑定丢失问题</strong>。<code>deFoo</code> 传参 <code>obj.foo</code> 的时候，此刻 <code>foo</code> 还没被执行，所以在 <code>doFoo</code> 中 <code>fn()</code> 就相当于 <code>window.fn()</code>，所以指向到 <code>window</code> 啦！</p><blockquote><p>注意此时调用的时候，查找的 <code>fn</code> 是 <code>window</code> 上的 <code>fn</code>，而不是 <code>doFoo</code> 里的，<code>doFoo</code> 并没有设置 <code>fn</code> 这个方法。</p></blockquote><h4 id="8-5-2-求输出结果"><a href="#8-5-2-求输出结果" class="headerlink" title="8.5.2 求输出结果"></a><a name="chapter-eight-five-two" id="chapter-eight-five-two"></a>8.5.2 求输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, foo &#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">3</span>, doFoo &#125;;</span><br><span class="line"></span><br><span class="line">obj2.doFoo(obj.foo); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：<code>&#123; a: 3, doFoo: f &#125;</code>、<code>2</code></p><p>解析：</p><ol><li>此刻的 <code>fn()</code> 调用，查找到的位置还是 <code>window.foo()</code>，所以调用的时候会指向 <code>window</code>。</li><li>这里的 <code>fn()</code> 是通过传参进来的，而不是 <code>doFoo</code> 里面存在的，所以执行的时候 <code>this</code> 找到的是 <code>foo</code> 定义的位置，实际上还是 <code>window.fn()</code></li><li>如何改正这个问题？</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  fn.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, foo &#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">3</span>, doFoo &#125;;</span><br><span class="line"></span><br><span class="line">obj2.doFoo(obj.foo);</span><br></pre></td></tr></table></figure><h3 id="8-6-显示绑定问题"><a href="#8-6-显示绑定问题" class="headerlink" title="8.6 显示绑定问题"></a>8.6 显示绑定问题</h3><h4 id="8-6-1-求输出结果"><a href="#8-6-1-求输出结果" class="headerlink" title="8.6.1 求输出结果"></a>8.6.1 求输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 输出啥？</span></span><br><span class="line">foo.call(obj); <span class="comment">// 输出啥？</span></span><br><span class="line">foo().call(obj); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">Uncaught TypeError: Cannot read property &#39;call&#39; of undefined</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li><code>foo()</code>：指向 <code>window</code></li><li><code>foo.call(obj)</code>：将 <code>foo</code> 的 <code>this</code> 指向了 <code>obj</code></li><li><code>foo().call(obj)</code>：先执行 <code>foo()</code>，输出 <code>2</code>，然后它是无返回的，相当于 <code>undefined.call(obj)</code>，直接报错</li></ul><h4 id="8-6-2-求输出结果"><a href="#8-6-2-求输出结果" class="headerlink" title="8.6.2 求输出结果"></a>8.6.2 求输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 输出啥？</span></span><br><span class="line">foo.call(obj); <span class="comment">// 输出啥？</span></span><br><span class="line">foo().call(obj); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>解析：前面 3 个不用说，和上面一题一样。</p><p>最后一个 <code>return function &#123; this.a &#125;</code>，所以变成这个方法来 <code>call(obj)</code>，因此输出 <code>obj</code> 中的 <code>a</code>，也就是 <code>1</code>。 </p><h3 id="8-7-求输出结果"><a href="#8-7-求输出结果" class="headerlink" title="8.7 求输出结果"></a>8.7 求输出结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.location);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo();</span><br></pre></td></tr></table></figure><p>请选择：</p><ul><li>A：当前窗口的 <code>Location</code> 对象</li><li>B：<code>undefined</code></li><li>C：<code>null</code></li><li>D：<code>TypeError</code></li></ul><hr><p>答案：D</p><p>解析：如果没有 <code>use strict</code>，那么选 A；如果是严格模式，那就是 D，严格模式下禁止 <code>this</code> 关键字指向全局对象。</p><h3 id="8-8-阐述题"><a href="#8-8-阐述题" class="headerlink" title="8.8 阐述题"></a>8.8 阐述题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userInfo = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">  sex: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">  updateInfo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 模拟 XMLHttpRequest 请求延时</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = <span class="string">&quot;zhazhaliang&quot;</span></span><br><span class="line">      <span class="built_in">this</span>.age = <span class="number">30</span>;</span><br><span class="line">      <span class="built_in">this</span>.sex = <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">userInfo.updateInfo();</span><br></pre></td></tr></table></figure><p>解决这里的 <code>this</code> 指向问题，求得最终结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: <span class="string">&quot;zhazhaliang&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  sex: <span class="string">&quot;female&quot;</span>,</span><br><span class="line">  updateInfo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>),</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><hr><p>答案：<code>setTimeout(() =&gt; &#123;&#125;)</code> 即可。</p><h2 id="九-参考文献"><a href="#九-参考文献" class="headerlink" title="九 参考文献"></a>九 参考文献</h2><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://juejin.im/post/6844904083707396109">再来40道this面试题酸爽继续</a>【阅读建议：1h】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://www.cnblogs.com/painsOnline/p/5102359.html">this,this,再次讨论javascript中的this,超全面</a>【阅读建议：10min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://juejin.im/post/59748cbb6fb9a06bb21ae36d">JavaScript中的this</a>【阅读建议：10min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/mqyqingfeng/Blog/issues/7">JavaScript深入之从ECMAScript规范解读this</a>【阅读建议：20min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://www.jianshu.com/p/d647aa6d1ae6">前端基础进阶（七）：全方位解读this</a>【阅读建议：20min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/axuebin/articles/issues/6">JavaScript基础心法——this</a>【阅读建议：20min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://time.geekbang.org/column/article/128427">11 | this：从JavaScript执行上下文的视角讲清楚this</a>【阅读建议：2hour】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://www.jianshu.com/p/159eabf152d0">浅谈react 中的 this 指向</a>【阅读建议：10min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://note.youdao.com/ynoteshare1/index.html?id=3d64b603405bcbb2c3cad3f750e5341d&type=note">react的性能优化</a>【阅读建议：5min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/qq_34829447/article/details/81705977">React事件处理函数必须使用bind(this)的原因</a>【阅读建议：10min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/AiHuanhuan110/article/details/106424812">由React构造函数中bind引起的this指向理解（React组件的方法为什么要用bind绑定this）</a>【阅读建议：20min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/yiersan__/article/details/108004911">React中this.handleClick = this.handleClick.bind(this)中的this指向问题</a>【阅读建议：10min】</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;this问题&quot;&gt;&lt;a href=&quot;#this问题&quot; class=&quot;headerlink&quot; title=&quot;this问题&quot;&gt;&lt;/a&gt;this问题&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之CSS篇</title>
    <link href="http://github.com/2020/12/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BCSS%E7%AF%87/"/>
    <id>http://github.com/2020/12/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BCSS%E7%AF%87/</id>
    <published>2020-12-02T16:00:00.000Z</published>
    <updated>2020-12-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS高频面试题及参考答案</p><h2 id="CSS高频面试题"><a href="#CSS高频面试题" class="headerlink" title="CSS高频面试题"></a>CSS高频面试题</h2><h3 id="是否了解盒模型，介绍一下标准的-CSS-盒子模型与低版本的-IE-盒子模型有什么不同box-sizing常用的属性有哪些-分别有啥作用"><a href="#是否了解盒模型，介绍一下标准的-CSS-盒子模型与低版本的-IE-盒子模型有什么不同box-sizing常用的属性有哪些-分别有啥作用" class="headerlink" title="是否了解盒模型，介绍一下标准的 CSS 盒子模型与低版本的 IE 盒子模型有什么不同box-sizing常用的属性有哪些? 分别有啥作用?"></a>是否了解盒模型，介绍一下标准的 CSS 盒子模型与低版本的 IE 盒子模型有什么不同box-sizing常用的属性有哪些? 分别有啥作用?</h3><blockquote><p>盒子模型是CSS布局中的核心概念 一个box 等于 自身+内边距+边框+外边距</p></blockquote><ul><li>CSS3中有一个属性 box-sizing</li><li>border-box 指的是怪异盒模型 W3C规范的标准</li><li>content-box 指的是标准盒模型 IE盒子模型 IExplore制定的标准</li><li>在IExplore中，若HTML文档缺失声明则会触发怪异盒模型<ul><li>W3C盒子模型：可通过box-sizing: content-box来设置，他包含content+padding+border+margin。</li><li>IE盒子模型：可通过box-sizing: border-box来设置，content+margin。其中content包含width , border，padding。</li></ul></li></ul><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><blockquote><p>block formatting context，块级格式化上下文。</p></blockquote><ul><li>产生了BFC的，形成了独立容器，他的特性就是不会再布局中影响到外边的元素。<h4 id="介绍-Box-block-formatting-context"><a href="#介绍-Box-block-formatting-context" class="headerlink" title="介绍 Box, block formatting context"></a>介绍 Box, block formatting context</h4></li></ul><ol><li>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。</li><li>元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。</li><li>有哪些盒子：</li></ol><ul><li><p>block-level box:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line">- inline-level box:</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line">    display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line">4. Formatting context 　</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line">    Formatting context 是 W3C CSS2.1 规范中的一个概念。</span><br><span class="line">    它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</span><br><span class="line">    最常见的 Formatting context 有 Block fomatting context (简称BFC)和Inline formatting context (简称IFC)。</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">#### BFC布局规则：</span><br><span class="line">1. 内部的Box会在垂直方向，一个接一个地放置。</span><br><span class="line">2. BFC的区域不会与float box重叠。</span><br><span class="line">3. 内部的Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</span><br><span class="line">4. 计算BFC的高度时，浮动元素也参与计算。(清除浮动   haslayout)</span><br><span class="line">5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</span><br><span class="line"></span><br><span class="line">#### BFC什么时候出现(哪些元素会生成BFC?)</span><br><span class="line">1. 根元素</span><br><span class="line">2. float属性不为none</span><br><span class="line">3. position为absolute或fixed</span><br><span class="line">4. overflow不为visible</span><br><span class="line">5. display为inline-block, table-cell, table-caption, flex, inline-flex</span><br><span class="line"></span><br><span class="line">#### 除了BFC，还有IFC、GFC、FFC的概念</span><br><span class="line"></span><br><span class="line">- GFC：可简单理解为grid布局</span><br><span class="line">- FFC：可简单理解为flex布局。</span><br><span class="line">- IFC:内联格式化上下文，简单理解为：inline-block。</span><br><span class="line"></span><br><span class="line">水平方向上的 margin，border 和 padding在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。包含那些框的长方形区域，会形成一行，叫做行框。</span><br><span class="line">inline-block的元素的内部是一个BFC，但是它本身可以和其它inline元素一起形成IFC。</span><br><span class="line"></span><br><span class="line">#### 作用与场景</span><br><span class="line"></span><br><span class="line">- 防止margin 发生重叠（相邻元素的外边距重叠问题）</span><br><span class="line"></span><br><span class="line">我们先看一般的情况下,上下元素都有margin 的情况下，会出现重叠的情况,实际只有 50px，所谓的塌陷其实是两个BFC的相邻盒或父子盒相互作用时产生的效果，两个盒子会取相邻边最大margin作为相邻边的共用margin。</span><br></pre></td></tr></table></figure><p>.box1 {<br>margin-bottom: 50px;<br>}<br>.box2 {<br>margin-top: 50px;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 防止浮动节点被覆盖</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line">.parent &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  &#x2F;* 当父元素不写高度的时候会发生高度塌陷 *&#x2F;</span><br><span class="line">  &#x2F;* height: 100px; *&#x2F;</span><br><span class="line">  border: 1px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.float &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 50px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  background-color: #eee;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">- 清除浮动</span><br></pre></td></tr></table></figure><p>overflow: auto;<br>/* 或者 */<br>display: flow-root;<br>```</p><h3 id="请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式："><a href="#请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式：" class="headerlink" title="请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式："></a>请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式：</h3><blockquote><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p></blockquote><h4 id="浮动元素引起的问题和解决办法？"><a href="#浮动元素引起的问题和解决办法？" class="headerlink" title="浮动元素引起的问题和解决办法？"></a>浮动元素引起的问题和解决办法？</h4><p>浮动元素引起的问题：</p></li><li><p>父元素的高度无法被撑开，影响与父元素同级的元素与浮动元素同级的非浮动元素（内联元素）会跟随其后若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;content: &quot;.&quot;;display: block;height: 0;clear: both;visibility: hidden;&#125;</span><br><span class="line">.clearfix&#123;display: inline-block;&#125; &#x2F;* for IE&#x2F;Mac *&#x2F;</span><br></pre></td></tr></table></figure><h4 id="清除浮动的几种方法："><a href="#清除浮动的几种方法：" class="headerlink" title="清除浮动的几种方法："></a>清除浮动的几种方法：</h4></li><li><p>额外标签法</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;clear:both;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）</span><br></pre></td></tr></table></figure></li><li><p>使用after伪类</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#parent:after&#123;</span><br><span class="line">content:&quot;.&quot;;</span><br><span class="line">height:0;</span><br><span class="line">visibility:hidden;</span><br><span class="line">display:block;</span><br><span class="line">clear:both;</span><br><span class="line">&#125;</span><br><span class="line">注意这里是给父元素加</span><br></pre></td></tr></table></figure></li><li><p>设置overflow为hidden或者auto</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1;</span><br><span class="line">&#x2F;&#x2F; zoom:1用于兼容IE6。</span><br></pre></td></tr></table></figure></li></ul><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><ul><li>flex，即弹性布局。一个由css3引入，为我们的盒子属性带来灵活性的一种布局方式。一旦父级采用了flex布局，里边的子控件将收flex布局限制，部分原本的样式（如float:left）也会失效。</li><li>基本api: <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></li><li>特别注意：<br>flex:0 0 30%的意义：等于flex-grow=0（默认不放大）+flex-shrink=0（不缩小）+flex-basis=30%（ 项目占据主轴的空间）</li></ul><h3 id="css3新特性"><a href="#css3新特性" class="headerlink" title="css3新特性"></a>css3新特性</h3><ol><li>背景，支持RGBA透明度，一次多背景图</li><li>支持媒体查询</li><li>支持阴影，渐变，</li><li>支持边框图片，border-image: url(border.png) 30 30 round</li><li>支持transform位移系列</li><li>支持过渡效果transition</li><li>支持自定义字体</li><li>引入flex/grid布局</li><li>引入多种选择器</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS高频面试题及参考答案&lt;/p&gt;
&lt;h2 id=&quot;CSS高频面试题&quot;&gt;&lt;a href=&quot;#CSS高频面试题&quot; class=&quot;headerlink&quot; title=&quot;CSS高频面试题&quot;&gt;&lt;/a&gt;CSS高频面试题&lt;/h2&gt;&lt;h3 id=&quot;是否了解盒模型，介绍一下标准的-CSS-
      
    
    </summary>
    
    
      <category term="面试" scheme="http://github.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://github.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>vue的总结</title>
    <link href="http://github.com/2020/08/27/vue%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://github.com/2020/08/27/vue%E7%9A%84%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-27T02:32:57.000Z</published>
    <updated>2020-08-27T02:32:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><h2 id="vue基础点"><a href="#vue基础点" class="headerlink" title="vue基础点"></a>vue基础点</h2><h3 id="vue的优点"><a href="#vue的优点" class="headerlink" title="vue的优点"></a>vue的优点</h3><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，压缩后大小只有几十kb；<br>简单易学：国人开发，中文文档，易于理解和学习；<br>双向数据绑定<br>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；<br>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；<br>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；<br>运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。<br>vue做SPA应用的用户体验还是不错的，性能也比较好，开发起来也比较简单，也能实现前后端分离</p><p>vue的大量封装既是优点又是缺点，对于seo不好</p><h3 id="vue-常用指令"><a href="#vue-常用指令" class="headerlink" title="vue 常用指令"></a>vue 常用指令</h3><ul><li>v-html / v-text：把值中的标签渲染出来</li><li>v-model： 放在表单元素上的，实现双向数据绑定</li><li>v-bind（缩写 :）：用于绑定行内属性</li><li>v-if / v-show 是否能显示，true 能显示，false 不能显示</li><li>v-cloak：需要配合 css 使用：解决小胡子显示问题</li><li>v-once 对应的标签只渲染一次</li><li>v-for ：循环显示元素</li><li>v-on 事件绑定</li></ul><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>Vue.js 为 v-on 提供了事件修饰符，修饰符是由点开头的指令后缀来表示的。</p><ul><li>stop：阻止事件继续传播</li><li>prevent：阻止事件默认行为</li><li>capture：添加事件监听器时使用事件捕获模式</li><li>self：当前元素触发时才触发事件处理函数</li><li>once：事件只触发一次</li><li>passive：告诉浏览器你不想阻止事件的默认行为，不能和.prevent 一起使用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop&#x3D;&quot;toDo&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;toSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent&#x3D;&quot;toDo&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture&#x3D;&quot;toDo&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;div v-on:click.self&#x3D;&quot;toDo&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="line">&lt;a v-on:click.once&#x3D;&quot;toDo&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="line">&lt;div v-on:scroll.passive&#x3D;&quot;onScroll&quot;&gt;...&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HTML知识点</title>
    <link href="http://github.com/2020/08/14/HTML%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://github.com/2020/08/14/HTML%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-08-13T16:00:00.000Z</published>
    <updated>2020-08-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是关于html的一些常见知识点，主要是方便本人查看，在这里存个记录</p><h2 id="HTML知识点"><a href="#HTML知识点" class="headerlink" title="HTML知识点"></a>HTML知识点</h2><h3 id="HTML5在标签、属性、存储、API上的新特性"><a href="#HTML5在标签、属性、存储、API上的新特性" class="headerlink" title="HTML5在标签、属性、存储、API上的新特性"></a>HTML5在标签、属性、存储、API上的新特性</h3><ol><li>标签：新增语义化标签（aside / figure / section / header / footer / nav等），增加多媒体标签video和audio，使得样式和结构更加分离</li><li>属性：增强表单，主要是增强了input的type属性；meta增加charset以设置字符集；script增加async以异步加载脚本</li><li>存储：增加localStorage、sessionStorage和indexedDB，引入了application cache对web和应用进行缓存</li><li>API：增加拖放API、地理定位、SVG绘图、canvas绘图、Web Worker、WebSocket</li></ol><h3 id="doctype的作用"><a href="#doctype的作用" class="headerlink" title="doctype的作用"></a>doctype的作用</h3><blockquote><p>声明文档类型，告知浏览器用什么文档标准解析这个文档</p></blockquote><ul><li>怪异模式：浏览器使用自己的模式解析文档，不加doctype时默认为怪异模式</li><li>标准模式：浏览器以W3C的标准解析文档</li></ul><h3 id="语义化的意义是什么"><a href="#语义化的意义是什么" class="headerlink" title="语义化的意义是什么"></a>语义化的意义是什么</h3><ul><li>开发者容易理解</li><li>机器容易理解结构(搜索、读屏软件)</li><li>有助于SEO</li><li>semantic 、microdata</li></ul><h3 id="前端储存及区别"><a href="#前端储存及区别" class="headerlink" title="前端储存及区别"></a>前端储存及区别</h3><ul><li>cookies： HTML5之前本地储存的主要方式，大小只有4k，HTTP请求头会自动带上cookie，兼容性好</li><li>localStorage：HTML5新特性，持久性存储，即使页面关闭也不会被清除，以键值对的方式存储，大小为5M</li><li>sessionStorage：HTML5新特性，操作及大小同localStorage，和- - - localStorage的区别在于sessionStorage在选项卡(页面)被关闭时即清除，且不同选项卡之间的sessionStorage不互通</li><li>IndexedDB： NoSQL型数据库，类比MongoDB，使用键值对进行储存，异步操作数据库，支持事务，储存空间可以在250MB以上，但是IndexedDB受同源策略限制</li><li>Web SQL：是在浏览器上模拟的关系型数据库，开发者可以通过SQL语句来操作Web SQL，是HTML5以外一套独立的规范，兼容性差</li></ul><h3 id="href和src有什么区别"><a href="#href和src有什么区别" class="headerlink" title="href和src有什么区别"></a>href和src有什么区别</h3><p>href（hyperReference）即超文本引用：当浏览器遇到href时，会并行的地下载资源，不会阻塞页面解析，例如我们使用<link>引入CSS，浏览器会并行地下载CSS而不阻塞页面解析. 因此我们在引入CSS时建议使用<link>而不是@import</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href&#x3D;&quot;style.css&quot; rel&#x3D;&quot;stylesheet&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>src（resource）即资源，当浏览器遇到src时，会暂停页面解析，直到该资源下载或执行完毕，这也是script标签之所以放底部的原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h3><p>iframe会阻塞主页面的Onload事件；<br>搜索引擎的检索程序无法解读这种页面，不利于SEO;<br>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p><blockquote><p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题。</p></blockquote><h3 id="meta有哪些属性，作用是什么"><a href="#meta有哪些属性，作用是什么" class="headerlink" title="meta有哪些属性，作用是什么"></a>meta有哪些属性，作用是什么</h3><p>meta标签用于描述网页的元信息，如网站作者、描述、关键词，meta通过name=xxx和content=xxx的形式来定义信息，常用设置如下：</p><ul><li>charset：定义HTML文档的字符集<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot; &gt;</span><br></pre></td></tr></table></figure></li><li>http-equiv：可用于模拟http请求头，可设置过期时间、缓存、刷新<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＜meta http-equiv&#x3D;&quot;expires&quot; content&#x3D;&quot;Wed, 20 Jun 2019 22:33:00 GMT&quot;＞</span><br></pre></td></tr></table></figure></li><li>viewport：视口，用于控制页面宽高及缩放比例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta </span><br><span class="line">    name&#x3D;&quot;viewport&quot; </span><br><span class="line">    content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="viewport有哪些参数，作用是什么"><a href="#viewport有哪些参数，作用是什么" class="headerlink" title="viewport有哪些参数，作用是什么"></a>viewport有哪些参数，作用是什么</h3><ul><li>width/height，宽高，默认宽度980px</li><li>initial-scale，初始缩放比例，1~10</li><li>maximum-scale/minimum-scale，允许用户缩放的最大/小比例</li><li>user-scalable，用户是否可以缩放 (yes/no)</li></ul><h3 id="http-equive属性的作用和参数"><a href="#http-equive属性的作用和参数" class="headerlink" title="http-equive属性的作用和参数"></a>http-equive属性的作用和参数</h3><ul><li>expires，指定过期时间</li><li>progma，设置no-cache可以禁止缓存</li><li>refresh，定时刷新</li><li>set-cookie，可以设置cookie</li><li>X-UA-Compatible，使用浏览器版本</li><li>apple-mobile-web-app-status-bar-style，针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是关于html的一些常见知识点，主要是方便本人查看，在这里存个记录&lt;/p&gt;
&lt;h2 id=&quot;HTML知识点&quot;&gt;&lt;a href=&quot;#HTML知识点&quot; class=&quot;headerlink&quot; title=&quot;HTML知识点&quot;&gt;&lt;/a&gt;HTML知识点&lt;/h2&gt;&lt;h3 id=&quot;HTM
      
    
    </summary>
    
    
      <category term="html" scheme="http://github.com/categories/html/"/>
    
    
      <category term="html" scheme="http://github.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Markdown编写指南</title>
    <link href="http://github.com/2020/08/05/Markdown%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"/>
    <id>http://github.com/2020/08/05/Markdown%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/</id>
    <published>2020-08-05T07:56:31.000Z</published>
    <updated>2020-08-05T07:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要是怕自己记不住</p><h2 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown"></a>什么是Markdown</h2><p>Markdown是一种轻量级标记语言，通过纯文本的方式编写文档，然后再通过工具转化成HTML，PDF，图片等格式，实现Write Once，Read Everywhere的效果。下面直接开始指南</p><h2 id="Markdown基础语法"><a href="#Markdown基础语法" class="headerlink" title="Markdown基础语法"></a>Markdown基础语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*强调文本（斜体）*</span> <span class="emphasis">_强调文本（斜体）_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**加粗文本**</span> <span class="strong">__加粗文本__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*着重的强调文本（加粗和斜体）<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">==标记文本==</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">~~删除文本~~</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">&gt; 引用文本</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">下标: 把字缩放，适合用来表现公式类的</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">H~2~O is是液体。</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">2^10^ 运算结果是 1024。</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br></pre></td></tr></table></figure><p><em>强调文本（斜体）</em> <em>强调文本（斜体）</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p><strong><em>着重的强调文本（加粗和斜体）</em></strong></p><p>==标记文本==</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H<del>2</del>O is是液体。</p><p>2^10^ 运算结果是 1024。</p><h3 id="字号及颜色"><a href="#字号及颜色" class="headerlink" title="字号及颜色"></a>字号及颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;font size&#x3D;1&gt;大小为1的字体&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font size&#x3D;6&gt;大小为6的字体&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font color&#x3D;gray size&#x3D;4&gt;gray颜色的字&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;green size&#x3D;4&gt;green颜色的字&lt;&#x2F;font&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font size=1>大小为1的字体</font><br><font size=6>大小为6的字体</font></p><p><font color=gray size=4>gray颜色的字</font><br><font color=green size=5>green颜色的字</font></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><blockquote><p>Markdown中并无下划线的原生语法，可以通过HTML的u标签来实现。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;我带下划线&lt;&#x2F;u&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><u>我带下划线</u></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">无序列表</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 项目</span><br><span class="line"><span class="bullet">*</span> 项目</span><br><span class="line"><span class="bullet">+</span> 项目</span><br><span class="line"></span><br><span class="line">有序列表</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 项目1</span><br><span class="line"><span class="bullet">2.</span> 项目2</span><br><span class="line"><span class="bullet">3.</span> 项目3</span><br><span class="line"></span><br><span class="line">列表混合及嵌套</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 测试啊</span><br><span class="line"><span class="bullet">  -</span> 真的测试啊</span><br><span class="line"><span class="bullet">  -</span> 你不信啊</span><br><span class="line"><span class="bullet">    1.</span> 我是三级有序列表</span><br><span class="line"><span class="bullet">    2.</span> 呵呵哒</span><br><span class="line"><span class="bullet">  -</span> 唉</span><br><span class="line"></span><br><span class="line">可勾选列表</span><br><span class="line"><span class="bullet">-</span> [ ] 计划任务</span><br><span class="line"><span class="bullet">-</span> [x] 完成任务</span><br></pre></td></tr></table></figure><p><strong><em>无序列表</em></strong></p><ul><li>项目</li></ul><ul><li>项目</li></ul><ul><li>项目</li></ul><p><strong><em>有序列表</em></strong></p><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><p><strong><em>列表混合及嵌套</em></strong></p><ul><li>测试啊<ul><li>真的测试啊</li><li>你不信啊<ol><li>我是三级有序列表</li><li>呵呵哒</li></ol></li><li>唉</li></ul></li></ul><p><strong><em>可勾选列表</em></strong></p><ul><li><input disabled="" type="checkbox"> 计划任务</li><li><input checked="" disabled="" type="checkbox"> 完成任务</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一段引用      &#x2F;&#x2F;在&#96;&gt;&#96;后面有 1 个空格</span><br><span class="line"></span><br><span class="line">&gt; 代码块形式引用在&#96;&gt;&#96;后面有 5 个空格， </span><br><span class="line">&gt; 例子：</span><br><span class="line">&gt;</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&gt; 一级引用</span><br><span class="line">&gt; &gt; 二级引用</span><br><span class="line">&gt; &gt; &gt; 三级引用</span><br><span class="line"></span><br><span class="line">&gt; 标题加引用</span><br><span class="line">&gt; #### 标题加引用</span><br><span class="line">&gt;</span><br><span class="line">&gt; 1. 这是第一行列表项</span><br><span class="line">&gt; 2. 这是第二行列表项</span><br></pre></td></tr></table></figure><blockquote><p>普通引用在<code>&gt;</code>后面有 1 个空格</p></blockquote><blockquote><p>代码块形式引用在<code>&gt;</code>后面有 5 个空格，<br>例子：</p></blockquote><pre><code>protected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);&#125;</code></pre><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p></blockquote></blockquote></blockquote><blockquote><p>标题加引用</p><h4 id="这是一个四级标题"><a href="#这是一个四级标题" class="headerlink" title="这是一个四级标题"></a>这是一个四级标题</h4><ol><li>这是第一行列表项</li><li>这是第二行列表项</li></ol></blockquote><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">图片  ![<span class="string">图片文本(可忽略)</span>](<span class="link">图片地址</span>)</span><br><span class="line"><span class="code">      ![图片文本(可忽略)](图片地址 &quot;可选标题&quot;)</span></span><br><span class="line"><span class="code">带尺寸： &lt;img src=&quot;https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg&quot; width=10%&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">链接： [链接文本](链接地址)</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">[![百度](https://www.baidu.com/img/bd_logo1.png)](https://www.baidu.com/)</span></span><br></pre></td></tr></table></figure><blockquote><p>链接又分为行内式、参考式和 自动链接</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">这是行内式链接：[<span class="string">博客</span>](<span class="link">https://lonelyzou.github.io/</span>)。</span><br><span class="line"></span><br><span class="line">这是参考式链接：[<span class="string">博客</span>][<span class="symbol">url</span>]，其中url为链接标记，可置于文中任意位置。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">url</span>]: <span class="link">https://lonelyzou.github.io &quot;博客&quot;</span></span><br><span class="line"></span><br><span class="line">链接标记格式为：[链接标记文本]:  链接地址  链接title(可忽略)</span><br><span class="line"></span><br><span class="line">这是自动链接：直接使用<span class="code">`&lt;&gt;`</span>括起来<span class="xml"><span class="tag">&lt;<span class="name">https:</span>//<span class="attr">blog.csdn.net</span>/<span class="attr">a1056244734</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">这是图片：![][头像]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">头像</span>]: <span class="link">https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg</span></span><br><span class="line"></span><br><span class="line">带尺寸： <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg&quot;</span> <span class="attr">width</span>=<span class="string">10%</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这是行内式链接：<a href="https://lonelyzou.github.io/">博客</a>。</p><p>这是参考式链接：<a href="https://lonelyzou.github.io/" title="博客">博客</a>，其中url为链接标记，可置于文中任意位置。</p><p>链接标记格式为：[链接标记文本]:  链接地址  链接title(可忽略)</p><p>这是自动链接：直接使用<code>&lt;&gt;</code>括起来<a href="https://blog.csdn.net/a1056244734">https://blog.csdn.net/a1056244734</a></p><p>这是图片：<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg"></p><p>![logo](<a href="https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg">https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg</a> logo)</p><p>带尺寸的图片: <img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg" width=10%></p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><blockquote><p>在一行中用三个以上的*、-、_来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式: 空行 --- 或 <span class="strong">**<span class="emphasis">* 或 <span class="strong">__<span class="emphasis">_</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">空行</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">---</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">这是空行</span></span></span></span></span><br></pre></td></tr></table></figure><p>空行</p><hr><p>这是空行</p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><blockquote><p>在行尾添加两个空格加回车表示换行：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一行后面加<span class="code">`&lt;br&gt;`</span><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span>换行</span><br></pre></td></tr></table></figure><p>这是一行后面加<code>&lt;br&gt;</code><br>换行</p><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：反引号+内容+反引号</span><br><span class="line"></span><br><span class="line"><span class="code">`module.exports= ()=&gt;&#123;&#125;`</span></span><br></pre></td></tr></table></figure><p><code>module.exports= ()=&gt;&#123;&#125;</code></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><blockquote><p>行内代码</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：反引号+内容+反引号</span><br><span class="line"></span><br><span class="line"><span class="code">`module.exports= ()=&gt;&#123;&#125;`</span></span><br></pre></td></tr></table></figure><blockquote><p>多行代码</p></blockquote><ol><li>代码区块使用 4 个空格或 1 个制表符(Tab)</li><li>使用```包裹一段代码，并指定一种语言（也可以不指定）</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：<span class="code">```+内容+```</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文字高亮"><a href="#文字高亮" class="headerlink" title="文字高亮"></a>文字高亮</h3><blockquote><p>有的markdown展示不支持</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">===听说我要呗高亮了===</span><br><span class="line"></span><br><span class="line">==是啊==</span><br><span class="line"></span><br><span class="line">==亮瞎眼了==</span><br></pre></td></tr></table></figure><p>===听说我要呗高亮了===</p><p>==是啊==</p><p>==亮瞎眼了==</p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```javascript</span></span><br><span class="line"><span class="code">// 我是 js 高亮</span></span><br><span class="line"><span class="code">import vue from &#x27;vue&#x27;;</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我是 js 高亮</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个具有注脚的文本。[^1]</span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">注脚的解释</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个具有注脚的文本。<a href="%E6%B3%A8%E8%84%9A%E7%9A%84%E8%A7%A3%E9%87%8A">^1</a></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Markdown将文本转换为 HTML。</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*[HTML]: 超文本标记语言</span></span><br></pre></td></tr></table></figure><p>Markdown将文本转换为 HTML。</p><p>*[HTML]: 超文本标记语言</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><blockquote><p>默认的列左对齐,也支持设置居中和右对齐, 横杆大于等于3， 列的竖必须闭合才能代表一列！</p></blockquote><ul><li>默认对齐(左对齐) :  :—-</li><li>居中对齐 : :—:</li><li>右对齐: —:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 默认左对齐     |       居中对齐       |     右对齐 |</span><br><span class="line">| :--- | :------------------: | -------: |</span><br><span class="line">| 珂朵莉 | 珂朵莉 | 珂朵莉 |</span><br><span class="line">| 珂朵莉 | 珂朵莉 | 珂朵莉 |</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">默认左对齐</th><th align="center">居中对齐</th><th align="right">右对齐</th></tr></thead><tbody><tr><td align="left">珂朵莉</td><td align="center">珂朵莉</td><td align="right">珂朵莉</td></tr><tr><td align="left">珂朵莉</td><td align="center">珂朵莉</td><td align="right">珂朵莉</td></tr></tbody></table><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><blockquote><p>「Markdown 语言」不负责实现段首缩进，所以我们只能手写，添加空格转义符，<a href="https://blog.csdn.net/a1056244734/article/details/106410927">前端HTML空格转义符总结</a></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`Math.abs(x)`</span></span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;返回一个数的绝对值。<span class="code">`在这里插入代码片`</span></span><br></pre></td></tr></table></figure><p><code>Math.abs(x)</code></p><p>&emsp;&emsp;返回一个数的绝对值。<code>在这里插入代码片</code></p><h3 id="高级技巧-HTML元素"><a href="#高级技巧-HTML元素" class="headerlink" title="高级技巧 - HTML元素"></a>高级技巧 - HTML元素</h3><blockquote><p>支持HTML元素<br>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 &gt;HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等。<br><br>如这里看不到效果，说明此网站Markdown实现不支持插入HTML标签</p></blockquote><h3 id="高级技巧-转义"><a href="#高级技巧-转义" class="headerlink" title="高级技巧 - 转义"></a>高级技巧 - 转义</h3><blockquote><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Markdown支持对以下特殊符号的转义：</span><br><span class="line">\   反斜线</span><br><span class="line">&#96;   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure><h3 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h3><p>常见命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br><span class="line">缩写：</span><br><span class="line"></span><br><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br><span class="line">组合命令：</span><br><span class="line"></span><br><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><hr><blockquote><p>本文参考网站：</p></blockquote><ul><li><a href="https://juejin.im/post/6844904030389403655#heading-27">Markdown超详细使用说明</a></li><li><a href="https://blog.csdn.net/a1056244734/article/details/107381675">Markdown编辑器常用语法使用指南（CSDN通用）</a></li><li><a href="https://juejin.im/post/6844904018636963847#heading-25">Markdown上手指南）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要是怕自己记不住&lt;/p&gt;
&lt;h2 id=&quot;什么是Markdown&quot;&gt;&lt;a href=&quot;#什么是Markdown&quot; class=&quot;headerlink&quot; title=&quot;什么是Markdown&quot;&gt;&lt;/a&gt;什么是Markdown&lt;/h2&gt;&lt;p&gt;Markdown是一种轻量级标记语
      
    
    </summary>
    
    
      <category term="markdown" scheme="http://github.com/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://github.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>butterfly一些文章和页面配置</title>
    <link href="http://github.com/2020/08/05/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE/"/>
    <id>http://github.com/2020/08/05/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2020-08-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是butterfly的一些文章和页面配置，主要是方便本人查看，在这里存个记录</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="这个markdown文章的一些配置"><a href="#这个markdown文章的一些配置" class="headerlink" title="这个markdown文章的一些配置"></a>这个markdown文章的一些配置</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments：</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">auto<span class="emphasis">_open:</span></span><br><span class="line"><span class="emphasis">copyright:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author:</span><br><span class="line">copyright<span class="emphasis">_author_</span>href:</span><br><span class="line">copyright<span class="emphasis">_url:</span></span><br><span class="line"><span class="emphasis">copyright_</span>info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer：</span><br><span class="line">highlight<span class="emphasis">_shrink：</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">写法</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">【必需】文章标题</td></tr><tr><td align="left">date</td><td align="left">【必需】文章创建日期</td></tr><tr><td align="left">updated</td><td align="left">【可选】文章更新日期</td></tr><tr><td align="left">tags</td><td align="left">【可选】文章标籤</td></tr><tr><td align="left">categories</td><td align="left">【可选】文章分类</td></tr><tr><td align="left">keywords</td><td align="left">【可选】文章关键字</td></tr><tr><td align="left">description</td><td align="left">【可选】文章描述</td></tr><tr><td align="left">top_img</td><td align="left">【可选】文章顶部图片</td></tr><tr><td align="left">cover</td><td align="left">【可选】文章缩略图 (如果没有设置 top_img, 文章页顶部将显示缩略图，可设为 false / 图片地址 / 留空)</td></tr><tr><td align="left">comments</td><td align="left">【可选】显示文章评论模块 (默认 true)</td></tr><tr><td align="left">toc</td><td align="left">【可选】显示文章 TOC (默认为设置中 toc 的 enable 配置)</td></tr><tr><td align="left">toc_number</td><td align="left">【可选】显示 toc_number (默认为设置中 toc 的number 配置)</td></tr><tr><td align="left">auto_open</td><td align="left">【可选】是否自动打开 TOC (默认为设置中 toc 的 auto_open 配置)</td></tr><tr><td align="left">copyright</td><td align="left">【可选】显示文章版权模块 (默认为设置中 post_copyright 的 enable 配置)</td></tr><tr><td align="left">copyright_author</td><td align="left">【可选】文章版权模块的文章作者</td></tr><tr><td align="left">copyright_author_href</td><td align="left">【可选】文章版权模块的文章作者链接</td></tr><tr><td align="left">copyright_url</td><td align="left">【可选】文章版权模块的文章连结链接</td></tr><tr><td align="left">copyright_info</td><td align="left">【可选】文章版权模块的版权声明文字</td></tr><tr><td align="left">mathjax</td><td align="left">【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">katex</td><td align="left">【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">aplayer</td><td align="left">【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td></tr><tr><td align="left">highlight_shrink</td><td align="left">【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</td></tr></tbody></table><h3 id="页面的一些配置"><a href="#页面的一些配置" class="headerlink" title="页面的一些配置"></a>页面的一些配置</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer：</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink：</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">写法</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">【必需】页面标题</td></tr><tr><td align="left">date</td><td align="left">【必需】页面创建日期</td></tr><tr><td align="left">type</td><td align="left">【必需】标籤、分类和友情链接三个页面需要配置</td></tr><tr><td align="left">updated</td><td align="left">【可选】页面更新日期</td></tr><tr><td align="left">description</td><td align="left">【可选】页面描述</td></tr><tr><td align="left">keywords</td><td align="left">【可选】页面关键字</td></tr><tr><td align="left">comments</td><td align="left">【可选】显示页面评论模块 (默认 true)</td></tr><tr><td align="left">top_img</td><td align="left">【可选】页面顶部图片</td></tr><tr><td align="left">mathjax</td><td align="left">【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">katex</td><td align="left">【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">aside</td><td align="left">【可选】显示侧边栏 (默认 true)</td></tr><tr><td align="left">aplayer</td><td align="left">【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td></tr><tr><td align="left">highlight_shrink</td><td align="left">【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</td></tr></tbody></table><p><a href="https://demo.jerryc.me/posts/4aa8abbe/#Tabs">文章Markdown更多技巧</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是butterfly的一些文章和页面配置，主要是方便本人查看，在这里存个记录&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;h3 id=&quot;这个markdown文章的一些配置&quot;
      
    
    </summary>
    
    
      <category term="butterfly" scheme="http://github.com/categories/butterfly/"/>
    
    
      <category term="butterfly" scheme="http://github.com/tags/butterfly/"/>
    
  </entry>
  
</feed>
