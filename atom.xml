<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>覆水行舟的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2021-03-07T16:00:00.000Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>覆水行舟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试宝典之React篇</title>
    <link href="http://github.com/2021/03/08/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BReact%E7%AF%87/"/>
    <id>http://github.com/2021/03/08/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BReact%E7%AF%87/</id>
    <published>2021-03-07T16:00:00.000Z</published>
    <updated>2021-03-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对React面试 的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="暂无数据"><a href="#暂无数据" class="headerlink" title="暂无数据"></a>暂无数据</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对React面试 的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;暂无数据&quot;&gt;&lt;a href=&quot;#暂无数据&quot; class=&quot;headerlink&quot; title=&quot;暂无数据&quot;&gt;&lt;/a&gt;暂无数据&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="面试  React" scheme="http://github.com/categories/%E9%9D%A2%E8%AF%95-React/"/>
    
    
      <category term="面试  React" scheme="http://github.com/tags/%E9%9D%A2%E8%AF%95-React/"/>
    
  </entry>
  
  <entry>
    <title>面试宝典之VueAPI面试篇</title>
    <link href="http://github.com/2021/03/05/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVueAPI%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    <id>http://github.com/2021/03/05/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVueAPI%E9%9D%A2%E8%AF%95%E7%AF%87/</id>
    <published>2021-03-04T16:00:00.000Z</published>
    <updated>2021-03-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="v-show-和-v-if指令的共同点和不同点"><a href="#v-show-和-v-if指令的共同点和不同点" class="headerlink" title="v-show 和 v-if指令的共同点和不同点"></a>v-show 和 v-if指令的共同点和不同点</h2><p>共同点： 都能控制元素的显示和隐藏；</p><p>不同点：</p><ol><li><p>实现本质方法不同</p><ul><li>v-show： 本质就是通过控制 css 中的 display 设置为 none，控制隐藏，只会编译一次；</li><li>v-if： 是动态的向 DOM 树内添加或者删除 DOM 元素，若初始值为 false ，就不会编译了。而且 v-if 不停的销毁和创建比较消耗性能。</li></ul></li><li><p>总结<br>如果要频繁切换某节点，使用 v-show (切换开销比较小，初始开销较大)。如果不需要频繁切换某节点使用 v-if（初始渲染开销较小，切换开销比较大）。</p></li></ol><h2 id="为什么使用key-Key-的作用是什么？可以用数组的-index（下标）代替么？（美团）"><a href="#为什么使用key-Key-的作用是什么？可以用数组的-index（下标）代替么？（美团）" class="headerlink" title="为什么使用key? Key 的作用是什么？可以用数组的 index（下标）代替么？（美团）"></a>为什么使用key? Key 的作用是什么？可以用数组的 index（下标）代替么？（美团）</h2><p>使用 key 来给每个节点做一个唯一标识， Diff 算法就可以正确的识别此节点</p><ol><li>key 的作用主要是为了高效的更新虚拟 DOM。另外 vue 中在使用相同标签<br>名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以<br>区分它们。否则 vue 只会替换其内部属性而不会触发过渡效果</li><li>key 不能用 index 代替，index 在同一个页面会有重复的情况，违背了高效<br>渲染的初衷。</li></ol><h2 id="v-model中的实现原理及如何自定义v-model"><a href="#v-model中的实现原理及如何自定义v-model" class="headerlink" title="v-model中的实现原理及如何自定义v-model"></a>v-model中的实现原理及如何自定义<code>v-model</code></h2><ol><li><code>v-model</code> 可以看成是 <code>value</code>+<code>input</code> 方法的语法糖（组件）。</li><li>原生的 v-model ，会根据标签的不同生成不同的事件与属性。解析一个指令来。</li><li>自定义：自己写 <code>model</code> 属性，里面放上 <code>prop</code> 和 <code>event</code></li></ol><h2 id="如何让CSS只在当前组件中起作用"><a href="#如何让CSS只在当前组件中起作用" class="headerlink" title="如何让CSS只在当前组件中起作用?"></a>如何让CSS只在当前组件中起作用?</h2><p>在组件中的 style 前面加上 scoped</p><h2 id="请说出vue-cli项目中src目录每个文件夹和文件的用法"><a href="#请说出vue-cli项目中src目录每个文件夹和文件的用法" class="headerlink" title="请说出vue.cli项目中src目录每个文件夹和文件的用法"></a>请说出vue.cli项目中src目录每个文件夹和文件的用法</h2><ul><li>assets 文件夹是放静态资源；</li><li>components 是放组件；</li><li>router 是定义路由相关的配置;</li><li>app.vue 是一个应用主组件；</li><li>main.js 是入口文件。</li></ul><h2 id="vue组件中data为什么必须是一个函数"><a href="#vue组件中data为什么必须是一个函数" class="headerlink" title="vue组件中data为什么必须是一个函数"></a>vue组件中data为什么必须是一个函数</h2><p>避免组件中的数据互相影响。<br><br>因为组件是用来复用的，并且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离性，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p><h2 id="为什么要使用异步组件？"><a href="#为什么要使用异步组件？" class="headerlink" title="为什么要使用异步组件？"></a>为什么要使用异步组件？</h2><ol><li>节省打包出的结果，异步组件分开打包，采用 jsonp 的方式进行加载，有效解决文件过大的问题。</li><li>核心就是包组件定义变成一个函数，依赖 import（） 语法，可以实现文件的分割加载。</li></ol><h2 id="谈谈对-keep-alive-的了解"><a href="#谈谈对-keep-alive-的了解" class="headerlink" title="谈谈对 keep-alive 的了解"></a>谈谈对 keep-alive 的了解</h2><ol><li>keep-alive 是 Vue 内置的一个组件，可以实现组件的缓存，当组件切换时不会对当前组件进行卸载。</li><li>常用的 2 个属性 include/exclude，允许组件有条件的进行缓存 3. 2 个生命周期 activated ， deactivated，用来得知当前组件是否处于活跃状态。</li><li>keep-alive 的中还运用了 LRU(Least Recently Used)算法。</li></ol><h2 id="Computed-watch-和-method-简述computed和watch的使用场景"><a href="#Computed-watch-和-method-简述computed和watch的使用场景" class="headerlink" title="Computed watch 和 method, 简述computed和watch的使用场景"></a>Computed watch 和 method, 简述computed和watch的使用场景</h2><ul><li>computed：本质是一个具备缓存的 watcher，只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。适用于计算比较消耗性能的计算场景</li><li>watch:  没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用 watch。<br>深度监听&gt; deep：true,会带来性能问题, 优化的话可以使用字符串形式监听</li><li>method：只要把方法用到模板上了,每次一变化就会重新渲染视图，性能开销大</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>computed : 当一个属性受多个属性影响的时候就需要用到 computed <br>最典型的栗子：购物车商品结算的时候</li><li>watch : 当一条数据影响多条数据的时候就需要用 watch <br>栗子：搜索数据</li></ol><h2 id="v-if和v-for的优先级"><a href="#v-if和v-for的优先级" class="headerlink" title="v-if和v-for的优先级"></a>v-if和v-for的优先级</h2><p>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。所以，不推荐 v-if 和 v-for 同时使用。<br><br>如果 v-if 和 v-for 一起用的话，vue中的的会自动提示 v-if 应该放到外层去。</p><h2 id="assets和static的区别"><a href="#assets和static的区别" class="headerlink" title="assets和static的区别"></a>assets和static的区别</h2><ol><li><p>相同点<br>assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下</p></li><li><p>不相同点</p><ul><li>assets<br>assets中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。</li><li>static<br>static中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</li></ul></li><li><p>建议<br>将项目中 template需要的样式文件js文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css </code>等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传。</p></li></ol><h2 id="说出几种vue当中的指令和它的用法？"><a href="#说出几种vue当中的指令和它的用法？" class="headerlink" title="说出几种vue当中的指令和它的用法？"></a>说出几种vue当中的指令和它的用法？</h2><ul><li>v-model 双向数据绑定；</li><li>v-for 循环；</li><li>v-if v-show 显示与隐藏；</li><li>v-on 事件；v-once : 只绑定一次。</li></ul><h2 id="vue-loader是什么？使用它的用途有哪些？"><a href="#vue-loader是什么？使用它的用途有哪些？" class="headerlink" title="vue-loader是什么？使用它的用途有哪些？"></a>vue-loader是什么？使用它的用途有哪些？</h2><p>vue 文件的一个加载器，将 template/js/style 转换成 js 模块。</p><p>用途：js 可以写 es6 、 style样式可以 scss 或 less 、 template 可以加 jade等</p><h2 id="v-on可以监听多个方法"><a href="#v-on可以监听多个方法" class="headerlink" title="v-on可以监听多个方法"></a>v-on可以监听多个方法</h2><p>栗子：<code>&lt;input type=&quot;text&quot; v-on=&quot;&#123; input:onInput,focus:onFocus,blur:onBlur, &#125;&quot;&gt;</code></p><h2 id="了解-nextTick-吗？"><a href="#了解-nextTick-吗？" class="headerlink" title="了解 nextTick 吗？"></a>了解 nextTick 吗？</h2><p>在下次 DOM 更新循环结束之后执行延迟回调</p><p>Vue的nextTick其本质上是对JS执行原理EventLoop的一种应用</p><p>nextTick的核心应用：Promise、MutationObserver、setImmediate、setTimeout的原生JS的方法来模拟对应的微/宏任务的实现，本质时是为了利用JS的这些异步回调任务队列来实现Vue框架中自己的异步回调队列</p><p>nextTick不仅是Vue内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对DOM更新数据时的后续逻辑处理</p><p>nextTick是典型的将底层JS执行原理应用到具体案例中的示例</p><h2 id="nextTick的使用"><a href="#nextTick的使用" class="headerlink" title="$nextTick的使用"></a>$nextTick的使用</h2><p>当你修改了data 的值然后马上获取这个 dom 元素的值，是不能获取到更新后的值， 你需要使用 $nextTick 这个回调，让修改后的 data 值渲染更新到 dom 元素之后在获取，才能成功。</p><h2 id="v-html-会导致哪些问题"><a href="#v-html-会导致哪些问题" class="headerlink" title="v-html 会导致哪些问题"></a>v-html 会导致哪些问题</h2><ol><li>XSS 攻击</li><li>v-html 会替换标签内部的元素</li></ol><h2 id="vue常用的修饰符"><a href="#vue常用的修饰符" class="headerlink" title="vue常用的修饰符"></a>vue常用的修饰符</h2><ol><li><p>.stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；</p></li><li><p>.prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</p></li><li><p>.capture ：与事件冒泡的方向相反，事件捕获由外到内；</p></li><li><p>.self ：只会触发自己范围内的事件，不包含子元素；</p></li><li><p>.once ：只会触发一次</p></li></ol><h2 id="引进组件的步骤"><a href="#引进组件的步骤" class="headerlink" title="引进组件的步骤"></a>引进组件的步骤</h2><ol><li>在template中引入组件；</li><li>在script的第一行用import引入路径；</li><li>用component中写上组件名称。</li></ol><h2 id="delete和Vue-delete删除数组的区别"><a href="#delete和Vue-delete删除数组的区别" class="headerlink" title="delete和Vue.delete删除数组的区别"></a>delete和Vue.delete删除数组的区别</h2><p>delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。<br><br>Vue.delete 直接删除了数组 改变了数组的键值。</p><h2 id="vue-slot"><a href="#vue-slot" class="headerlink" title="vue slot"></a>vue slot</h2><p>简单来说，假如父组件需要在子组件内放一些DOM，那么这些DOM是显示、不显示、在哪个地方显示、如何显示，就是slot分发负责的活。</p><h2 id="插槽与作用域插槽的区别"><a href="#插槽与作用域插槽的区别" class="headerlink" title="插槽与作用域插槽的区别"></a>插槽与作用域插槽的区别</h2><ol><li><p>插槽</p><ul><li><p>创建组件虚拟节点时，会将组件儿子的虚拟节点保存起来。当初始化组件时，通过插槽属性将儿子进行分类 <code>&#123;a:[vnode],b[vnode]&#125;</code></p></li><li><p>渲染组件时会拿对应的 slot 属性的节点进行替换操作。（插槽的作用域为父组件）</p></li></ul></li><li><p>作用域插槽</p><ul><li><p>作用域插槽在解析的时候不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。</p></li><li><p>普通插槽渲染的作用域是父组件，作用域插槽的渲染作用域是当前子组件。</p></li></ul></li></ol><h2 id="slot是什么？有什么作用？原理是什么？"><a href="#slot是什么？有什么作用？原理是什么？" class="headerlink" title="slot是什么？有什么作用？原理是什么？"></a>slot是什么？有什么作用？原理是什么？</h2><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。<br>slot又分三类，默认插槽，具名插槽和作用域插槽。</p><p>默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。<br>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。<br>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</p><p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h2 id="请说下封装-vue-组件的过程？"><a href="#请说下封装-vue-组件的过程？" class="headerlink" title="请说下封装 vue 组件的过程？"></a>请说下封装 vue 组件的过程？</h2><ol><li><p>建立组件的模板，先把架子搭起来，写写样式，考虑好组件的基本逻辑。(os：思考1小时，码码10分钟，程序猿的准则。) 　　</p></li><li><p>准备好组件的数据输入。即分析好逻辑，定好 props 里面的数据、类型。　　</p></li><li><p>准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法。　　</p></li><li><p>封装完毕了，直接调用即可</p></li></ol><h2 id="vue-中相同逻辑如何抽离"><a href="#vue-中相同逻辑如何抽离" class="headerlink" title="vue 中相同逻辑如何抽离"></a>vue 中相同逻辑如何抽离</h2><p>考察 vue.mixin 用法，给组件每个生命周期，函数都混入一些公共逻辑</p><h2 id="vue修改打包后静态资源路径的修改"><a href="#vue修改打包后静态资源路径的修改" class="headerlink" title="vue修改打包后静态资源路径的修改"></a>vue修改打包后静态资源路径的修改</h2><p>cli2 版本：将 config/index.js 里的 assetsPublicPath 的值改为  ./  。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build: &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  assetsPublicPath:  .&#x2F; ,</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cli3版本：在根目录下新建vue.config.js 文件，然后加上以下内容：（如果已经有此文件就直接修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  publicPath: , &#x2F;&#x2F; 相对于 HTML 页面（目录相同）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="那template和jsx的有什么分别？"><a href="#那template和jsx的有什么分别？" class="headerlink" title="那template和jsx的有什么分别？"></a>那template和jsx的有什么分别？</h2><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。<br>在 webpack 中，我们使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。<br>与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。<br>所以，template和jsx的都是render的一种表现形式，不同的是：<br>JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p><h2 id="什么是-vue-生命周期？有什么作用？"><a href="#什么是-vue-生命周期？有什么作用？" class="headerlink" title="什么是 vue 生命周期？有什么作用？"></a>什么是 vue 生命周期？有什么作用？</h2><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会。（ps：生命周期钩子就是生命周期函数）例如，如果要通过某些插件操作DOM节点，如想在页面渲染完后弹出广告窗， 那我们最早可在mounted 中进行。</p><h2 id="第一次页面加载会触发哪几个钩子？"><a href="#第一次页面加载会触发哪几个钩子？" class="headerlink" title="第一次页面加载会触发哪几个钩子？"></a>第一次页面加载会触发哪几个钩子？</h2><p>答：beforeCreate， created， beforeMount， mounted</p><h2 id="介绍一下Vue的生命周期"><a href="#介绍一下Vue的生命周期" class="headerlink" title="介绍一下Vue的生命周期"></a>介绍一下Vue的生命周期</h2><ol><li>beforeCreate：是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。</li><li>created：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</li><li>beforeMount：发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。</li><li>mounted：在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。</li><li>beforeUpdate：发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</li><li>updated：发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</li><li>beforeDestroy：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</li><li>destroyed：发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</li></ol><h2 id="组件之间是怎么通信的"><a href="#组件之间是怎么通信的" class="headerlink" title="组件之间是怎么通信的"></a>组件之间是怎么通信的</h2><ol><li>父子组件通信</li></ol><p>父组件 -&gt; 子组件：prop<br>子组件 -&gt; 父组件：$on/$emit<br>获取组件实例：使用$parent/$children，$refs.xxx，获取到实例后直接获取属性数据或调用组件方法</p><ol start="2"><li>兄弟组件通信</li></ol><p>Event Bus：每一个Vue实例都是一个Event Bus，都支持$on/$emit，可以为兄弟组件的实例之间new一个Vue实例，作为Event Bus进行通信。<br>Vuex：将状态和方法提取到Vuex，完成共享</p><ol start="3"><li>跨级组件通信</li></ol><p>使用provide/inject<br>provide / inject 适用于 隔代组件通信 祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。<br>。</p><ol start="4"><li>attrs/listeners 适用于 隔代组件通信</li></ol><p>attrs: 包含了父作用域中不被prop所识别(且获取)的特性绑定(class和style除外)。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定(class和style除外)，并且可以通过v−bind=”attrs:包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过v-bind=”attrs:包含了父作用域中不被prop所识别(且获取)的特性绑定(class和style除外)。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定(class和style除外)，并且可以通过v−bind=”attrs”传入内部组件。通常配合inheritAttrs选项一起使用。</p><p>listeners: 包含了父作用域中的(不含.native修饰器的)v−on事件监听器。它可以通过v−on=”listeners:包含了父作用域中的 (不含 .native 修饰器的) v-on事件监听器。它可以通过v-on=”listeners:包含了父作用域中的(不含.native修饰器的)v−on事件监听器。它可以通过v−on=”listeners”传入内部组件</p><p>Vuex 适用于 父子、隔代、兄弟组件通信。Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p><h2 id="说一下Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#说一下Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="说一下Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>说一下Vue 的父组件和子组件生命周期钩子函数执行顺序？</h2><p>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。<br>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p><ol><li><p>加载渲染过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</span><br></pre></td></tr></table></figure></li><li><p>子组件更新过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</span><br></pre></td></tr></table></figure></li><li><p>父组件更新过程<br><code>父 beforeUpdate -&gt; 父 updated</code></p></li><li><p>销毁过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</span><br></pre></td></tr></table></figure><h2 id="子组件可以直接改变父组件的数据么？说说你的理由？"><a href="#子组件可以直接改变父组件的数据么？说说你的理由？" class="headerlink" title="子组件可以直接改变父组件的数据么？说说你的理由？"></a>子组件可以直接改变父组件的数据么？说说你的理由？</h2></li></ol><p>主要是为了维护父子组件的单向数据流</p><p>每次父组件发生更新时，子组件中所有的prop都将会刷新为最新的值<br>如果这样做的话，Vue会在浏览器控制台中发出警告<br>Vue提倡单向数据流，即父级props的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件的状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破环了单向数据流，当应用复杂情况时，debug的成本会非常高<br>只有通过$emit派发一个自定义事件，父组件接收后，由父组件修改.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;v-show-和-v-if指令的共同点和不同点&quot;&gt;&lt;a href=&quot;#v-show-和-v-if指令的共同点和不同点&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="面试 Vue" scheme="http://github.com/categories/%E9%9D%A2%E8%AF%95-Vue/"/>
    
    
      <category term="面试 Vue" scheme="http://github.com/tags/%E9%9D%A2%E8%AF%95-Vue/"/>
    
  </entry>
  
  <entry>
    <title>面试宝典之Vue路由&amp;vuex面试篇</title>
    <link href="http://github.com/2021/03/04/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVue%E8%B7%AF%E7%94%B1&amp;vuex%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    <id>http://github.com/2021/03/04/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVue%E8%B7%AF%E7%94%B1&amp;vuex%E9%9D%A2%E8%AF%95%E7%AF%87/</id>
    <published>2021-03-03T16:00:00.000Z</published>
    <updated>2021-03-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h2><h3 id="vue-router的原理"><a href="#vue-router的原理" class="headerlink" title="vue-router的原理"></a>vue-router的原理</h3><p>实现原理：vue-router的原理就是更新视图而不重新请求页面</p><h3 id="vue-router-是什么-它有哪些组件"><a href="#vue-router-是什么-它有哪些组件" class="headerlink" title="vue-router 是什么?它有哪些组件"></a>vue-router 是什么?它有哪些组件</h3><p>vue用来写路由一个插件。router-link、router-view</p><h3 id="active-class-是哪个组件的属性？"><a href="#active-class-是哪个组件的属性？" class="headerlink" title="active-class 是哪个组件的属性？"></a>active-class 是哪个组件的属性？</h3><p>vue-router模块的router-link组件。children数组来定义子路由</p><h3 id="怎么定义-vue-router-的动态路由-怎么获取传过来的值？"><a href="#怎么定义-vue-router-的动态路由-怎么获取传过来的值？" class="headerlink" title="怎么定义 vue-router 的动态路由? 怎么获取传过来的值？"></a>怎么定义 vue-router 的动态路由? 怎么获取传过来的值？</h3><p>在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id。</p><h3 id="vue-router-有哪几种导航钩子"><a href="#vue-router-有哪几种导航钩子" class="headerlink" title="vue-router 有哪几种导航钩子?"></a>vue-router 有哪几种导航钩子?</h3><ol><li><p>全局的钩子函数 beforeEach 和 afterEach</p><p> beforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数</p></li><li><p>单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的</p></li><li><p>组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组件内部直接进行定义的</p></li></ol><h3 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和 $router 的区别"></a><code>$route</code> 和 <code>$router</code> 的区别</h3><ol><li><p>$router 是VueRouter的实例，在script标签中想要导航到不同的URL,使用 $router.push 方法。返回上一个历史history用 $router.to(-1)</p></li><li><p>$route 为当前router跳转对象。里面可以获取当前路由的name,path,query,parmas等。</p></li></ol><h3 id="vue-router的两种模式"><a href="#vue-router的两种模式" class="headerlink" title="vue-router的两种模式"></a>vue-router的两种模式</h3><ol><li><p>hash模式： 即地址栏 URL 中的 # 符号；</p></li><li><p>history模式： window.history对象打印出来可以看到里边提供的方法和记录长度。利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）。</p></li></ol><h3 id="能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h3><h3 id="hash模式的实现原理"><a href="#hash模式的实现原理" class="headerlink" title="hash模式的实现原理"></a>hash模式的实现原理</h3><ol><li><p>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；</p></li><li><p>使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值。我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）</p><h3 id="history-模式的实现原理"><a href="#history-模式的实现原理" class="headerlink" title="history 模式的实现原理"></a>history 模式的实现原理</h3><p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.replaceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录.<br>使用 popstate 事件来监听 url 的变化，从而对页面进行跳转(渲染)<br>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）</p></li></ol><h3 id="vue-router实现路由懒加载（-动态加载路由-）"><a href="#vue-router实现路由懒加载（-动态加载路由-）" class="headerlink" title="vue-router实现路由懒加载（ 动态加载路由 ）"></a>vue-router实现路由懒加载（ 动态加载路由 ）</h3><p>答:三种方式</p><p>第一种： vue异步组件技术 ==== 异步加载，vue-router配置路由 , 使用vue的异步组件技术 , 可以实现按需加载 .但是,这种情况下一个组件生成一个js文件。</p><p>第二种： 路由懒加载(使用import)。</p><p>第三种： webpack提供的require.ensure()，vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p><h3 id="params和query的区别"><a href="#params和query的区别" class="headerlink" title=".params和query的区别"></a>.params和query的区别</h3><p>答：用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 this.$route.query.name 和 this.$route.params.name 。url地址显示：query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p><p>注意点：query刷新不会丢失query里面的数据 params刷新 会 丢失 params里面的数据。</p><h2 id="RouterLink在IE和Firefox中不起作用（路由不跳转）的问题"><a href="#RouterLink在IE和Firefox中不起作用（路由不跳转）的问题" class="headerlink" title="RouterLink在IE和Firefox中不起作用（路由不跳转）的问题"></a>RouterLink在IE和Firefox中不起作用（路由不跳转）的问题</h2><p>方法一：只用a标签，不适用button标签；方法二：使用button标签和Router.navigate方法</p><h2 id="Vue2中注册在router-link上事件无效解决方法"><a href="#Vue2中注册在router-link上事件无效解决方法" class="headerlink" title="Vue2中注册在router-link上事件无效解决方法"></a>Vue2中注册在router-link上事件无效解决方法</h2><p>使用 @click.native 。原因：router-link会阻止click事件，.native指直接监听一个原生事件。</p><h2 id="Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？"><a href="#Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？" class="headerlink" title="Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？"></a>Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？</h2><p>Vue路由在Android机上有问题，babel问题，安装babel polypill插件解决。</p><h2 id="Vue-router跳转和location-href有什么区别"><a href="#Vue-router跳转和location-href有什么区别" class="headerlink" title="Vue-router跳转和location.href有什么区别"></a>Vue-router跳转和location.href有什么区别</h2><p>使用 location.href= /url 来跳转，简单方便，但是刷新了页面；使用 history.pushState( /url ) ，无刷新页面，静态跳转；引进 router ，然后使用 router.push( /url ) 来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 history.pushState() 没什么差别的，因为vue-router就是用了 history.pushState() ，尤其是在history模式下。</p><h2 id="vuex常见面试题篇"><a href="#vuex常见面试题篇" class="headerlink" title="vuex常见面试题篇"></a>vuex常见面试题篇</h2><h3 id="vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex是什么？怎么使用？哪种功能场景使用它？"></a>vuex是什么？怎么使用？哪种功能场景使用它？</h3><p>vue框架中状态管理。在main.js引入store，注入。</p><p>新建了一个目录<code>store.js</code>，<code>….. export</code> 。</p><p>场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p><h3 id="vuex有哪几种属性？"><a href="#vuex有哪几种属性？" class="headerlink" title="vuex有哪几种属性？"></a>vuex有哪几种属性？</h3><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p><p>state =&gt; 基本数据(数据源存放地)</p><p>getters =&gt; 从基本数据派生出来的数据</p><p>mutations =&gt; (同步)提交更改数据的方法，修改state的,并且修改state的唯一途径就是提交mutation mutation中定义一系列方法，对state进行修改</p><p>actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。</p><p>modules =&gt; 模块化Vuex</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>Vuex 中说白了，任何的操作都是围绕 state 来进行的，Vuex 是状态管理器，作用就是管理 state 中的状态，其他提供的所有功能 Getter、Mutation、Action 都是为了能够更好的管理 state，而之所以设计成期望通过 Mutation 改变状态，是因为我们期望所有状态的变化都是有迹可循的！</p><h3 id="Vue-js中ajax请求代码应该写在组件的methods中还是vuex的actions中？"><a href="#Vue-js中ajax请求代码应该写在组件的methods中还是vuex的actions中？" class="headerlink" title="Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？"></a>Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？</h3><p>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</p><p>如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;vue路由&quot;&gt;&lt;a href=&quot;#vue路由&quot; class=&quot;headerlink&quot; title=&quot;vue路由&quot;&gt;&lt;/a&gt;vue路由&lt;/h2&gt;&lt;h
      
    
    </summary>
    
    
      <category term="面试 Vue" scheme="http://github.com/categories/%E9%9D%A2%E8%AF%95-Vue/"/>
    
    
      <category term="面试 Vue" scheme="http://github.com/tags/%E9%9D%A2%E8%AF%95-Vue/"/>
    
  </entry>
  
  <entry>
    <title>面试宝典之Vue原理面试篇</title>
    <link href="http://github.com/2021/03/02/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVue%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    <id>http://github.com/2021/03/02/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVue%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E7%AF%87/</id>
    <published>2021-03-01T16:00:00.000Z</published>
    <updated>2021-03-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><blockquote><p>Vue 借鉴了 angular 的模板和数据绑定技术，又借鉴了 react 的组件化和虚拟 DOM 技术</p></blockquote><h2 id="首先谈谈你对-Vue-的理解"><a href="#首先谈谈你对-Vue-的理解" class="headerlink" title="首先谈谈你对 Vue 的理解"></a>首先谈谈你对 Vue 的理解</h2><ul><li><p>渐进式 JavaScript 框架、核心库加插件、动态创建用户界面（异步获取后台数据，数据展示在界面）</p></li><li><p>特点： MVVM 模式；代码简洁体积小，运行效率高，适合移动 PC 端开发；本身只关注 UI （和 react 相似），可以轻松引入 Vue 插件或其他的第三方库进行开发。</p></li></ul><h2 id="渐进式框架的理解"><a href="#渐进式框架的理解" class="headerlink" title="渐进式框架的理解"></a>渐进式框架的理解</h2><ul><li>主张最少；</li><li>可以根据不同的需求选择不同的层级；</li></ul><h2 id="vue优点"><a href="#vue优点" class="headerlink" title="vue优点"></a>vue优点</h2><ul><li><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；</p></li><li><p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p></li><li><p>双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；</p></li><li><p>组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；</p></li><li><p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p></li><li><p>虚拟DOM：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；</p></li><li><p>运行速度更快：相比较于 react 而言，同样是操作虚拟 dom ，就性能而言， vue 存在很大的优势</p></li></ul><h2 id="说下MVVM"><a href="#说下MVVM" class="headerlink" title="说下MVVM"></a>说下MVVM</h2><p>全称：Model-View-ViewModel ，<br>Model 表示数据模型层。view 表示视图层， ViewModel 是 View 和 Model 层的桥梁，数据绑定到 viewModel 层并自动渲染到页面中，视图变化通知 viewModel 层更新数据。</p><h2 id="vue和jQuery的区别"><a href="#vue和jQuery的区别" class="headerlink" title="vue和jQuery的区别"></a>vue和jQuery的区别</h2><p>jQuery是使用选择器（ $ ）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。<br>比如需要获取label标签的内容：$(“lable”).val(); ,它还是依赖DOM元素的值。Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。</p><h2 id="介绍一下Vue的响应式系统"><a href="#介绍一下Vue的响应式系统" class="headerlink" title="介绍一下Vue的响应式系统"></a>介绍一下Vue的响应式系统</h2><p>vue为MVVM框架，当数据模型data变化时，页面视图会得到响应更新，其原理对data的getter/setter方法进行拦截（Object.defineProperty或者Proxy），利用发布订阅的设计模式，在getter方法中进行订阅，在setter方法中发布通知，让所有订阅者完成响应。</p><h2 id="vue的两个核心点"><a href="#vue的两个核心点" class="headerlink" title="vue的两个核心点"></a>vue的两个核心点</h2><p>数据驱动、组件系统</p><p>数据驱动： ViewModel，保证数据和视图的一致性。<br><br>组件系统： 应用类UI可以看作全部是由组件树构成的。</p><h2 id="vue-的双向绑定的原理"><a href="#vue-的双向绑定的原理" class="headerlink" title="vue 的双向绑定的原理"></a>vue 的双向绑定的原理</h2><p>数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。<br><br>通过ES5提供的Object.defineProperty()方法来劫持(监视)各个属性的setter,getter，在数据变动的时发布消息给订阅者，触发相应的监听回调。并且，由于是在不同的数据上触发同步，可以精确的将变更发送发送给绑定的视图，而不是对所有的数据都执行一次检测。</p><h3 id="具体实现流程："><a href="#具体实现流程：" class="headerlink" title="具体实现流程："></a>具体实现流程：</h3><ol><li>实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者</li><li>实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图</li><li>接着，我们还需要实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</li></ol><h2 id="vue-是如何实现响应式数据"><a href="#vue-是如何实现响应式数据" class="headerlink" title="vue 是如何实现响应式数据"></a>vue 是如何实现响应式数据</h2><p>Vue2：Object.definProperty 重新定义 data 中所有的属性， Object.definProperty 可以使数据的获取与设置增加一个拦截的功能，拦截属性的获取，进行依赖收集。拦截属性的更新操作，进行通知。具体的过程：首先 Vue 使用 initData 初始化用户传入的参数，然后使用 new Observer 对数据进行观测，如果数据是一个对象类型就会调用 this.walk（value） 对对象进行处理，内部使用 defineReactive 循环对象属性定义响应式变化，核心就是使用 Object.definProperty 重新定义数据。</p><p>vue3: Proxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。</p><p>d) Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><h2 id="vue-中是如何检测数组变化"><a href="#vue-中是如何检测数组变化" class="headerlink" title="vue 中是如何检测数组变化"></a>vue 中是如何检测数组变化</h2><p>数组就是使用 object.defineProperty 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的， pop 、 push 、 shift 、 unshift 、 splice 、 sort 、 reverse 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解。</p><p>使用了函数劫持的方式，重写了数组的方法，Vue 将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法。</p><p>这样当调用数组 api 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p><h2 id="监测数组的时候可能触发多次-get-set，那么如何防止触发多次呢？"><a href="#监测数组的时候可能触发多次-get-set，那么如何防止触发多次呢？" class="headerlink" title="监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？"></a>监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？</h2><p>我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。</p><h2 id="Vue事件绑定原理说一下"><a href="#Vue事件绑定原理说一下" class="headerlink" title="Vue事件绑定原理说一下"></a>Vue事件绑定原理说一下</h2><p>每一个Vue实例都是一个Event Bus，当子组件被创建的时候，父组件将事件传递给子组件，子组件初始化的时候是有$on方法将事件注册到内部，在需要的时候使用$emit触发函数，而对于原生native事件，使用addEventListener绑定到真实的DOM元素上。</p><h2 id="你说说-Vue-的事件绑定原理吧"><a href="#你说说-Vue-的事件绑定原理吧" class="headerlink" title="你说说 Vue 的事件绑定原理吧"></a>你说说 Vue 的事件绑定原理吧</h2><p>原生 DOM 的绑定：Vue 在创建真实 DOM 时会调用 createElm ，默认会调用 invokeCreateHooks 。会遍历当前平台下相对的属性处理代码，其中就有 updateDOMLListeners 方法，内部会传入 add（） 方法。</p><p>原生事件绑定是通过 addEventListener 绑定给真实元素的,组件事件绑定是通过 Vue 自定义的$on 实现的。</p><h2 id="vue-采用异步渲染呢？"><a href="#vue-采用异步渲染呢？" class="headerlink" title="vue 采用异步渲染呢？"></a>vue 采用异步渲染呢？</h2><p>Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 nextTick 。dep.notify（） 通知 watcher 进行更新， subs[i].update 依次调用 watcher 的 update ， queueWatcher 将 watcher 去重放入队列， nextTick（ flushSchedulerQueue ）在下一 tick 中刷新 watcher 队列（异步）。</p><h2 id="为什么要使用异步组件？"><a href="#为什么要使用异步组件？" class="headerlink" title="为什么要使用异步组件？"></a>为什么要使用异步组件？</h2><ol><li>节省打包出的结果，异步组件分开打包，采用 jsonp 的方式进行加载，有效解决文件过大的问题。</li><li>核心就是包组件定义变成一个函数，依赖 import（） 语法，可以实现文件的分割加载。</li></ol><h2 id="如何从真实-DOM-到虚拟-DOM"><a href="#如何从真实-DOM-到虚拟-DOM" class="headerlink" title="如何从真实 DOM 到虚拟 DOM"></a>如何从真实 DOM 到虚拟 DOM</h2><p>涉及到 Vue 中的模板编译原理，主要过程：</p><ol><li><p>将模板转换成 ast 树， ast 用对象来描述真实的 JS 语法（将真实 DOM 转换成虚拟 DOM）</p></li><li><p>优化树</p></li><li><p>将 ast 树生成代码</p></li></ol><h2 id="用-VNode-来描述一个-DOM-结构"><a href="#用-VNode-来描述一个-DOM-结构" class="headerlink" title="用 VNode 来描述一个 DOM 结构"></a>用 VNode 来描述一个 DOM 结构</h2><p>虚拟节点就是用一个对象来描述一个真实的 DOM 元素。首先将 template （真实 DOM）先转成 ast ， ast 树通过 codegen 生成 render 函数， render 函数里的 _c 方法将它转为虚拟 dom</p><h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><p>时间复杂度： 个树的完全 diff 算法是一个时间复杂度为 O(n*3） ，vue 进行优化转化成 O(n) 。理解：</p><p>最小量更新， key 很重要。这个可以是这个节点的唯一标识，告诉 diff 算法，在更改前后它们是同一个 DOM 节点</p><p>扩展 v-for 为什么要有 key ，没有 key 会暴力复用，举例子的话随便说一个比如移动节点或者增加节点（修改 DOM），加 key 只会移动减少操作 DOM。<br>只有是同一个虚拟节点才会进行精细化比较，否则就是暴力删除旧的，插入新的。</p><p>只进行同层比较，不会进行跨层比较。</p><p>diff 算法的优化策略：四种命中查找，四个指针</p><p>旧前与新前（先比开头，后插入和删除节点的这种情况）</p><p>旧后与新后（比结尾，前插入或删除的情况）</p><p>旧前与新后（头与尾比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧后之后）</p><p>旧后与新前（尾与头比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧前之前）</p><h2 id="Vue模板渲染的原理是什么？"><a href="#Vue模板渲染的原理是什么？" class="headerlink" title="Vue模板渲染的原理是什么？"></a>Vue模板渲染的原理是什么？</h2><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。<br>模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p><p>parse阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。<br>optimize阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。<br>generate阶段：将最终的AST转化为render函数字符串。</p><h2 id="template预编译是什么？"><a href="#template预编译是什么？" class="headerlink" title="template预编译是什么？"></a>template预编译是什么？</h2><p>对于 Vue 组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后在也不会进行编译。因此，编译对组件的 runtime 是一种性能损耗。<br>而模板编译的目的仅仅是将template转化为render function，这个过程，正好可以在项目构建的过程中完成，这样可以让实际组件在 runtime 时直接跳过模板渲染，进而提升性能，这个在项目构建的编译template的过程，就是预编译。<br>那template和jsx的有什么分别？<br>对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。<br>在 webpack 中，我们使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。<br>与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。<br>所以，template和jsx的都是render的一种表现形式，不同的是：<br>JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。<br>说一下什么是Virtual DOM<br>Virtual DOM 是 DOM 节点在 JavaScript 中的一种抽象数据结构，之所以需要虚拟DOM，是因为浏览器中操作DOM的代价比较昂贵，频繁操作DOM会产生性能问题。虚拟DOM的作用是在每一次响应式数据发生变化引起页面重渲染时，Vue对比更新前后的虚拟DOM，匹配找出尽可能少的需要更新的真实DOM，从而达到提升性能的目的。</p><h2 id="介绍一下Vue中的Diff算法"><a href="#介绍一下Vue中的Diff算法" class="headerlink" title="介绍一下Vue中的Diff算法"></a>介绍一下Vue中的Diff算法</h2><p>在新老虚拟DOM对比时</p><p>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换<br>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)<br>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。<br>匹配时，找到相同的子节点，递归比较子节点</p><p>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n^3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p><h2 id="说说Vue2-0和Vue3-0有什么区别"><a href="#说说Vue2-0和Vue3-0有什么区别" class="headerlink" title="说说Vue2.0和Vue3.0有什么区别"></a>说说Vue2.0和Vue3.0有什么区别</h2><p>重构响应式系统，使用Proxy替换Object.defineProperty，使用Proxy优势：</p><p>可直接监听数组类型的数据变化<br>监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升<br>可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行<br>直接实现对象属性的新增/删除</p><p>新增Composition API，更好的逻辑复用和代码组织<br>重构 Virtual DOM</p><p>模板编译时的优化，将一些静态节点编译成常量<br>slot优化，将slot编译为lazy函数，将slot的渲染的决定权交给子组件<br>模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）</p><p>代码结构调整，更便于Tree shaking，使得体积更小<br>使用Typescript替换Flow</p><h2 id="为什么要新增Composition-API，它能解决什么问题"><a href="#为什么要新增Composition-API，它能解决什么问题" class="headerlink" title="为什么要新增Composition API，它能解决什么问题"></a>为什么要新增Composition API，它能解决什么问题</h2><p>Vue2.0中，随着功能的增加，组件变得越来越复杂，越来越难维护，而难以维护的根本原因是Vue的API设计迫使开发者使用watch，computed，methods选项组织代码，而不是实际的业务逻辑。<br>另外Vue2.0缺少一种较为简洁的低成本的机制来完成逻辑复用，虽然可以minxis完成逻辑复用，但是当mixin变多的时候，会使得难以找到对应的data、computed或者method来源于哪个mixin，使得类型推断难以进行。<br>所以Composition API的出现，主要是也是为了解决Option API带来的问题，第一个是代码组织问题，Compostion API可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性，也就是说当下一个开发者接触这一段不是他自己写的代码时，他可以更好的利用代码的组织反推出实际的业务逻辑，或者根据业务逻辑更好的理解代码。<br>第二个是实现代码的逻辑提取与复用，当然mixin也可以实现逻辑提取与复用，但是像前面所说的，多个mixin作用在同一个组件时，很难看出property是来源于哪个mixin，来源不清楚，另外，多个mixin的property存在变量命名冲突的风险。而Composition API刚好解决了这两个问题。</p><h2 id="都说Composition-API与React-Hook很像，说说区别"><a href="#都说Composition-API与React-Hook很像，说说区别" class="headerlink" title="都说Composition API与React Hook很像，说说区别"></a>都说Composition API与React Hook很像，说说区别</h2><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p><p>不能在循环、条件、嵌套函数中调用Hook<br>必须确保总是在你的React函数的顶层调用Hook<br>useEffect、useMemo等函数必须手动确定依赖关系</p><p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p><p>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢<br>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用<br>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</p><p>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p><h2 id="SSR有了解吗？原理是什么？"><a href="#SSR有了解吗？原理是什么？" class="headerlink" title="SSR有了解吗？原理是什么？"></a>SSR有了解吗？原理是什么？</h2><p>在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且在服务器内部将Vue组件渲染成HTML，并且将数据、HTML一并返回给客户端，这个在服务器将数据和组件转化为HTML的过程，叫做服务端渲染SSR。<br>而当客户端拿到服务器渲染的HTML和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者Vuex内部即可。除了数据意外，HTML也结构已经有了，客户端在渲染组件的时候，也只需要将HTML的DOM节点映射到Virtual DOM即可，不需要重新创建DOM节点，这个将数据和HTML同步的过程，又叫做客户端激活。<br>使用SSR的好处：</p><p>有利于SEO：其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行JavaScript的，这种不支持执行JavaScript的爬虫抓取到的非SSR的页面会是一个空的HTML页面，而有了SSR以后，这些爬虫就可以获取到完整的HTML结构的数据，进而收录到搜索引擎中。</p><p>白屏时间更短：相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。</p><h2 id="为什么要用-Proxy-API-替代-defineProperty-API？"><a href="#为什么要用-Proxy-API-替代-defineProperty-API？" class="headerlink" title="为什么要用 Proxy API 替代 defineProperty API？"></a>为什么要用 Proxy API 替代 defineProperty API？</h2><p>a) defineProperty 的局限性的最大原因是它只能针对单例属性做监听，Vue2.x中对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。<br>这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因。<br>b) 在Vue 中使用下标的方式直接修改属性的值或者添加一个预先不存在的对<br>象属性是无法做到 setter 监听的，这是 defineProperty 的局限性。<br>c) Proxy 的监听是针对一个对象的，那么对这个对象的所有操作会进入监听<br>操作，这就完全可以代理所有属性，将会带来很大的性能提升和更优的代<br>码。<br>d) Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访<br>问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进<br>行过滤和改写。</p><ol start="2"><li>响应式是惰性的<br>a) 在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的<br>变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对<br>象数据都变成响应式的，这无疑会有很大的性能消耗。<br>b) 在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变<br>化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正<br>访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减<br>少性能消耗。</li></ol><h2 id="Vue3-0-编译做了哪些优化？"><a href="#Vue3-0-编译做了哪些优化？" class="headerlink" title="Vue3.0 编译做了哪些优化？"></a>Vue3.0 编译做了哪些优化？</h2><p>a) 生成 block tree<br>i. Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部<br>需要遍历该组件的整个 vnode 树。<br>ii. Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了 Block<br>tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个<br>区块内部的节点结构是固定的。每个区块只需要追踪自身包含的动态节<br>点。</p><h2 id="slot-编译优化"><a href="#slot-编译优化" class="headerlink" title="slot 编译优化"></a>slot 编译优化</h2><p>i. Vue.js 2.x 中，如果有一个组件传入了 slot，那么每次父组件更新的时候，<br>会强制使子组件 update，造成性能的浪费。<br>ii. Vue.js 3.0 优化了 slot 的生成，使得非动态 slot 中属性的更新只会触发子<br>组件的更新。动态 slot 指的是在 slot 上面使用 v-if，v-for，动态 slot 名字<br>等会导致 slot 产生运行时动态变化但是又无法被子组件 track 的操作。</p><h2 id="Vue-性能优化"><a href="#Vue-性能优化" class="headerlink" title="Vue 性能优化"></a>Vue 性能优化</h2><h3 id="代码层面的优化"><a href="#代码层面的优化" class="headerlink" title="代码层面的优化"></a>代码层面的优化</h3><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch 区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li></ul><h3 id="Webpack-层面的优化"><a href="#Webpack-层面的优化" class="headerlink" title="Webpack 层面的优化"></a>Webpack 层面的优化</h3><ul><li>Webpack 对图片进行压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li></ul><h3 id="基础的-Web-技术的优化"><a href="#基础的-Web-技术的优化" class="headerlink" title="基础的 Web 技术的优化"></a>基础的 Web 技术的优化</h3><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul><h2 id="单页面应用和多页面应用区别及优缺点"><a href="#单页面应用和多页面应用区别及优缺点" class="headerlink" title="单页面应用和多页面应用区别及优缺点"></a>单页面应用和多页面应用区别及优缺点</h2><p>答：单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。</p><p>多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新</p><p>单页面的优点：用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。</p><p>单页面缺点：不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。</p><h2 id="SPA首屏加载慢如何解决"><a href="#SPA首屏加载慢如何解决" class="headerlink" title="SPA首屏加载慢如何解决"></a>SPA首屏加载慢如何解决</h2><p>答：安装动态懒加载所需插件；使用CDN资源。</p><h2 id="Proxy-只会代理对象的第一层，那么-Vue3-又是怎样处理这个问题的呢？"><a href="#Proxy-只会代理对象的第一层，那么-Vue3-又是怎样处理这个问题的呢？" class="headerlink" title="Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？"></a>Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？</h2><p>判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测。</p><h2 id="Vue-模版编译原理知道吗，能简单说一下吗？"><a href="#Vue-模版编译原理知道吗，能简单说一下吗？" class="headerlink" title="Vue 模版编译原理知道吗，能简单说一下吗？"></a>Vue 模版编译原理知道吗，能简单说一下吗？</h2><p>简单说，Vue 的编译过程就是将 template 转化为 render 函数的过程。会经历以下阶段：</p><p>生成 AST 树</p><p>优化</p><p>codegen</p><p>首先解析模版，生成 AST 语法树(一种用 JavaScript 对象的形式来描述整个模板)。使用大量的正则表达式对模板进行解析，</p><p>遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p><p>Vue 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 DOM 也不会变化。</p><p>那么优化过程就是深度遍历 AST 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p><p>编译的最后一步是将优化后的 AST 树转换为可执行的代码。</p><h2 id="Vue2-x-和-Vue3-x-渲染器的-diff-算法分别说一下"><a href="#Vue2-x-和-Vue3-x-渲染器的-diff-算法分别说一下" class="headerlink" title="Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下"></a>Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下</h2><p>简单来说，diff 算法有以下过程</p><p>同级比较，再比较子节点</p><p>先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)</p><p>比较都有子节点的情况(核心 diff)</p><p>递归比较子节点</p><p>正常 Diff 两个树的时间复杂度是 O(n^3)，但实际情况下我们很少会进行跨层级的移动 DOM，所以 Vue 将 Diff 进行了优化，从 O(n^3) -&gt; O(n)，</p><p>只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。</p><p>Vue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。</p><p>相比 React 的 Diff 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p><p>Vue3.x 借鉴了 ivi 算法和 inferno 算法</p><p>在创建 VNode 时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，</p><p>使得性能上较 Vue2.x 有了提升。</p><p>该算法中还运用了动态规划的思想求解最长递归子序列。</p><h2 id="再说一下虚拟-Dom-以及-key-属性的作用"><a href="#再说一下虚拟-Dom-以及-key-属性的作用" class="headerlink" title="再说一下虚拟 Dom 以及 key 属性的作用"></a>再说一下虚拟 Dom 以及 key 属性的作用</h2><p>由于在浏览器中操作 DOM 是很昂贵的。频繁的操作 DOM，会产生一定的性能问题。这就是虚拟 Dom 的产生原因。</p><p>Vue2 的 Virtual DOM 借鉴了开源库 snabbdom 的实现。</p><p>Virtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点。是对真实 DOM 的一层抽象。(也就是源码中的 VNode 类，它定义在 src/core/vdom/vnode.js 中。)</p><p>VirtualDOM 映射到真实 DOM 要经历 VNode 的 create、diff、patch 等阶段。</p><p>「key 的作用是尽可能的复用 DOM 元素。」</p><p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。</p><p>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key 也就是 children 中节点的唯一标识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vue 借鉴了 angular 的模板和数据绑定技术，又借鉴了 react 的组件化和虚拟 DOM 技术&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
    
      <category term="面试 Vue" scheme="http://github.com/categories/%E9%9D%A2%E8%AF%95-Vue/"/>
    
    
      <category term="面试 Vue" scheme="http://github.com/tags/%E9%9D%A2%E8%AF%95-Vue/"/>
    
  </entry>
  
  <entry>
    <title>CSS之基础篇</title>
    <link href="http://github.com/2021/02/09/CSS%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://github.com/2021/02/09/CSS%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2021-02-08T16:00:00.000Z</published>
    <updated>2021-02-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对CSS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="DIV-CSS-布局的优缺点"><a href="#DIV-CSS-布局的优缺点" class="headerlink" title="DIV + CSS 布局的优缺点"></a>DIV + CSS 布局的优缺点</h2><p>优点：</p><ul><li>代码精简，且结构与样式分离，易于维护</li><li>代码量减少了，减少了大量的带宽，页面加载的也更快，提升了用户的体验</li><li>对 SEO 搜索引擎更加友好，且 H5 又新增了许多语义化标签更是如此</li><li>允许更多炫酷的页面效果，丰富了页面</li><li>符合 W3C 标准，保证网站不会因为网络应用的升级而被淘汰</li></ul><p>缺点：</p><p>不同浏览器对 Web 标准默认值不同，所以更容易出现对浏览器的兼容性问题。</p><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>基本原理是通过媒体查询（@media）检测不同的设备屏幕尺寸做处理。</p><p>好处：对某些数据的修改就能自动更新视图，让开发者不需要操作 DOM，有更多的时间去思考完成业务逻辑。</p><h2 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h2><p>文档流：将窗体自上而下分成一行一行，并在每行中按从左至右一次排放元素，成为文档流，也就普通流。</p><p>脱离文档流：脱离文档流的元素，将不再在文档流占据空间，而是漂浮在文档流上方。</p><p><code>float: left/right</code>：使用之后会脱离，但是其他盒子会环绕该元素的周围。</p><p><code>position: absolute/fixed：absolute</code> 为绝对定位，脱离文档流之后还是会相对于该元素的父类（做了 <code>relative/absolute</code> 定位的父类）进行偏移。而 <code>fixed</code> 就是完全脱离文档流，相对于 <code>HTML</code> （整个浏览器窗口）的形式展示。</p><h2 id="块级格式化上下文（BFC）"><a href="#块级格式化上下文（BFC）" class="headerlink" title="块级格式化上下文（BFC）"></a>块级格式化上下文（BFC）</h2><p>BFC 布局规则 是指页面上一个隔离的独立容器，容器内部的子元素不会影响到外面的元素，反之外面的元素也不会影响容器里面的元素。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>在 BFC 中，盒子从顶端开始垂直地一个接一个地排列</li><li>盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠</li></ul><h3 id="外边距问题"><a href="#外边距问题" class="headerlink" title="外边距问题"></a>外边距问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;width:100px; height:100px; margin-bottom:100px;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div style=<span class="string">&quot;width:100px; height:100px; margin-top:200px;&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这段代码产生的页面中，它们的边距是 200px，需要通过 BFC 解决边距问题。</p><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h3><ol><li><p>清除元素内部浮动。<code>overflow: hidden</code></p></li><li><p>解决外边距合并问题。创建 2 个不同 <code>BFC</code>，就不会发生 <code>margin</code> 重叠</p><h3 id="产生-BFC-的条件："><a href="#产生-BFC-的条件：" class="headerlink" title="产生 BFC 的条件："></a>产生 BFC 的条件：</h3></li><li><p>根元素 <code>html</code></p></li><li><p><code>float: left/right</code></p></li><li><p><code>position: absolute/fixed</code></p></li><li><p><code>display: inline-block/flex/grid</code></p></li><li><p><code>overflow: hidden</code></p></li></ol><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><ul><li><code>box-sizing: content-box</code>。标准盒子，总宽度等于：<code>width + padding + border + margin</code>。</li><li><code>box-sizing: border-box</code>。<code>IE</code> 盒子，总宽度等于：<code>width + margin</code>。<code>IE</code> 盒子的 <code>width</code> 包含了 <code>width、padding</code> 和 <code>border</code> 属性。</li></ul><h2 id="link-和-import-区别"><a href="#link-和-import-区别" class="headerlink" title="link 和 @import 区别"></a>link 和 @import 区别</h2><p>CSS 引入方式有：</p><ul><li>内联：<code>style</code> 属性（<code>style=&quot;color: red&quot;</code>）</li><li>内嵌：<code>style</code> 标签（<code>&lt;style&gt;&lt;/style&gt;</code>）</li><li>外链：<code>link</code> 标签（<code>&lt;link href=&quot;index.css&quot;</code>&gt;</li><li>导入：<code>@import</code>（<code>@import url(&#39;index.css&#39;</code>) 或者 @import ‘index.css’）</li></ul><h3 id="link-和-import-区别："><a href="#link-和-import-区别：" class="headerlink" title="link 和 @import 区别："></a>link 和 @import 区别：</h3><ul><li><code>link</code> 是 <code>XHTML</code> 标签，除了加载 <code>CSS</code> 外，还可以定义 <code>RSS</code> 等其他事务；<code>@import</code> 属于 <code>CSS</code> 范畴，只能加载 <code>CSS</code>。</li><li><code>link</code> 引用 <code>CSS</code> 时，在页面载入时同时加载；<code>@import</code> 需要页面网页完全载入以后加载。</li><li><code>link</code> 是 <code>XHTML</code> 标签，无兼容问题；<code>@import</code> 是在 <code>CSS2.1</code> 提出的，低版本的浏览器不支持。</li><li><code>link</code> 支持使用 <code>Javascript</code> 控制 <code>DOM</code> 去改变样式；而 <code>@import</code> 不支持。</li></ul><h2 id="渐进增减和优雅降级"><a href="#渐进增减和优雅降级" class="headerlink" title="渐进增减和优雅降级"></a>渐进增减和优雅降级</h2><p>关键的区别是他们所侧重的内容，以及这种不同造成的工作流程的差异。</p><ul><li>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li><li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li></ul><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul><li>优雅降级是从复杂的现状开始，并试图减少用户体验的供给<br>渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要</li><li>降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</li></ul><h2 id="CSS-实现垂直居中"><a href="#CSS-实现垂直居中" class="headerlink" title="CSS 实现垂直居中"></a>CSS 实现垂直居中</h2><ol><li><p>方法一：Flex 布局（子元素是块级元素）</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-center&#123;</span><br><span class="line">  margin: auto;</span><br><span class="line">  background-color: greenyellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二：Flex 布局</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-center&#123;</span><br><span class="line">  background-color: greenyellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法三：绝对定位实现（定位元素定宽定高）</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-center&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">0</span>;</span><br><span class="line">  right: <span class="number">0</span>;</span><br><span class="line">  bottom: <span class="number">0</span>;</span><br><span class="line">  top: <span class="number">0</span>;</span><br><span class="line">  margin: auto;</span><br><span class="line">  width: <span class="number">50</span>px;</span><br><span class="line">  height: <span class="number">50</span>px;</span><br><span class="line">  background-color: greenyellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法四：使用 transform</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父盒子设置：display: relative</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子盒子 div 设置：</span></span><br><span class="line">div &#123;</span><br><span class="line">  transform: translate(<span class="number">-50</span>%, <span class="number">-50</span>%);</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: <span class="number">50</span>%;</span><br><span class="line">  left: <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h2><p>垂直居中分为水平居中、和垂直居中、完全居中（水平垂直都居中）</p></li></ol><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ol><li>行内元素可以通过在其父节点声明 text-align: center; 来实现,适用于内联、内联块、内联表、内联 Flex</li><li>块级元素可以通过 margin: 0 auto; + 宽度width<br>(在现代浏览器中实现水平居中，可以使用 display: flex; justify-content: center;不过，在 IE8-9 这样的不支持弹性盒布局的旧式浏览器中，上述代码并不会生效。此时要实现在父元素中居中，可使用 margin: 0 auto)<ul><li>节点不是块级元素需声明 display:block</li><li>若节点宽度已隐式声明则无需显式声明 width</li></ul></li><li>绝对定位 absolute+移动 transform 的方式</li><li>绝对定位 absolute+margin 负边距的方案</li><li>display:flex + justify-content:center</li></ol><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ol><li>子元素是单行文本的话直接 line-height 等于父节点的高度</li><li>display:flex + align-items:center</li><li>绝对定位 absolute+移动 transform 的方式</li><li>绝对定位 absolute+margin 负边距的方案</li></ol><h3 id="水平和垂直居中"><a href="#水平和垂直居中" class="headerlink" title="水平和垂直居中"></a>水平和垂直居中</h3><p>元素的宽度和高度 固定</p><p>绝对定位在 50%处，然后通过 margin 调整位置，浏览器兼容性良好</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;child&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.parent &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">50</span>%;</span><br><span class="line">  top: <span class="number">50</span>%;</span><br><span class="line">  margin: <span class="number">-50</span>px <span class="number">0</span> <span class="number">0</span> <span class="number">-50</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.child &#123;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">0</span>;</span><br><span class="line">  top: <span class="number">0</span>;</span><br><span class="line">  right: <span class="number">0</span>;</span><br><span class="line">  bottom: <span class="number">0</span>;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的宽度和高度 未知</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">50</span>%;</span><br><span class="line">  top: <span class="number">50</span>%;</span><br><span class="line">  <span class="comment">/* margin: -50px 0 0 -50px; */</span></span><br><span class="line">  transform: translate(<span class="number">-50</span>%, <span class="number">-50</span>%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强大的 flex 布局结合 margin</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  div &#123;</span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS-单位"><a href="#CSS-单位" class="headerlink" title="CSS 单位"></a>CSS 单位</h2><h3 id="1-px"><a href="#1-px" class="headerlink" title="1. px"></a>1. px</h3><p>px 是像素（pixel）的缩写，相对长度单位，是网页设计常用的基本基本单位，它是相对于显示器屏幕分辨率而言的。</p><h3 id="2-em"><a href="#2-em" class="headerlink" title="2. em"></a>2. em</h3><p>em 是相对长度单位，相对于对象内文本的字体尺寸（参考物是父元素的 font-size。</p><p>如果当前父元素的字体元素未设置，则相对于浏览器的默认字体尺寸设置。</p><h3 id="3-rem"><a href="#3-rem" class="headerlink" title="3. rem"></a>3. rem</h3><p>rem 是相对于 HTML 根元素的字体大小（font-size）来计算的长度单位。</p><p>如果你没有设置 HTML 字体大小，那么以浏览器默认为主，一般为 16px。</p><h3 id="4-vw-vh"><a href="#4-vw-vh" class="headerlink" title="4. vw/vh"></a>4. vw/vh</h3><p>vw 和 vh 是相对于 viewport - 相对视口的宽度或者高度而定的。</p><p>一般来说：1vw = npx / 100，即浏览器宽度为 200px 的时候，1vw = 200px / 100，即 1vw = 2px。</p><h2 id="CSS-设置隐藏元素"><a href="#CSS-设置隐藏元素" class="headerlink" title="CSS 设置隐藏元素"></a>CSS 设置隐藏元素</h2><ul><li><code>display: none</code>：彻底消失，会导致浏览器回流和重绘，不能再触发点击事件。</li><li><code>visibility: hidden</code>：元素隐藏，空间仍保留，会导致重绘，但是不能再触发点击事件。</li><li><code>opacity: 0</code>：设置为透明，相当于它还在那里，但是你看不到，可以触发点击事件。</li></ul><h2 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h2><p>CSS 选择器及样式优先级：</p><ul><li>在属性后面使用 !important 会覆盖页面任意位置定义的元素样式</li><li>作为 style 属性写在元素内的样式（行内样式）</li><li>id 选择器</li><li>类选择器 | 伪类选择器 | 属性选择器（后面样式覆盖前面样式）</li><li>标签选择器</li><li>通配符选择器</li><li>浏览器自定义样式</li></ul><h2 id="CSS-匹配规则"><a href="#CSS-匹配规则" class="headerlink" title="CSS 匹配规则"></a>CSS 匹配规则</h2><blockquote><p>CSS 选择器的解析是从右向左解析的。</p></blockquote><p>若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。</p><p>若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。</p><p>两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p><h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>层叠上下文（stacking context），是 HTML 中一个三维的概念。在 CSS2.1 规范中，每个盒模型的位置是三维的，分别是平面画布上的 X 轴，Y 轴以及表示层叠的 Z 轴。</p><p>一般情况下，元素在页面上沿 X 轴 Y 轴平铺，我们察觉不到它们在 Z 轴上的层叠关系。</p><p>而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。</p><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ul><li>根层叠上下文（HTML）</li><li>position</li><li>CSS3 属性<ul><li>flex</li><li>transform</li><li>opacity</li><li>filter</li><li>will-change</li><li>-webkit-overflow-scrolling</li></ul></li></ul><h3 id="层叠等级"><a href="#层叠等级" class="headerlink" title="层叠等级"></a>层叠等级</h3><p>层叠等级：层叠上下文在 Z 轴上的排序</p><p>在同一层叠上下文中，层叠等级才有意义<br>z-index 的优先级最高</p><h2 id="dispaly-和-position"><a href="#dispaly-和-position" class="headerlink" title="dispaly 和 position"></a>dispaly 和 position</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>inline</code>：（默认）内联</li><li><code>none</code>：隐藏</li><li><code>block</code>：块显示</li><li><code>table</code>：表格显示</li><li><code>inline-block</code>：内联块<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>static</code>：默认位置。不需要特别声明，不常用。</li><li><code>relative</code>：相对定位。相对于元素默认的位置进行定位，设置 <code>top/left/right/bottom</code> 后的元素仍占据空间。</li><li><code>absolute</code>：绝对定位。如果父元素设置了 <code>position: absolute/relative</code>，那么这个设置成立。它会根据上一个设置了 <code>absolute/relative</code> 的元素进行偏移。</li><li><code>fixed</code>：固定定位。相对于整个浏览器窗口进行定位，无论页面怎么滚动。</li><li><code>sticky</code>：黏性定位。屏幕范围内该元素位置不受影响，超出范围后，会变成 <code>fixed</code>，根据设置的 <code>left/top</code> 等属性成固定的效果。</li></ul><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><ul><li>RGBA 和透明度</li><li><code>background-image</code>、<code>background-origin(content-box/padding-box/border-box)</code>、<code>background-size</code>、<code>background-repeat</code></li><li><code>word-wrap</code>：对长的不可分割单词换行，例如 <code>word-wrap：break-word</code></li><li>文字阴影：<code>text-shadow: 5px 5px 5px #FF0000</code>;，对应水平阴影，垂直阴影，模糊距离，阴影颜色</li><li><code>font-face</code> 属性：定义自己的字体</li><li>圆角（边框半径）：<code>border-radius</code> 属性用于创建圆角</li><li>边框图片：<code>border-image: url(border.png) 30 30 round</code></li><li>盒阴影：<code>box-shadow: 10px 10px 5px #888888</code></li><li>媒体查询：定义两套 <code>CSS</code>，当浏览器的尺寸变化时会采用不同的属性<h3 id="Flexbox-弹性盒布局模型"><a href="#Flexbox-弹性盒布局模型" class="headerlink" title="Flexbox 弹性盒布局模型"></a>Flexbox 弹性盒布局模型</h3></li></ul><p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。</p><p>在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。</p><p>弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。</p><p>试用场景：弹性布局适合于移动前端开发，在 Android 和 IOS 上也完美支持。</p><h2 id="CSS-优化"><a href="#CSS-优化" class="headerlink" title="CSS 优化"></a>CSS 优化</h2><ul><li>避免过度约束</li><li>避免后代选择符</li><li>避免链式选择符</li><li>使用紧凑的语法</li><li>避免不必要的命名空间</li><li>避免不必要的重复</li><li>最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么</li><li>避免 !important，可以选择其他选择器</li><li>尽可能的精简规则，你可以合并不同类里的重复规则</li></ul><h2 id="CSS-的-style-标签位置"><a href="#CSS-的-style-标签位置" class="headerlink" title="CSS 的 style 标签位置"></a>CSS 的 style 标签位置</h2><p>页面加载自上而下，当然是先加载样式。</p><p>写在 body 标签后由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在 Windows 的 IE 下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对CSS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;DIV-CSS-布局的优缺点&quot;&gt;&lt;a href=&quot;#DIV-CSS-布局的优缺点&quot; class=&quot;headerlink&quot; title=&quot;DIV + C
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://github.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://github.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS之面试重点篇</title>
    <link href="http://github.com/2021/02/09/CSS%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E7%AF%87/"/>
    <id>http://github.com/2021/02/09/CSS%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E7%AF%87/</id>
    <published>2021-02-08T16:00:00.000Z</published>
    <updated>2021-02-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对CSS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://juejin.cn/post/6844903842635579405">【面试篇】寒冬求职之你必须要懂的Web安全</a></p></li><li><p><a href="https://zoumiaojiang.com/article/common-web-security/#xss">常见 Web 安全攻防总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对CSS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h2&gt;&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="CSS 面试" scheme="http://github.com/categories/CSS-%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="CSS 面试" scheme="http://github.com/tags/CSS-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化之Webpack优化</title>
    <link href="http://github.com/2021/02/06/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8BWebpack%E4%BC%98%E5%8C%96/"/>
    <id>http://github.com/2021/02/06/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8BWebpack%E4%BC%98%E5%8C%96/</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-02-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="Webpack优化"><a href="#Webpack优化" class="headerlink" title="Webpack优化"></a>Webpack优化</h2><p>Webpack 的优化瓶颈，主要是 2 个方面：</p><p>Webpack 的构建过程太花时间<br>Webpack 打包的结果体积太大</p><h2 id="针对-Webpack-本身构建优化"><a href="#针对-Webpack-本身构建优化" class="headerlink" title="针对 Webpack 本身构建优化"></a>针对 Webpack 本身构建优化</h2><h3 id="优化-resolve-modules-配置"><a href="#优化-resolve-modules-配置" class="headerlink" title="优化 resolve.modules 配置"></a>优化 resolve.modules 配置</h3><p><code>resolve.modules</code> 用于配置<code> Webpack</code> 去哪些目录下寻找第三方模块，默认是 <code>[&#39;node_modules&#39;]</code>。</p><p>但是，它会先去当前目录的 <code>./node_modules</code> 查找，没有的话再去 <code>../node_modules</code>，最后到根目录 —— 即 <code>npm</code> 查找包的规则。</p><p>所以可以直接指定项目根目录，这样代码就不需要一层一层查找。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  modules: [path.resolve(__dirname, <span class="string">&#x27;node_modules&#x27;</span>)],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化-resolve-extensions-配置"><a href="#优化-resolve-extensions-配置" class="headerlink" title="优化 resolve.extensions 配置"></a>优化 resolve.extensions 配置</h3><p>在导入没带文件后缀的路径时，<code>Webpack</code> 会自动带上后缀去尝试询问文件是否存在，而 <code>resolve.extensions</code> 用于配置尝试后缀列表；默认为 <code>extensions:[&#39;js&#39;, &#39;json&#39;]</code>。</p><p>当遇到 <code>require(&#39;./data&#39;)</code> 时 <code>Webpack</code> 会先尝试寻找 <code>data.js</code>，没有再去找 <code>data.json</code>；如果列表越长，或者正确的后缀越往后，尝试的次数就会越多。</p><p>所以在配置时为提升构建优化需遵守：</p><ul><li>频率出现高的文件后缀优先放在前面。</li><li>列表尽可能的少，例如只有 3 个：js、jsx、json。</li><li>书写导入语句时，尽量写上后缀名。</li></ul><h3 id="优化-resolve-include-exclude-配置"><a href="#优化-resolve-include-exclude-配置" class="headerlink" title="优化 resolve.include/exclude 配置"></a>优化 resolve.include/exclude 配置</h3><p>以 <code>babel-loader</code> 为例，可以通过 <code>include</code> 和 <code>exclude</code> 帮助我们避免 <code>node_modules</code> 这类庞大文件夹。</p><p>即通过 <code>include</code> 告诉 <code>Webpack</code> 哪些我们是需要检测的，通过 <code>exclude</code> 告诉 <code>Webpack</code> 哪些我们是不需要检测的（例如已经收拾过的静态资源）</p><h2 id="通过-Loader-和-Plugin-优化"><a href="#通过-Loader-和-Plugin-优化" class="headerlink" title="通过 Loader 和 Plugin 优化"></a>通过 Loader 和 Plugin 优化</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li><p>cache-loader</p><p>在 babel-loader 开启 cache 后，将 loader 的编译结果写进硬盘缓存，再次构建如果文件没有发生变化则会直接拉取缓存。</p></li><li><p>uglifyjs-webpack-plugin</p><p>通过这个插件也可以解决缓存问题。</p></li></ul><blockquote><p>注：具体的要根据当前的 Webpack 版本，Loader 和 Plugin 表示 Webpack 每次更新都会淘汰一批没有跟进维护的 Loader 和 Plugin。就跟大佬还在持续学习，你几年没学习之后，遇到金融危机被淘汰的风险就高了。</p></blockquote><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。</p><p>文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？</p><p><code>Happypack</code> 可以将任务分解成多个子进程去并发执行，大大提升打包效率。</p><p>除此之外 <code>thread-loader</code> 和 <code>Happypack</code> 一样，但是配置比较简单。</p><blockquote><p>  <code>Happypack</code> 已经不维护了。</p></blockquote><h3 id="多进程压缩"><a href="#多进程压缩" class="headerlink" title="多进程压缩"></a>多进程压缩</h3><p>因为自带的 <code>UglifyjsWebpackPlugin</code> 压缩插件是单线程运行的，而 <code>TerserWebpackPlugin</code> 可以并发运行压缩功能（多进程）。</p><p>所以通过 <code>TerserWebpackPlugin</code> 代替自带的 <code>UglifyjsWebpackPlugin</code> 插件。</p><h3 id="静态资源分离"><a href="#静态资源分离" class="headerlink" title="静态资源分离"></a>静态资源分离</h3><p>通过 <code>DllPlugin</code> 或者 <code>Externals</code> 进行静态依赖包的分离。</p><p>由于 <code>CommonsChunkPlugin</code> 每次构建会重新构建一次 <code>vendor</code>，所以出于效率考虑，使用<code>DllPlugin</code>将第三方库单独打包到一个文件中，只有依赖自身发生版本变化时才会重新打包。</p><h3 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h3><p>在 <code>Webpack </code>中，到底什么是代码分离？代码分离允许你把代码拆分到多个文件中。如果使用得当，你的应用性能会提高很多。因为浏览器能缓存你的代码。</p><p>每当你做出一次修改，包含修改的文件需要被所有访问你网站的人重新下载。但你并不会经常修改应用的依赖库。</p><p>如果你能把那些依赖库拆分到完全分离的文件中，即使业务逻辑发生了更改，访问者也不需要再次下载依赖库，直接使用之前的缓存就可以了。</p><p>由于有了 <code>SplitChunksPlugin</code>，你可以把应用中的特定部分移至不同文件。如果一个模块在不止一个 chunk 中被使用，那么利用代码分离，该模块就可以在它们之间很好地被共享。</p><h3 id="打包资源压缩"><a href="#打包资源压缩" class="headerlink" title="打包资源压缩"></a>打包资源压缩</h3><ul><li>JS 压缩：<code>UglifyjsWebpackPlugin</code></li><li>HTML 压缩：<code>HtmlWebpackPlugin</code></li><li>CSS 压缩：<code>MiniCssExtractPlugin</code></li><li>图片压缩：<code>image-webpack-loader</code></li><li>Gzip 压缩：不包括图片</li></ul><h2 id="其他优化点"><a href="#其他优化点" class="headerlink" title="其他优化点"></a>其他优化点</h2><h3 id="1-Tree-Shaking"><a href="#1-Tree-Shaking" class="headerlink" title="1. Tree Shaking"></a>1. Tree Shaking</h3><p>通过 ES6 的<code>import/export</code>来检查未引用代码，以及 <code>sideEffects</code> 来标记无副作用代码，最后用 <code>UglifyJSPlugin</code> 来做 <code>Tree Shaking</code>，从而删除冗余代码。</p><h3 id="2-Scope-Hoisting"><a href="#2-Scope-Hoisting" class="headerlink" title="2. Scope Hoisting"></a>2. Scope Hoisting</h3><p><code>Scope Hoisting</code> 是 <code>Webpack3</code> 的新功能，直译为 「<code>作用域提升」</code>，它可以让 <code>Webpack</code> 打包出来的 <code>「代码文件更小」</code>，<code>「运行速度更快」</code>。</p><p>熟悉 <code>JavaScript </code>都应该知道 <code>「函数提升」</code> 和 <code>「变量提升」</code> ，<code>JavaScript</code> 会把函数和变量声明提升到当前作用域的顶部。</p><p><code>「作用域提升」</code> 也类似于此，<code>Webpack</code> 会把引入的 <code>js</code> 文件 <code>“提升到”</code> 它的引入者顶部。</p><p><code>Scope Hoisting</code> 的实现原理其实很简单：分析出模块之间的依赖关系，尽可能将打散的模块合并到一个函数中，前提是不能造成代码冗余。因此「只有那些被引用了一次的模块才能被合并」。</p><p>由于 <code>Scope Hoisting</code> 需要分析出模块之间的依赖关系，因此源码<code>「必须采用 ES6 模块化语句」</code>，不然它将无法生效。原因和 <code>Tree Shaking </code>中介绍的类似。</p><h3 id="3-按需加载"><a href="#3-按需加载" class="headerlink" title="3. 按需加载"></a>3. 按需加载</h3><p>什么是 代码分割（<code>code splitting</code>）？</p><p>代码分割是指：将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程。</p><p>在 <code>Webpack</code> 构建时，会避免加载已声明要异步加载的代码，异步代码会被单独分离出一个文件，当代码实际调用时被加载至页面。</p><p>代码分割技术的核心是 <code>异步加载资源</code>。</p><p>可喜的是，浏览器允许我们这么做，<code>W3C stage 3</code> 规范： <code>whatwg/loader</code> 对其进行了定义：你可以通过 <code>import()</code> 关键字让浏览器在程序执行时异步加载相关资源。</p><p>在 <code>Vue</code> 中，可以直接使用 <code>import()</code> 关键字做到这一点，而在 <code>React</code> 中，你需要使用 <code>react-loadable</code> 去完成同样的事。</p><h2 id="优化体验"><a href="#优化体验" class="headerlink" title="优化体验"></a>优化体验</h2><ul><li><p><code>progress-bar-webpack-plugin</code>：在终端底部，将会有一个构建的进度条，可以让你清晰的看见构建的执行进度。</p></li><li><p><code>webpack-build-notifier</code>：在构建完成时，能够像微信、Lark 这样的 APP 弹出消息的方式，提示构建已经完成。</p></li><li><p><code>webpack-dashboard</code>：对 <code>Webpack</code> 原始的构建输出不满意的话，也可以使用这样一款 Plugin 来优化你的输出界面。</p></li><li><p><code>speed-measure-webpack-plugin</code>：该插件可以测量各个插件和 <code>loader</code> 所花费的时间。</p></li><li><p><code>webpack-bundle-analyzer</code>：可视化分析。通过矩阵树图的方式将包内各个模块的大小和依赖关系呈现出来。</p></li><li><p><code>webpack-chart</code></p></li><li><p><code>webpack-analyse</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ul><ul><li><p><a href="https://juejin.cn/post/6844903924806189070#heading-0">Webpack优化——将你的构建效率提速翻倍</a></p></li><li><p><a href="http://louiszhai.github.io/2019/01/04/webpack4/">使用webpack4提升180%编译速度</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;Webpack优化&quot;&gt;&lt;a href=&quot;#Webpack优化&quot; class=&quot;headerlink&quot; title=&quot;Webpack优化&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://github.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="前端工程化" scheme="http://github.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化之Webpack</title>
    <link href="http://github.com/2021/02/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8BWebpack/"/>
    <id>http://github.com/2021/02/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8BWebpack/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="Webpack-是什么"><a href="#Webpack-是什么" class="headerlink" title="Webpack 是什么"></a>Webpack 是什么</h2><p>Webpack 是一个现代 JavaScript 应用程序的静态模块打包器（module bundler）。</p><p>当 Webpack 处理应用程序时，它会递归地构建一个依赖关系图（dependency graph），其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p><p>所以，它的本质是一个模块打包器，其工作是将每个模块打包成相应的 bundle。</p><h2 id="Webpack-核心概念"><a href="#Webpack-核心概念" class="headerlink" title="Webpack 核心概念"></a>Webpack 核心概念</h2><ul><li>mode：模式。对应有开发模式、生产模式等</li><li>entry：入口</li><li>output：出口</li><li>loader：模块转换器，用于把模块原内容按照需求转换成新内容。Webpack 对于 .jpg、.txt 等内容无法处理，就需要 file-loader、url-loader 等进行协助处理。</li><li>plugins：扩展插件，在 Webpack 构建流程中的特定时机注入拓展逻辑来改变构建结果或者做其他你想做的事情。</li></ul><h2 id="Webpack-构建流程"><a href="#Webpack-构建流程" class="headerlink" title="Webpack 构建流程"></a>Webpack 构建流程</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li><li>确定入口：根据配置中的 entry 找出所有的入口文件</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ol><p>简单来说：</p><ol><li>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler（钩子）</li><li>编译：从 Entry 出发，针对每个 Module（模块）串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li><li>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中（Chunk 就是打包过程中，入口模块引用其他模块，模块再引用模块，这个关系链连接的 Module 就形成了 Chunk）</li></ol><p>在这个过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="1-entry"><a href="#1-entry" class="headerlink" title="1.entry"></a>1.entry</h3><blockquote><p>打包入口<br>指定打包⼊口文件，有三种不同的形式：string | object | array。</p></blockquote><p>一对一：一个入口、一个打包文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多对一：多个入口、一个打包文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [</span><br><span class="line">    <span class="string">&#x27;./src/index1.js&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;./src/index2.js&#x27;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多对多：多个入口、多打包文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">&#x27;index1&#x27;</span>: <span class="string">&quot;./src/index1.js&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;index2&#x27;</span>: <span class="string">&quot;./src/index2.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-output"><a href="#2-output" class="headerlink" title="2.output"></a>2.output</h3><blockquote><p>打包后的文件输出位置。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    filename: <span class="string">&quot;[name].js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以指定一个固定的文件名称，如果是多入口多出口（entry 为对象），则不能使用单文件出口，需要使用下面的方式<br>通过 Webpack 内置的变量占位符：[name]</p><h3 id="3-loader"><a href="#3-loader" class="headerlink" title="3.loader"></a>3.loader</h3><blockquote><p>模块转换器，用于把模块原内容按照需求转换成新内容</p></blockquote><p>loader 的执行顺序是从右向左执行的，也就是后面的 loader 先执行。</p><p>假如有配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那就是先处理 less-loader，再处理 css-loader，最后处理 style-loader。</p><h4 id="常见的-loader"><a href="#常见的-loader" class="headerlink" title="常见的 loader"></a>常见的 loader</h4><ol><li><p>关于文件处理常见的 loader</p><ul><li><code>file-loader</code>：当引入的文件是 <code>.png</code>、<code>.txt</code> 等时，可以通过<code>file-loader</code> 解析项目中的 <code>url</code> 引入。根据配置将文件拷贝到相应的路径，并修改打包后文件的引入路径，让它指向正确的文件。</li><li><code>url-loader</code>：<code>url-loader</code> 封装了 <code>file-loader</code> 且可以不依赖于 <code>file-loader</code> 单独使用，并且可以配置 <code>limit</code>。对小于 <code>limit</code> 大小的图片转换成 <code>Base64</code>，大于 <code>limit</code> 的时候使用 <code>file-loader</code> 里的方法。</li></ul></li><li><p>关于语法检查常见 loader</p></li></ol><ul><li>tslint-loader：通过 TSLint 检查 TypeScript 代码</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li></ul><ol start="3"><li>关于 HTML 代码处理常见的 loader</li></ol><ul><li>html-withimg-loader：处理 HTML 中的图片</li></ul><ol start="4"><li>关于 CSS 代码处理常见的 loader</li></ol><ul><li>style-loader：动态创建 style 标签，将 CSS 代码插入到 head 中。</li><li>css-loader：负责处理 @import、url 等语句。例如 import css from ‘file.css’、url(image.png)。</li><li>postcss-loader：负责进一步处理 CSS 文件，比如添加浏览器前缀，压缩 CSS 等。</li><li>less-loader：将 .less 文件内容转换成 CSS。</li><li>sass-loader：将 .sass 文件内容转换成 CSS。</li></ul><ol start="5"><li>关于 JS 代码处理常见的 loader</li></ol><ul><li>babel-loader：将 JS 代码向低版本转换，我们需要使用 -babel-loader。</li><li>ts-loader：将 TypeScript 转换成 JavaScript</li></ul><h3 id="4-plugin"><a href="#4-plugin" class="headerlink" title="4.plugin"></a>4.plugin</h3><blockquote><p>扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情</p></blockquote><h4 id="常见-plugin"><a href="#常见-plugin" class="headerlink" title="常见 plugin"></a>常见 plugin</h4><ul><li>clean-webpack-plugin：打包前自动清理 dist 目录，防止文件残留。</li><li>copy-webpack-plugin：将单个文件或者整个目录复制到构建目录<br>mini-css-extract-plugin：将 CSS 抽离出来单独打包并且通过配置可以设置是否压缩。</li><li>html-webpack-plugin：这个插件可以配置生成一个 HTML5 文件，其中 script 标签包含所有 Webpack 包。如果你设置多个入口点，你可以据此实现多页面应用打包。<h4 id="提高效率的-plugin"><a href="#提高效率的-plugin" class="headerlink" title="提高效率的 plugin"></a>提高效率的 plugin</h4></li><li>webpack-dashboard：可以更友好的展示相关打包信息。</li><li>webpack-merge：提取公共配置，减少重复配置代码</li><li>speed-measure-webpack-plugin：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。</li><li>size-plugin：监控资源体积变化，尽早发现问题</li><li>HotModuleReplacementPlugin：模块热替换</li></ul><h4 id="loader-和-plugin-的区别"><a href="#loader-和-plugin-的区别" class="headerlink" title="loader 和 plugin 的区别"></a>loader 和 plugin 的区别</h4><ol><li><p>Loader</p><p> Loader 本质上就是一个函数，对接收到的内容进行转换，返回转换后的结果。</p><p> 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对不同类型的资源进行处理。</p><p> 就好比 file-loader 或者 url-loader，配置之后就可以正确引用 png 等格式的图片、txt 等格式文件。</p><p> 又好比 style-loader 以及 css-loader，引用后就可以对 CSS 内容进行预编译处理。</p></li><li><p>Plugin</p><p> Plugin 就是插件，就好比 编写的 VS Code 插件一样，Plugin 拓展了 Webpack 的功能。</p><p> Plugin 就是在 Webpack 的生命周期中进行各种操作，从而达到使用者目的插件。</p><p> 就好比 html-webpack-plugin，配合多入口形式使用之后，就可以实现多页面应用的功能。</p><p> 又好比 clean-webpack-plugin 实现打包之前清空 dist 目录，copy-webpack-plugin 可以将单个文件或者整个目录复制到构建目录。</p></li></ol><h3 id="5-resolve"><a href="#5-resolve" class="headerlink" title="5.resolve"></a>5.resolve</h3><blockquote><p>resolve 配置 Webpack 如何寻找模块所对应的文件。</p></blockquote><p>Webpack 内置 JavaScript 模块化语法解析功能，默认会采用模块化标准里约定好的规则去寻找，但你可以根据自己的需要修改默认的规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    modules: [<span class="string">&#x27;./src/components&#x27;</span>, <span class="string">&#x27;node_modules&#x27;</span>] <span class="comment">// 从左到右依次查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>resolve.modules：配置 Webpack 去哪些目录下寻找第三方模块，默认情况下，只会去 node_modules 下寻找，如果你在项目中某个文件夹下的模块经常被导入，不希望写很长的路径，那么就可以通过配置 resolve.modules 来简化。</li><li>resolve.alias：配置项通过别名把原导入路径映射成一个新的导入路径。</li><li>resolve.extensions：适配多端的项目中，可能会出现 .web.js, .wx.js，例如在转 Web 的项目中，我们希望首先找 .web.js，如果没有，再找 .js。extensions: [‘web.js’, ‘.js’]。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://juejin.cn/post/6844904094281236487#heading-0">「吐血整理」再来一打Webpack面试题</a></p></li><li><p><a href="https://juejin.cn/post/6844904079219490830#heading-0">带你深度解锁Webpack系列(基础篇)</a></p></li><li><p><a href="https://juejin.cn/post/6924258563862822919#heading-1">Webpack5 新特性业务落地实战</a></p></li><li><p><a href="https://juejin.cn/post/6902225969604460558#heading-0">Vite 原理分析</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;Webpack-是什么&quot;&gt;&lt;a href=&quot;#Webpack-是什么&quot; class=&quot;headerlink&quot; title=&quot;Webpack 是什么
      
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://github.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="前端工程化" scheme="http://github.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="http://github.com/2021/02/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>http://github.com/2021/02/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><h3 id="Babel-原理"><a href="#Babel-原理" class="headerlink" title="Babel 原理"></a>Babel 原理</h3><p>大多数 <code>JavaScript Parser</code> 遵循 <code>estree</code> 规范，<code>Babel</code> 最初基于 <code>acorn</code> 项目（轻量级现代 <code>JavaScript</code> 解析器）</p><p><code>Babel</code> 大概分为三大部分：</p><ul><li>解析：将代码转换成 <code>AST</code><ul><li>词法分析：将代码（字符串）分割为 <code>token</code> 流，即语法单元成的数组</li><li>语法分析：分析 <code>token</code> 流（上面生成的数组）并生成 <code>AST</code></li></ul></li><li>转换：访问 <code>AST</code> 的节点进行变换操作生产新的 <code>AST</code>，<br><code>Taro</code> 就是利用 <code>babel</code> 完成的小程序语法转换</li><li>生成：以新的 <code>AST</code> 为基础生成代码</li></ul><h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><blockquote><p>抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。</p></blockquote><p>它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p><p>之所以说语法是 “抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p><h3 id="面试点"><a href="#面试点" class="headerlink" title="面试点"></a>面试点</h3><ul><li>面试官：了解过 <code>Babel</code> 吗？</li><li>俺：大概知道将 <code>ES6+</code> 代码，先通过词法分析和语法分析之后解析为 <code>AST</code>，然后将这份 <code>AST</code> 转换为我们需要形式的 <code>AST</code>，最后将这个 <code>AST</code> 再转换成 <code>ES5</code> 或者期望格式的内容。</li><li>面试官：写过 <code>Babel</code> 插件吗？</li><li>俺：没有。</li></ul><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><ul><li>是什么：本质是一个模块打包器，其工作是将每个模块打包成相应的 bundle</li><li>核心概念：mode、entry、output、loader、plugin</li><li>构建流程：初始化、编译、输出，插件（Plugin）随时监听 Webpack 广播并在某些时候调用 API 改变运行结果。</li><li>entry：指定打包⼊口⽂文件。原本是 string，即一个入口对一个打包文件、object 多对一，array 多对多</li><li>output：打包后的文件位置</li><li>loader：翻译官，对不同资源进行处理，从右向左执行</li><li>plugin：插件，扩展 Webpack 的功能，监听 Webpack 的生命周期，调用 API 改变输出结果。</li><li>resolve：配置 Webpack 如何寻找模块所对应的文件。<code>resolve.modules/extensions/include/exclude</code></li></ul><h2 id="Webpack-性能优化"><a href="#Webpack-性能优化" class="headerlink" title="Webpack 性能优化"></a>Webpack 性能优化</h2><ul><li>resolve.modules：用于配置 Webpack 去哪些目录下寻找第三方模块（node_modules）</li><li>resolve.extensions：在导入没带文件后缀的路径时，Webpack 会自动带上后缀去尝试询问文件是否存在，而 <code>resolve.extensions</code> 用于配置尝试后缀列表；默认为 <code>extensions:[&#39;js&#39;, &#39;json&#39;]</code></li><li><code>resolve.include/exclude</code>：以 <code>babel-loader</code> 为例，可以通过 include 和 exclude 帮助我们避免 node_modules 这类庞大文件夹]</li><li>缓存：<code>cache-loader</code> 和 <code>uglifyjs-webpack-plugin</code>，将编译结果写进硬盘缓存，下次文件如果没有变化则直接拉取缓存</li><li>多进程：<code>Happypack</code> 和 <code>thread-loader</code>，将任务分解成多个子进程去并发执行，提高打包效率</li><li>多进程压缩：<code>Webpack</code> 自带的 <code>UglifyJSWebpackPlugin</code> 压缩插件是单线程运行的，而 <code>TerserWebpackPlugin</code> 可以并行执行（多线程）</li><li>静态资源分离：<code>CommonsChunkPlugins</code> 每次构建都会重新构建 vendor，出于效率问题使用 DllPlugin 可以将第三方库单独打包到一个文件中，只有依赖自身发生版本变化才会重新打包</li><li>打包资源压缩：</li><li>JS 压缩：<code>UglifyJSWebpackPlugin</code> 和 <code>TerserWebpackPlugin</code></li><li>HTML 压缩：<code>HtmlWebpackPlugin</code></li><li>CSS 压缩：<code>MiniCssExtractPlugin</code></li><li>图片压缩：<code>ImageWebpackPlugin</code></li><li>Gzip 压缩：不包括图片</li><li>Tree Shaking</li><li>Scope Hoisiting</li><li>按需加载<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ul><ul><li><p><a href="https://juejin.cn/post/6844903842635579405">【面试篇】寒冬求职之你必须要懂的Web安全</a></p></li><li><p><a href="https://zoumiaojiang.com/article/common-web-security/#xss">常见 Web 安全攻防总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;Babel&quot;&gt;&lt;a href=&quot;#Babel&quot; class=&quot;headerlink&quot; title=&quot;Babel&quot;&gt;&lt;/a&gt;Babel&lt;/h2&gt;&lt;h
      
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://github.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="前端工程化" scheme="http://github.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之HTTP</title>
    <link href="http://github.com/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BHTTP/"/>
    <id>http://github.com/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BHTTP/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="HTTP-发展史"><a href="#HTTP-发展史" class="headerlink" title="HTTP 发展史"></a>HTTP 发展史</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>传输体积很小的文件，没有 HTTP 请求头和请求体，服务器也不返回头信息。</p><p>HTTP/0.9 并没有考虑太过复杂的内容，仅仅是用来传输体积很小的文件。</p><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>核心诉求是支持多种类型的文件下载。加入了请求头和响应头支持多种不同类型的数据。以及状态码、Cache 机制、用户代理等。</p><p>应对 HTTP/0.9 出现的问题，进行了支持多类型文件下载等内容的优化。<br><br>HTTP/1.0 定义了三种请求方法：GET，POST 和 HEAD 方法。</p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><ol><li>改进了 <code>HTTP/1.0</code> 版本每次 <code>HTTP</code> 通信都需要建立 <code>TCP</code> 连接、传输 <code>HTTP</code> 数据再断开 <code>TCP</code> 连接的尴尬局面，支持持续连接。只要浏览器或者服务器没有明确断开连接，那么该 <code>TCP</code> 连接会一直保持（默认开启 <code>keep-alive</code>）。</li><li>如果 <code>TCP</code> 通道中某个请求因为某些原因没有及时返回，会阻塞后面所有请求（队头阻塞），所以 <code>HTTP/1.1 </code>通过管线化来解决队头阻塞的问题。</li><li><code>HTTP/1.0</code> 每个域名绑定唯一 <code>IP</code> 地址，一个服务器只能支持一个域名。<code>HTTP/1.1</code> 请求头增加 <code>Host</code> 字段，表示当前域名地址，服务器可以根据不同的 <code>Host</code> 值做不同的处理。这样一台物理主机就可以绑定多个虚拟主机，每个虚拟主机都有自己单独的域名。</li><li><code>HTTP/1.0</code> 需要在响应头设置完整的数据大小来接收数据，但是随着服务器端发展，很多页面动态生成，不知道传输数据的最终大小。<code>HTTP/1.1</code> 引入 <code>Chunk transfer</code> 机制来解决这个问题，服务器将数据分割成任意大小的数据块，每个数据块发送时附带上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志，从而支持了动态内容。</li><li>客户端 <code>Cookie</code>、安全机制。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>HTTP/1.1</code> 默认开启 <code>Connection: keep-alive</code>，让一个 <code>TCP </code>连接能重复发送/接收多次 <code>HTTP </code>请求。</li><li><code>HTTP/1.1</code>新增了六种请求方法：<code>OPTIONS</code>、<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>、<code>TRACE</code> 和 <code>CONNECT</code> 方法。</li></ul><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><ol><li>一个域名只使用一个 TCP 长连接和消除队头阻塞问题</li><li>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。HTTP/2.0 实现了一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</li><li>队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>头部压缩：HTTP/2 压缩消息头，减少了传输数据的大小</li><li>多路复用：即多个请求都通过一个 TCP 连接并发地完成</li><li>设置请求优先级</li><li>服务器推送：服务端能够主动把资源推送给客户端</li></ul><h3 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP/3.0"></a>HTTP/3.0</h3><ol><li>实现了类似 TCP 的流量控制、传输可靠性的功能。</li><li>集成了 TLS 加密功能。</li><li>实现了 HTTP/2 中的多路复用功能。</li><li>实现了快速握手功能。</li></ol><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="什么是http？"><a href="#什么是http？" class="headerlink" title="什么是http？"></a>什么是http？</h3><blockquote><p>超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP）</p></blockquote><p>Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器等一系列运作流程。而协议是指规则的约定。可以说，Web 是建立在 HTTP 协议上通信的。</p><p>HTTP 最初的目的是为了让研究者共享知识信息，所以它的主要作用就是文档传输，它是一种用于传输文档的协议。用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><h3 id="HTTP的优点："><a href="#HTTP的优点：" class="headerlink" title="HTTP的优点："></a>HTTP的优点：</h3><ol><li><strong><em>灵活可扩展</em></strong>，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</li><li><strong><em>可靠传输</em></strong>。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</li><li><strong><em>请求-应答</em></strong>。也就是一发一收、有来有回，当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</li><li><strong><em>无状态</em></strong>。这里的状态是指通信过程的上下文信息，而每次 HTTP 请求都是独立、无关的，默认不需要保留状态信息。</li></ol><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><ol><li><strong><em>无状态</em></strong>。在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 HTTP 的缺点了。</li><li><strong><em>明文传输</em></strong>。协议里的报文（主要指的是头部）不使用二进制数据，而是文本形式。</li><li><strong><em>队头阻塞问题</em></strong>。当 HTTP 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态。</li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="什么是https"><a href="#什么是https" class="headerlink" title="什么是https"></a>什么是https</h3><blockquote><p>https的SSL加密是在传输层实现的。</p></blockquote><p>以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p><p>简单来说 HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，比 HTTP 协议的安全性更高。</p><p>最后一个字母 S 指的是 SSL/TLS 协议，它位于 HTTP 协议与 TCP/IP 协议中间。</p><h3 id="https协议的工作原理"><a href="#https协议的工作原理" class="headerlink" title="https协议的工作原理"></a>https协议的工作原理</h3><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><ul><li>浏览器请求 URL，找到服务器，向服务器发送请求。服务器将自己的证书（包含服务器公钥）、对称加密算法种类以及其他相关信息返回给浏览器。</li><li>浏览器检查 CA 证书是否可依赖，确认证书有效。</li><li>如果不是，给服务器发警告，询问是否可以继续使用。</li><li>如果是，浏览器使用公钥加密一个随机对称秘钥，包含加密的 URL 一起发送给服务器。</li><li>服务器用自己的私钥解密浏览器发送的钥匙，然后用这把对称加密的钥匙给浏览器请求的 URL 连接解密。</li><li>服务器用浏览器发送的对称钥匙给请求的网页加密，浏览器使用相同的钥匙就可以解密网页。</li></ul><h3 id="https协议的优点"><a href="#https协议的优点" class="headerlink" title="https协议的优点"></a>https协议的优点</h3><ol><li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li><li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li></ol><h3 id="https协议的缺点"><a href="#https协议的缺点" class="headerlink" title="https协议的缺点"></a>https协议的缺点</h3><ol><li>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</li><li>https缓存不如http高效，会增加数据开销。</li><li>SSL证书也需要钱，功能越强大的证书费用越高。</li><li>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</li></ol><h2 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h2><p>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</p><p>主要的区别如下：</p><ol><li><strong><em>概念对比</em></strong>。HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</li><li><strong><em>费用对比</em></strong>。 HTTPS 协议需要 CA 证书，费用较高。</li><li><strong><em>连接方式和端口</em></strong>。使用不同的连接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li><li><strong><em>安全性对比</em></strong>。 HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ol><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><ul><li>GET：获取资源</li><li>HEAD：获取资源的元信息</li><li>POST：提交/上传 数据</li><li>PUT：修改数据</li><li>DELETE：删除资源（几乎用不到）</li><li>CONNECT：建立连接渠道，用于代理服务器</li><li>OPTIONS：列出可对资源实施的请求方法，用来跨域请求</li><li>TRACE：追踪请求-响应的传输路径</li></ul><h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><p>GET 和 POST 方法没有实质区别，只是报文格式不同。</p><p>GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议。</p><p>无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。</p><ul><li>GET 获取资源；POST 提交/上传 数据。</li><li>GET 请求长度在浏览器中有限制，而 POST 并没有。</li><li>GET 请求会被浏览器主动保留下来（历史记录），而 POST 默认不会。</li><li>get和post在缓存方面的区别：<ul><li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li><li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li></ul></li></ul><h3 id="【误】GET-请求传参长度有限制"><a href="#【误】GET-请求传参长度有限制" class="headerlink" title="【误】GET 请求传参长度有限制"></a>【误】GET 请求传参长度有限制</h3><p>【误】我们经常说 GET 请求参数的大小存在限制，而 POST 请求的参数大小是无限制的。</p><p>其实这是有问题的，实际上 HTTP 协议从来没规定 GET/POST 的请求长度限制是多少。</p><p>对 GET 请求参数的限制来源于浏览器或者 Web 服务器，是它们限制了这个长度。</p><p>不同的浏览器和 Web 服务器，限制的最大长度不一样。</p><h3 id="【误】POST-方法比-GET-方法安全"><a href="#【误】POST-方法比-GET-方法安全" class="headerlink" title="【误】POST 方法比 GET 方法安全"></a>【误】POST 方法比 GET 方法安全</h3><p>返回目录</p><p>【误】POST 比 GET 安全，是因为数据在地址栏 URL 看不见。</p><p>从传输角度来说，都是 HTTP 在网络上的明文传输，可以通过抓包工具完整获取的。</p><p>如果想安全，那就用 HTTPS 吧。</p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p><code>HTTP</code> 的 <code>keep-alive</code> 也称为 <code>HTTP</code> 长连接。</p><p>它通过重用一个 TCP 连接来发送/接收多个 HTTP 请求，来减少创建/关闭多个 TCP 连接的开销。</p><p>在 HTTP/1.0 协议中，如果请求头中包含：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>则代表开启 keep-alive，而服务端的返回报文头中，也会包含相同的内容。</p><p>在 HTTP/1.1 协议中，默认开启 keep-alive，除非显式地关闭它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>当然，除此之外我们也可以设置断开的时间等：</p><p>Keep-Alive: timeout=5, max=100<br>这个就表示这个 TCP 通道可以保持 5 秒，max=100 表示这个长连接最多接收 100 次请求就断开。</p><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><h3 id="HTTP-状态码为-3-位数，被归为-5-类："><a href="#HTTP-状态码为-3-位数，被归为-5-类：" class="headerlink" title="HTTP 状态码为 3 位数，被归为 5 类："></a>HTTP 状态码为 3 位数，被归为 5 类：</h3><p>1XX：表示目前是协议处理的中间状态，还需要后续操作。<br>2XX：表示成功状态。<br>3XX：重定向状态，资源位置发生变动，需要重新请求。<br>4XX：请求报文有误。<br>5XX：服务器端发生错误。</p><h3 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h3><ul><li>101 Switching Protocols：在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码为 101。<h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3></li><li>200 OK：请求成功状态码，响应体中含有数据。</li><li>204 No Content：含义同 200，但是响应报文不含实体的主体部分。</li><li>206 Partial Content：表示部分内容请求成功。使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段 Content-Range。<h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3></li><li>301 Move Permanently：永久重定向。HTTP 升级 HTTPS，之前站点再也不用，那就是 301。</li><li>302 Found：临时重定向。当前站点暂时不可用，那就是 302，后续可能换回来。</li><li>304 Not Modified：当命中协商缓存时会返回这个状态码。<h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3></li><li>400 Bad Request：请求无效。通常为前后端数据格式不一致或者其他原因。</li><li>403 Forbidden：服务器已经得到请求，但是拒绝执行，比如没权限、法律禁止等。</li><li>404 Not Found：资源未找到，服务器不存在对应的资源。<h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h3></li><li>500 Internal Server Error：服务器报错，有些时候可以在 Response 看到后端 PHP 等技术的报错信息等。</li><li>502 Bad Gateway：服务器正常，但是访问出错。</li><li>503 Service Unavailable：服务器繁忙或者停机维护，暂时无法处理请求。</li></ul><h2 id="解决通讯安全问题"><a href="#解决通讯安全问题" class="headerlink" title="解决通讯安全问题"></a>解决通讯安全问题</h2><ol><li>对称加密： 可以理解为对原始数据的可逆变换</li><li>非对称加密: 有两个秘钥：一个公钥、一个私钥，客户端和服务器使用的是两个不同的秘钥</li><li>对称加密 + 非对称加密： HTTPS 就是采用这种对称加密和非对称加密两者并用的混合加密机制</li><li>第三方认证： 在 HTTPS 中，为了解决无法验证公钥正确性的问题，使用数字证书认证机构（CA）及其颁发的数字证书来解决这个问题。</li><li>第三方认证安全性</li></ol><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS（Domain Name System，域名系统），最初，由于 IP 地址长且难记，通过 IP 访问网站不方便。</p><p>所以后来通过发明了 DNS 服务器，这个时候我们访问网站输入网站域名，DNS 服务器就解析我们的域名为 IP。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>查询 <a href="http://www.baidu.com/">www.baidu.com</a></li><li>访问客户端 DNS 缓存：浏览器缓存 -&gt; 系统缓存（host） -&gt; 路由器缓存</li><li>访问 ISP DNS 服务器（ISP，互联网服务提供商，有联通电信移动等。如果你是电信网络，则进入电信的 DNS 缓存服务器，以下简称本地），如果本地服务器有，则直接返回；如果没有，让本地 DNS 服务器去逐个咨询查找。</li><li>本地去咨询 DNS 根服务器，DNS 根服务器发现是 .com 区域 管理的，告诉本地去咨询它。</li><li>本地去咨询 .com 顶级域服务器，.com 域服务器告诉本地去咨询 baidu.com 主区域 的服务器。</li><li>本地去咨询 baidu.com 主域名服务器，baidu.com 域服务器查找到对应的 IP 地址，返回给本地。</li><li>本地 DNS 云服务器通知用户对方 IP 地址，同时缓存这个 IP 地址，下次就直接访问了。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;HTTP-发展史&quot;&gt;&lt;a href=&quot;#HTTP-发展史&quot; class=&quot;headerlink&quot; title=&quot;HTTP 发展史&quot;&gt;&lt;/a&gt;HTT
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://github.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://github.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>浏览器兼容问题总结</title>
    <link href="http://github.com/2021/02/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://github.com/2021/02/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器兼容问题的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="安卓4-4操作系统下webviewH5页面访问空白？"><a href="#安卓4-4操作系统下webviewH5页面访问空白？" class="headerlink" title="安卓4.4操作系统下webviewH5页面访问空白？"></a>安卓4.4操作系统下webviewH5页面访问空白？</h2><p>原因：该webview浏览器内核版本太低，JavaScript解析器无法解析es5，es6新语法<br>解决步骤：利用babel polyfill对不兼容的语法进行处理</p><h2 id="样式的问题"><a href="#样式的问题" class="headerlink" title="样式的问题"></a>样式的问题</h2><p>问题：金额的前缀不显示，即￥这个标识显示不出来<br>原因： 低版本浏览器对utf-8字符￥不识别<br>解决方案：用html实体编号替代羊角，代码: <code>&lt;sub lang=&quot;en&quot;&gt;&amp;#165;&lt;/sub&gt;</code></p><h2 id="边框不显示"><a href="#边框不显示" class="headerlink" title="边框不显示"></a>边框不显示</h2><p>原因：为了方便编码，配置了px转义成rem的插件,vue.config.js中配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">css: &#123; <span class="comment">// 解决项目中自动添加浏览器厂商前缀等 和自动转换项目中px 到 rem单位</span></span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">        postcss: &#123;</span><br><span class="line">            plugins: [</span><br><span class="line">                <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>), <span class="built_in">require</span>(<span class="string">&#x27;postcss-px2rem&#x27;</span>)(&#123;</span><br><span class="line">                    remUnit: <span class="number">75</span></span><br><span class="line">                &#125;)</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该webpack编译插件致使 边框单位小于1px，浏览器无法渲染小于1px的像素（不同浏览器表现形式不太一样）</p><p>解决方案：从原来的2px改到3px，该解决方法还存在弊端，最好的方法是配置一下该插件对1px-2px不进行转换rem</p><h2 id="商品图片不显示"><a href="#商品图片不显示" class="headerlink" title="商品图片不显示"></a>商品图片不显示</h2><p>原因：之前使用100vw来撑开banner，vw不兼容低版本浏览器，导致banner高度为0</p><p>解决方法：js动态获取屏幕宽度，重新设置banner高度</p><h2 id="常遇到的关于浏览器的宽高问题："><a href="#常遇到的关于浏览器的宽高问题：" class="headerlink" title="常遇到的关于浏览器的宽高问题："></a>常遇到的关于浏览器的宽高问题：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var winW&#x3D;document.body.clientWidth||document.docuemntElement.clientWidth;</span><br><span class="line">&#x2F;&#x2F;网页可见区域宽</span><br><span class="line">var winH&#x3D;document.body.clientHeight||document.docuemntElement.clientHeight;&#x2F;&#x2F;网页可见区域宽</span><br></pre></td></tr></table></figure><p>//以上为不包括边框的宽高，如果是offsetWidth或者offsetHeight的话包括边框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var winWW&#x3D;document.body.scrollWidth||document.docuemntElement.scrollWidth;</span><br><span class="line">&#x2F;&#x2F;整个网页的宽</span><br><span class="line">var winHH&#x3D;document.body.scrollHeight||document.docuemntElement.scrollHeight;&#x2F;&#x2F;整个网页的高</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var scrollHeight&#x3D;document.body.scrollTop||document.docuemntElement.scrollTop;&#x2F;&#x2F;网页被卷去的高</span><br><span class="line">var scrollLeft&#x3D;document.body.scrollLeft||document.docuemntElement.scrollLeft;&#x2F;&#x2F;网页左卷的距离</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var screenH&#x3D;window.screen.height;&#x2F;&#x2F;屏幕分辨率的高</span><br><span class="line">var screenW&#x3D;window.screen.width;&#x2F;&#x2F;屏幕分辨率的宽</span><br><span class="line">var screenX&#x3D;window.screenLeft;&#x2F;&#x2F;浏览器窗口相对于屏幕的x坐标（除了FireFox）</span><br><span class="line">var screenXX&#x3D;window.screenX;&#x2F;&#x2F;FireFox相对于屏幕的X坐标</span><br><span class="line">var screenY&#x3D;window.screenTop;&#x2F;&#x2F;浏览器窗口相对于屏幕的y坐标（除了FireFox）</span><br><span class="line">var screenYY&#x3D;window.screenY;&#x2F;&#x2F;FireFox相对于屏幕的y坐标</span><br></pre></td></tr></table></figure><h2 id="event事件问题："><a href="#event事件问题：" class="headerlink" title="event事件问题："></a>event事件问题：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">document.onclick&#x3D;function(ev)&#123;&#x2F;&#x2F;谷歌火狐的写法，IE9以上支持，往下不支持；</span><br><span class="line">var e&#x3D;ev;</span><br><span class="line">console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">document.onclick&#x3D;function()&#123;&#x2F;&#x2F;谷歌和IE支持，火狐不支持；</span><br><span class="line">var e&#x3D;event;</span><br><span class="line">console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">document.onclick&#x3D;function(ev)&#123;&#x2F;&#x2F;兼容写法；</span><br><span class="line">    var e&#x3D;ev||window.event;</span><br><span class="line">    var mouseX&#x3D;e.clientX;&#x2F;&#x2F;鼠标X轴的坐标</span><br><span class="line">    var mouseY&#x3D;e.clientY;&#x2F;&#x2F;鼠标Y轴的坐标</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="DOM节点相关的问题，我直接封装了函数，以便随时可以拿来使用："><a href="#DOM节点相关的问题，我直接封装了函数，以便随时可以拿来使用：" class="headerlink" title="DOM节点相关的问题，我直接封装了函数，以便随时可以拿来使用："></a>DOM节点相关的问题，我直接封装了函数，以便随时可以拿来使用：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function nextnode(obj)&#123;&#x2F;&#x2F;获取下一个兄弟节点</span><br><span class="line">    if (obj.nextElementSibling) &#123;</span><br><span class="line">      return obj.nextElementSibling;</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">      return obj.nextSibling;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  function prenode(obj)&#123;&#x2F;&#x2F;获取上一个兄弟节点</span><br><span class="line">    if (obj.previousElementSibling) &#123;</span><br><span class="line">      return obj.previousElementSibling;</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">      return obj.previousSibling;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  function firstnode(obj)&#123;&#x2F;&#x2F;获取第一个子节点</span><br><span class="line">    if (obj.firstElementChild) &#123;</span><br><span class="line">      return obj.firstElementChild;&#x2F;&#x2F;非IE678支持</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">      return obj.firstChild;&#x2F;&#x2F;IE678支持</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  function lastnode(obj)&#123;&#x2F;&#x2F;获取最后一个子节点</span><br><span class="line">    if (obj.lastElementChild) &#123;</span><br><span class="line">      return obj.lastElementChild;&#x2F;&#x2F;非IE678支持</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">      return obj.lastChild;&#x2F;&#x2F;IE678支持</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="document-getElementsByClassName问题："><a href="#document-getElementsByClassName问题：" class="headerlink" title="document.getElementsByClassName问题："></a>document.getElementsByClassName问题：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过类名获取元素</span><br><span class="line">  document.getElementsByClassName(&#39;&#39;);&#x2F;&#x2F;IE 6 7 8不支持；</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F;这里可以定义一个函数来解决兼容问题，当然别在这给我提jQuery...</span><br><span class="line">  &#x2F;&#x2F;第一个为全局获取类名，第二个为局部获取类名</span><br><span class="line">  function byClass1(oClass)&#123;&#x2F;&#x2F;全局获取，oClass为你想要查找的类名，没有“.”</span><br><span class="line">    var tags&#x3D;document.all?document.all:document.getElementsByTagName(&#39;*&#39;);</span><br><span class="line">    var arr&#x3D;[];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; tags.length; i++) &#123;</span><br><span class="line">      var reg&#x3D;new RegExp(&#39;\\b&#39;+oClass+&#39;\\b&#39;,&#39;g&#39;);</span><br><span class="line">      if (reg.test(tags[i].className)) &#123;</span><br><span class="line">        arr.push(tags[i]);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr;&#x2F;&#x2F;注意返回的也是数组，包含你传入的class所有元素；</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function byClass2(parentID,oClass)&#123;&#x2F;&#x2F;局部获取类名，parentID为你传入的父级ID</span><br><span class="line">    var parent&#x3D;document.getElementById(parentID);</span><br><span class="line">    var tags&#x3D;parent.all?parent.all:parent.getElementsByTagName(&#39;*&#39;);</span><br><span class="line">    var arr&#x3D;[];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; tags.length; i++) &#123;</span><br><span class="line">    var reg&#x3D;new RegExp(&#39;\\b&#39;+oClass+&#39;\\b&#39;,&#39;g&#39;);</span><br><span class="line">      if (reg.test(tags[i].className)) &#123;</span><br><span class="line">        arr.push(tags[i]);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr;&#x2F;&#x2F;注意返回的也是数组，包含你传入的class所有元素；</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="元素到浏览器边缘的距离："><a href="#元素到浏览器边缘的距离：" class="headerlink" title="元素到浏览器边缘的距离："></a>元素到浏览器边缘的距离：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在这里加个元素到浏览器边缘的距离，很实用</span><br><span class="line">  function offsetTL(obj)&#123;&#x2F;&#x2F;获取元素内容距离浏览器边框的距离（含边框）</span><br><span class="line">    var ofL&#x3D;0,ofT&#x3D;0;</span><br><span class="line">    while(obj)&#123;</span><br><span class="line">      ofL+&#x3D;obj.offsetLeft+obj.clientLeft;</span><br><span class="line">      ofT+&#x3D;obj.offsetTop+obj.clientTop;</span><br><span class="line">      obj&#x3D;obj.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    return&#123;left:ofL,top:ofT&#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器兼容问题的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;安卓4-4操作系统下webviewH5页面访问空白？&quot;&gt;&lt;a href=&quot;#安卓4-4操作系统下webviewH5页面访问空白？&quot; class
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之网络安全</title>
    <link href="http://github.com/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://github.com/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><p>浏览器安全可以分为三大块：</p><ul><li>Web 页面安全</li><li>浏览器网络安全</li><li>浏览器系统安全</li></ul><p>在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。</p><p>这就引出了页面中最基础、最核心的安全策略：同源策略（Same-origin policy）。</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>所谓的同源，是指 协议、域名、端口 一致的情况下，才属于同源。</p><p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</p><h3 id="为什么需要同源策略"><a href="#为什么需要同源策略" class="headerlink" title="为什么需要同源策略"></a>为什么需要同源策略</h3><p>同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p><ol><li><p>第一个，DOM 层面</p><p> 同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p><p> 当你在 A 页面，通过 <code>&lt;a href=&quot;xxx&quot; target=&quot;_blank&quot;&gt;</code> 的形式打开 B 页面，经过下面 2 行代码可以将 A 页面的内容给隐藏掉：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pdom = opener.document;</span><br><span class="line">pdom.body.style.display = <span class="string">&quot;none&quot;</span>;</span><br></pre></td></tr></table></figure><p> 这就是同源情况下 DOM 的一个操作。</p><p> 而不同源的是无法操作的。</p></li><li><p>第二个，数据层面</p></li></ol><p>同源策略限制了不同源的站点读取当前站点的 <code>Cookie</code>、<code>IndexDB</code>、<code>LocalStorage</code> 等数据。</p><p>由于同源策略，我们依然无法通过 B 页面的 <code>opener</code> 来访问 A 页面中的 <code>Cookie</code>、<code>IndexDB</code> 或者 <code>LocalStorage</code> 等内容。</p><ol start="3"><li>第三个，网络层面<br>同源策略限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送给不同源的站点。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ol><ul><li><p><a href="https://juejin.cn/post/6844903842635579405">【面试篇】寒冬求职之你必须要懂的Web安全</a></p></li><li><p><a href="https://zoumiaojiang.com/article/common-web-security/#xss">常见 Web 安全攻防总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;浏览器安全&quot;&gt;&lt;a href=&quot;#浏览器安全&quot; class=&quot;headerlink&quot; title=&quot;浏览器安全&quot;&gt;&lt;/a&gt;浏览器安全&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://github.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://github.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript之基础篇</title>
    <link href="http://github.com/2021/02/01/TypeScript%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://github.com/2021/02/01/TypeScript%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对TS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>let isDone: boolean = false;</code></p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: number = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binaryLiteral: number = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octalLiteral: number = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: string = <span class="string">&quot;bob&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 方式1: 可以在元素类型后面接上 []，表示由此类型元素组成的一个数组</span></span><br><span class="line"><span class="keyword">let</span> list: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 方式2: 使用数组泛型，Array&lt;元素类型&gt;：</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [string, number];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当访问一个越界的元素，会使用联合类型替代</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure><h3 id="枚举（Enum）"><a href="#枚举（Enum）" class="headerlink" title="枚举（Enum）"></a>枚举（Enum）</h3><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。<br>1.数字枚举</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  NORTH,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dir: Direction = Direction.NORTH;</span><br></pre></td></tr></table></figure><p>复制代码默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。上面的枚举示例代码经过编译后会生成以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;NORTH&quot;</span>] = <span class="number">0</span>)] = <span class="string">&quot;NORTH&quot;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;SOUTH&quot;</span>] = <span class="number">1</span>)] = <span class="string">&quot;SOUTH&quot;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;EAST&quot;</span>] = <span class="number">2</span>)] = <span class="string">&quot;EAST&quot;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;WEST&quot;</span>] = <span class="number">3</span>)] = <span class="string">&quot;WEST&quot;</span>;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> dir = Direction.NORTH;</span><br></pre></td></tr></table></figure><p>当然我们也可以设置 NORTH 的初始值，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  NORTH = <span class="number">3</span>,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: any = <span class="number">4</span>;</span><br><span class="line">notSure.ifItExists(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.toFixed(); <span class="comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br></pre></td></tr></table></figure><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void。<br><br>声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p>undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和  void相似，它们的本身的类型用处不是很大</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。<br><br>当你指定了 –strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自。</p><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>never 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。<br><br>never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。<br>使用 object 类型，就可以更好的表示像 Object.create 这样的API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | null</span>): <span class="title">void</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">&#123; prop: <span class="number">0</span> &#125;</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">null</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="number">42</span></span>); // <span class="title">Error</span></span></span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。<br>类型断言有两种形式。 其一是“尖括号”语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (<span class="xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>someValue).length;</span></span><br></pre></td></tr></table></figure><p>另一个为 as 语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (someValue <span class="keyword">as</span> string).length;</span><br></pre></td></tr></table></figure><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。</p><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>联合类型使用 | 分隔每个类型。</p><p>这里的 let myFavoriteNumber: string | number 的含义是，允许 myFavoriteNumber 的类型是 string 或者 number，但是不能是其他类型。</p><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>TypeScript 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">  id: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IWorker &#123;</span><br><span class="line">  companyId: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IStaff = IPerson &amp; IWorker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> staff: IStaff = &#123;</span><br><span class="line">  id: <span class="string">&#x27;E1006&#x27;</span>,</span><br><span class="line">  age: <span class="number">33</span>,</span><br><span class="line">  companyId: <span class="string">&#x27;EFT&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(staff)</span><br></pre></td></tr></table></figure><p>在上面示例中，我们首先为 <code>IPerson</code> 和 <code>IWorker</code> 类型定义了不同的成员，然后通过 <code>&amp; </code>运算符定义了 <code>IStaff </code> 交叉类型，所以该类型同时拥有<code>IPerson</code>和 <code>IWorker </code>这两种类型的成员。</p><h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(<code>interface</code>)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person &#x3D; &#123;</span><br><span class="line">    name: &#39;Tom&#39;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接口一般首字母大写。有的编程语言中会建议接口的名称加上 I 前缀。</p><p>定义的变量比接口少了一些属性是不允许的,多一些属性也是不允许的,赋值的时候，变量的形状必须和接口的形状保持一致。</p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但仍然不允许添加未定义的属性：</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly 来指定只读属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">    readonly y: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过赋值一个对象字面量来构造一个 Point 。 赋值后， x 和 y 再也不能被改变了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1: Point = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line">p1.x = <span class="number">5</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>TypeScript 具有 ReadonlyArray<T> 类型，它与 Array<T> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;number&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，可以看到就算把整个 ReadonlyArray 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> number[];</span><br></pre></td></tr></table></figure><h3 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h3><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    gender: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>[propName: string]</code> 定义了任意属性取<code>string</code>类型的值。</p><p>需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><h3 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myAdd has the full function type</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="comment">// The parameters `x` and `y` have the type number</span></span><br><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">baseValue: number, increment: number</span>) =&gt;</span> number = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, lastName: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">&quot;Bob&quot;</span>);                  <span class="comment">// error, too few parameters</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>, <span class="string">&quot;Sr.&quot;</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>);         <span class="comment">// ah, just right</span></span><br></pre></td></tr></table></figure><p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在 TypeScript 里我们可以在参数名旁使用 ? 实现可选参数的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, lastName?: string</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>在 TypeScript 里，你可以把所有参数收集到一个变量里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, ...restOfName: string[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">&quot;Joseph&quot;</span>, <span class="string">&quot;Samuel&quot;</span>, <span class="string">&quot;Lucas&quot;</span>, <span class="string">&quot;MacKinzie&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="TypeScript-泛型"><a href="#TypeScript-泛型" class="headerlink" title="TypeScript 泛型"></a>TypeScript 泛型</h3><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。<br><br>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。<br><br>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。<br><br>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">  (arg: T): T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  zeroValue: T;</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;number&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="泛型变量"><a href="#泛型变量" class="headerlink" title="泛型变量"></a>泛型变量</h3><p>对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：</p><ul><li>T（Type）：表示一个 TypeScript 类型</li><li>K（Key）：表示对象中的键类型</li><li>V（Value）：表示对象中的值类型</li><li>E（Element）：表示元素类型</li></ul><h3 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h3><p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。</p><ol><li>typeof<br>在 TypeScript 中，typeof 操作符可以用来获取一个变量声明或对象的类型。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sem: Person = &#123; <span class="attr">name</span>: <span class="string">&#x27;semlinker&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line">type Sem= <span class="keyword">typeof</span> sem; <span class="comment">// -&gt; Person</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">x: number</span>): <span class="title">Array</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Func = <span class="keyword">typeof</span> toArray; <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br></pre></td></tr></table></figure></li><li>keyof</li></ol><p>keyof 操作符可以用来一个对象中的所有 key 值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type K1 = keyof Person; <span class="comment">// &quot;name&quot; | &quot;age&quot;</span></span><br><span class="line">type K2 = keyof Person[]; <span class="comment">// &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot; </span></span><br><span class="line">type K3 = keyof &#123; [x: string]: Person &#125;;  <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure><ol start="3"><li>in</li></ol><p>in 用来遍历枚举类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Keys = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line">type Obj =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: any</span><br><span class="line">&#125; <span class="comment">// -&gt; &#123; a: any, b: any, c: any &#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>infer</li></ol><p>在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type ReturnType&lt;T&gt; &#x3D; T extends (</span><br><span class="line">  ...args: any[]</span><br><span class="line">) &#x3D;&gt; infer R ? R : any;</span><br></pre></td></tr></table></figure><p>以上代码中 <code>infer R</code> 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。<br>5. extends</p><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ILengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error, number doesn&#x27;t have a .length property</span></span><br></pre></td></tr></table></figure><p>这时我们需要传入符合约束类型的值，必须包含必须的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(&#123;<span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><ol start="6"><li>Partial</li></ol><p><code>Partial&lt;T&gt;</code> 的作用就是将某个类型里的属性全部变为可选项 <code>?</code>。<br>定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts</span><br><span class="line"> * Make all properties in T optional</span><br><span class="line"> *&#x2F;</span><br><span class="line">type Partial&lt;T&gt; &#x3D; &#123;</span><br><span class="line">  [P in keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在以上代码中，首先通过 <code>keyof T</code> 拿到 <code>T</code> 的所有属性名，然后使用 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后通过 <code>T[P]</code> 取得相应的属性值。中间的 <code>?</code> 号，用于将所有属性变为可选。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Todo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  description: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTodo</span>(<span class="params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo1 = &#123;</span><br><span class="line">  title: <span class="string">&quot;organize desk&quot;</span>,</span><br><span class="line">  description: <span class="string">&quot;clear clutter&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo2 = updateTodo(todo1, &#123;</span><br><span class="line">  description: <span class="string">&quot;throw out trash&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的 <code>updateTodo</code> 方法中，我们利用 <code>Partial&lt;T&gt;</code> 工具类型，定义 <code>fieldsToUpdate</code> 的类型为 <code>Partial&lt;Todo&gt;</code>，<br>即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   title?: string | <span class="literal">undefined</span>;</span><br><span class="line">   description?: string | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://juejin.cn/post/6844903842635579405">【面试篇】寒冬求职之你必须要懂的Web安全</a></p></li><li><p><a href="https://zoumiaojiang.com/article/common-web-security/#xss">常见 Web 安全攻防总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对TS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;基础类型&quot;&gt;&lt;a href=&quot;#基础类型&quot; class=&quot;headerlink&quot; title=&quot;基础类型&quot;&gt;&lt;/a&gt;基础类型&lt;/h2&gt;&lt;h3 id=&quot;布
      
    
    </summary>
    
    
      <category term="TypeScript" scheme="http://github.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://github.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>JS之DOM事件流</title>
    <link href="http://github.com/2021/01/31/JS%E4%B9%8BDOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <id>http://github.com/2021/01/31/JS%E4%B9%8BDOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2021-01-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><blockquote><p>事件流描述的是从页面中接收事件的顺序</p></blockquote><p>DOM2级事件流包括下面几个阶段。</p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><h2 id="事件冒泡与事件捕获"><a href="#事件冒泡与事件捕获" class="headerlink" title="事件冒泡与事件捕获"></a>事件冒泡与事件捕获</h2><p>事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;outer&quot;</span>&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;inner&quot;</span>&gt;Click me!&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？为了解决这个问题微软和网景提出了两种几乎完全相反的概念。</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>微软(IE)提出了名为事件冒泡(event bubbling)的事件流。</p><p>事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。</p><p>因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是:</p><p>p -&gt; div -&gt; body -&gt; html -&gt; document</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>网景提出另一种事件流名为事件捕获(event capturing)。</p><p>与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。</p><p>上面的例子在事件捕获的概念下发生click事件的顺序应该是:</p><p>document -&gt; html -&gt; body -&gt; div -&gt; p</p><h3 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h3><blockquote><p>W3C 对这两种方案进行了统一：将 DOM 事件分为两个阶段，事件捕获和事件冒泡阶段</p></blockquote><p>当一个元素被点击，首先是事件捕获阶段，window 最先接收事件，然后一层一层往下捕获，最后由具体元素接收；之后再由具体元素再一层一层往上冒泡，到 window 接收事件。</p><h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h3><blockquote><p>E浏览器对addEventListener兼容性并不算太好，只有IE9以上可以使用。</p></blockquote><p><code>DOM2级事件</code>中规定的事件流同时支持了事件捕获阶段和事件冒泡阶段，而作为开发者，我们可以选择事件处理函数在哪一个阶段被调用。</p><p><code>addEventListener</code>方法用来为一个特定的元素绑定一个事件处理函数，是<code>JavaScript</code>中的常用方法。</p><blockquote><p><code>element.addEventListener(event, function, useCapture)</code></p></blockquote><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">event</td><td align="left">必须。字符串，指定事件名。<br>注意: 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。<br>提示： 所有 HTML DOM 事件，</td></tr><tr><td align="left">function</td><td align="left">必须。指定要事件触发时执行的函数。<br>当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。<br>例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。</td></tr><tr><td align="left">useCapture</td><td align="left">可选。布尔值，指定事件是否在捕获或冒泡阶段执行。<br>可能值:<br>true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）<br>false(默认值)。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）</td></tr></tbody></table><h3 id="如何让事件先冒泡后捕获"><a href="#如何让事件先冒泡后捕获" class="headerlink" title="如何让事件先冒泡后捕获"></a>如何让事件先冒泡后捕获</h3><p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。</p><h2 id="事件委托-代理"><a href="#事件委托-代理" class="headerlink" title="事件委托(代理)"></a>事件委托(代理)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</p><h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2><ol><li>给子级加 <code>event.stopPropagation( )</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#div1&quot;</span>).mousedown(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=event||<span class="built_in">window</span>.event;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>在事件处理函数中返回 <code>false</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#div1&quot;</span>).mousedown(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=e||<span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>但是这两种方式是有区别的。</li></ol><ul><li><code>return false</code> 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。</li><li><code>event.stopPropagation()</code>则只阻止事件往上冒泡，不阻止事件本身。</li></ul><p>3.  <code>event.target==event.currentTarget</code>，让触发事件的元素等于绑定事件的元素，也可以阻止事件冒泡；</p><h2 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h2><ul><li>（1）event.preventDefault( )</li><li>（2）return false</li></ul><h2 id="并不是所有的事件都有冒泡"><a href="#并不是所有的事件都有冒泡" class="headerlink" title="并不是所有的事件都有冒泡"></a>并不是所有的事件都有冒泡</h2><p>例如：</p><ul><li><code>onblur</code></li><li><code>onfocus</code></li><li><code>onmouseenter</code></li><li><code>onmouseleave</code></li></ul><h2 id="onmouseover-和-onmouseenter-区别"><a href="#onmouseover-和-onmouseenter-区别" class="headerlink" title="onmouseover 和 onmouseenter 区别"></a>onmouseover 和 onmouseenter 区别</h2><ul><li><p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</p></li><li><p>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</p></li></ul><p>这两者都是移入的时候触发，但是 onmouseover 会触发多次，而 onmouseenter 只在进去的时候才触发。</p><h2 id="JS-位置"><a href="#JS-位置" class="headerlink" title="JS 位置"></a>JS 位置</h2><ul><li><code>clientHeight</code>：表示可视区域的高度，不包含 <code>border</code> 和滚动条</li><li><code>offsetHeight</code>：表示可视区域的高度，包含了 <code>border</code> 和滚动条</li><li><code>scrollHeight</code>：表示了所有区域的高度，包含了因为滚动被隐藏的部分</li><li><code>clientTop</code>：表示边框 border 的厚度，在未指定的情况下一般为0</li><li><code>scrollTop</code>：滚动后被隐藏的高度，获取对象相对于由 <code>offsetParent </code>属性指定的父坐标（CSS 定位的元素或 body 元素）距离顶端的高度。</li></ul><h2 id="js拖拽功能的实现"><a href="#js拖拽功能的实现" class="headerlink" title="js拖拽功能的实现"></a>js拖拽功能的实现</h2><ol><li>通过 mousedown、mousemove、mouseup 方法实现</li></ol><ul><li><p>首先是三个事件，分别是mousedown，mousemove，mouseup,当鼠标点击按下的时候，需要一个tag标识此时已经按下，可以执行mousemove里面的具体方法。</p></li><li><p>clientX，clientY标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用offsetX和offsetY来表示元素的元素的初始坐标，<br><br>移动的举例应该是：<br><br>鼠标移动时候的坐标-鼠标按下去时候的坐标。<br><br>也就是说定位信息为：<br><br>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft.<br></p></li></ul><ol start="2"><li>可以通过html5的拖放（Drag 和 drop）来实现</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903834075021326#heading-0">你真的理解事件冒泡和事件捕获吗</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h2&gt;&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之从重绘和重排</title>
    <link href="http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/"/>
    <id>http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/</id>
    <published>2021-01-29T16:00:00.000Z</published>
    <updated>2021-01-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><blockquote><p>回流必将引起重绘，重绘不一定会引起回流</p></blockquote><h2 id="浏览器的渲染"><a href="#浏览器的渲染" class="headerlink" title="浏览器的渲染"></a>浏览器的渲染</h2><ol><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display:将像素发送给GPU，展示在页面上。</li></ol><h2 id="回流-Reflow-重绘"><a href="#回流-Reflow-重绘" class="headerlink" title="回流 (Reflow)(重绘)"></a>回流 (Reflow)(重绘)</h2><p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p><h3 id="会导致回流的操作："><a href="#会导致回流的操作：" class="headerlink" title="会导致回流的操作："></a>会导致回流的操作：</h3><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除可见的DOM元素</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法</li></ul><h3 id="一些常用且会导致回流的属性和方法："><a href="#一些常用且会导致回流的属性和方法：" class="headerlink" title="一些常用且会导致回流的属性和方法："></a>一些常用且会导致回流的属性和方法：</h3><ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>scrollIntoView()、scrollIntoViewIfNeeded()</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li><li>scrollTo()</li></ul><h2 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘 (Repaint)"></a>重绘 (Repaint)</h2><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><h3 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h3><p>回流比重绘的代价要更高。</p><p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</p><p>现代浏览器会对频繁的回流或重绘操作进行优化：</p><p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p><p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p><ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>width、height</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li></ul><p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p><h3 id="如何触发重绘？"><a href="#如何触发重绘？" class="headerlink" title="如何触发重绘？"></a>如何触发重绘？</h3><ul><li>修改背景色、颜色（background、color）</li><li>设置可见度（visibility）</li><li>设置背景图（background-image）</li></ul><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><p>CSS</p><ul><li>避免使用table布局。</li><li>尽可能在DOM树的最末端改变class。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到position属性为absolute或fixed的元素上。</li><li>避免使用CSS表达式（例如：calc()）。</li></ul><p>JavaScript</p><ul><li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li><li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li><li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><h2 id="减少重绘和回流的细节："><a href="#减少重绘和回流的细节：" class="headerlink" title="减少重绘和回流的细节："></a>减少重绘和回流的细节：</h2><ol><li>使用 translate 替代 top</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>尽量算出结果再去重绘把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame  Load 和 DOMContentLoaded 区别。Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000017329980">你真的了解回流和重绘吗</a></li><li><a href="https://juejin.cn/post/6844903569087266823">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></li><li><a href="https://juejin.cn/post/6844903569087266823">回流与重绘：CSS性能让JavaScript变慢？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;回流必将引起重绘，重绘不一定会引起回流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;浏览器的渲染&quot;&gt;&lt;a href=&quot;#浏览器
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之从输入 URL 到页面呈现</title>
    <link href="http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0/"/>
    <id>http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0/</id>
    <published>2021-01-29T16:00:00.000Z</published>
    <updated>2021-01-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改（浏览器的工作原理）</p><h2 id="整体过程"><a href="#整体过程" class="headerlink" title="整体过程"></a>整体过程</h2><p>在用户输入 URL，按下回车之后，走过的步骤：</p><ul><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器响应</li><li>浏览器解析渲染页面</li></ul><h2 id="具体阶段"><a href="#具体阶段" class="headerlink" title="具体阶段"></a>具体阶段</h2><ul><li>用户输入阶段</li><li>发起URL请求阶段</li><li>准备渲染进程阶段</li><li>提交文档阶段</li><li>页面渲染阶段</li></ul><h2 id="用户输入阶段"><a href="#用户输入阶段" class="headerlink" title="用户输入阶段"></a>用户输入阶段</h2><ul><li>合成 URL：用户输入 URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容 + 默认搜索引擎合成新的 URL；如果用户输入的内容符合 URL 规则，浏览器就会根据 URL 协议，在这段内容上加上协议合成合法的 URL；</li><li>加载：用户输入完内容，按下回车键，浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得；</li></ul><h2 id="发起URL请求阶段"><a href="#发起URL请求阶段" class="headerlink" title="发起URL请求阶段"></a>发起URL请求阶段</h2><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/30/XovFHrwqVeN37ds.png"></p><h3 id="开始阶段"><a href="#开始阶段" class="headerlink" title="开始阶段"></a>开始阶段</h3><ol><li><p>构建请求：浏览器进程首先会构建请求行信息，然后通过进程间通信（IPC）将 URL 请求发送给网络进程；</p></li><li><p>查找缓存：网络进程获取到 URL，先去本地缓存中查找是否有缓存资源，如果有则拦截请求，直接将缓存资源返回给浏览器进程；否则，进入网络请求阶段；</p></li></ol><h3 id="网络请求阶段-从服务器获取资源"><a href="#网络请求阶段-从服务器获取资源" class="headerlink" title="网络请求阶段(从服务器获取资源)"></a>网络请求阶段(从服务器获取资源)</h3><ol><li><p><code>DNS</code> 解析：网络进程请求首先会从 <code>DNS</code> 数据缓存服务中查找是否缓存过当前域名信息，有则直接返回；否则，会进行 DNS 解析返回域名对应的 IP 和端口号，如果没有指定端口号，<code>http</code> 默认<code> 80</code> 端口，<code>https</code> 默认 <code>443</code>。如果是 <code>https</code> 请求，还需要建立 <code>TLS</code> 连接；</p></li><li><p>等待 <code>TCP</code> 队列：<code>Chrome</code> 有个机制，同一个域名同时最多只能建立 <code>6</code> 个 <code>TCP</code> 连接，如果在同一个域名下同时有 <code>10 </code>个请求发生，那么其中 <code>4</code> 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于<code>6</code>个，会直接建立 <code>TCP</code> 连接；</p></li><li><p>建立 <code>TCP</code> 连接：<code>TCP</code> 三次握手与服务器建立连接，然后进行数据的传输，最后；</p></li><li><p>发送 <code>HTTP</code> 请求：浏览器首先会向服务器发送请求行，它包含了请求方法、请求 <code>URI</code> 和 <code>HTTP</code> 协议的版本；另外还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核，请求域名、<code>Cookie</code> 等；如果需要传递参数，则还需要发送请求体；</p></li><li><p>服务器处理请求：服务器首先返回响应行，包括协议版本和状态码，比如状态码 <code>200</code> 表示继续处理该请求；（如果是 <code>301</code>，则表示重定向，将会在响应头的 <code>Locaiton</code> 字段中加上重定向的地址信息，接下来浏览器获取这个地址，将会重新导航。）服务器也会向浏览器发送响应头，包含了一些信息，比如服务器生成返回数据的时间、返回的数据类型（<code>JSON</code>、<code>HTML</code>、<code>流媒体</code>等类型），以及服务器要在客户端保存的 <code>Cookie</code> 等；继续发送响应体的数据；(服务器处理请求完毕后，会返回 HTTP 报文)</p></li><li><p>断开 <code>TCP</code> 连接：数据传输完成，正常情况下 <code>TCP</code> 将四次挥手断开连接。但是如果浏览器或者服务器在<code>HTTP</code>头部加上 <code>Connection: keep-alive</code>，<code>TCP</code> 就会一直保持连接。保持 <code>TCP</code> 连接可以省下下次需要建立连接的时间，提示资源加载速度；</p></li></ol><h2 id="准备渲染进程阶段"><a href="#准备渲染进程阶段" class="headerlink" title="准备渲染进程阶段"></a>准备渲染进程阶段</h2><blockquote><p>将获取到的数据包进行解析</p></blockquote><ol><li><p>网络进程将获取到的数据包进行解析，根据响应头中的 <code>Content-type</code> 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是 <code>text/html</code> 类型，就通知浏览器进程获取到的是 <code>HTML</code>，应该准备渲染进程了；</p></li><li><p>正常情况下每个浏览器的 <code>tab</code> 会对应一个渲染进程，但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程，否则就会创建一个新的渲染进程；</p></li></ol><h2 id="提交文档阶段"><a href="#提交文档阶段" class="headerlink" title="提交文档阶段"></a>提交文档阶段</h2><ol><li><p>渲染进程准备好后，浏览器会发出 <code>&quot;提交文档&quot;</code> 的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的 <code>&quot;管道&quot;</code>，文档数据传输完成后，渲染进程会返回<code>&quot;确认提交&quot;</code>的消息给浏览器进程；</p></li><li><p>浏览器收到 <code>&quot;确认提交&quot;</code> 的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 <code>web</code> 页面，此时的 <code>web</code> 页面是空白页；</p></li></ol><h2 id="页面渲染阶段"><a href="#页面渲染阶段" class="headerlink" title="页面渲染阶段"></a>页面渲染阶段</h2><ol><li><p>文档一旦提交，渲染进程将开始页面解析和子资源加载；渲染阶段比较复杂，所以将分为多个子阶段，按照渲染的时间顺序可以分为：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成；</p></li><li><p>构建 DOM 树：HTML 经过解析器后输出一个以 document 为顶层节点的树状结构的 DOM；</p></li><li><p>样式计算：这里有 3 个步骤：</p><ul><li>将 3 个来源（<code>&lt;link&gt;</code> 标签引入的外部样式、<code>&lt;style&gt;</code> 标签里定义的样式、以及元素的 <code>style</code> 属性上的样式）的 <code>CSS</code> 转化成浏览器能够理解的结构 <code>styleSheets</code>；</li><li>转换样式表中的属性值，使其标准化；比如 <code>font-weight: bold</code>; 会转成 <code>font-weight: 700</code>;， <code>color: blue</code>; 会转成 <code>color: rgb(0, 0, 255)</code>; 等；</li><li>依据 <code>CSS</code> 的继承和层叠规则计算出 <code>DOM</code> 树中每个节点的具体样式；</li></ul></li><li><p>布局阶段：<code>DOM</code> 树中依然存在许多不可见的元素（比如 <code>head</code>），这些元素对于布局是丝毫没用的，所以又会生成一棵只包含可见元素的布局树；然后再根据布局树的每个节点计算出其具体位置和尺寸大小；</p></li><li><p>分层：页面中有很多复杂的效果，如一些复杂的 <code>3D</code> 变换、页面滚动，或者使用 <code>z-index</code> 做 <code>z</code> 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树；关于层叠上下文的知识，具体可以参考这里彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、<code>z-index</code>；</p></li><li><p>绘制：为每个图层生成绘制列表，并将其提交到合成线程；</p></li><li><p>光栅化：通常一个页面很大，而视口很局限，所以合成线程会按照视口附近的图块来优先生成位图，并在光栅化线程池中将图块转换成位图；</p></li><li><p>合成：一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令 <code>DrawQuad</code>，然后将该命令提交给浏览器进程；之后浏览器将开始生成显示页面。</p></li></ol><h2 id="渲染过程（此为面试回答）"><a href="#渲染过程（此为面试回答）" class="headerlink" title="渲染过程（此为面试回答）"></a>渲染过程（此为面试回答）</h2><h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><ul><li>解析 <code>HTML</code>，生成 <code>DOM</code> 树</li><li>解析 <code>CSS</code>，生成 <code>CSS</code> 规则树（<code>CSS Rule Tree</code>）</li><li>将 <code>DOM Tree</code> 和 <code>CSS Rule Tree</code> 相结合，生成 渲染树（<code>Render Tree</code>）</li><li>从根节点开始，计算每一个元素的大小、位置，给出每个节点所应该出现的屏幕精确坐标，(计算每个节点的位置)从而得到基于渲染树的 布局渲染树（<code>Layout of the render tree</code>）。</li><li>遍历渲染树，将每个节点用 <code>UI</code> 渲染引擎来绘制，从而将整棵树绘制到页面上，这个步骤叫 绘制渲染树（<code>Painting the render tree</code>）(调用 GPU 绘制，合成图层，显示在屏幕上)</li></ul><h3 id="在解析渲染过程中，可能会产生-回流-和-重绘："><a href="#在解析渲染过程中，可能会产生-回流-和-重绘：" class="headerlink" title="在解析渲染过程中，可能会产生 回流 和 重绘："></a>在解析渲染过程中，可能会产生 回流 和 重绘：</h3><ul><li><p>重绘(repaint)：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此损耗较少。</p></li><li><p>回流(reflow)：又叫重排（layout）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。</p></li></ul><h3 id="渲染过程碰到-JS-文件"><a href="#渲染过程碰到-JS-文件" class="headerlink" title="渲染过程碰到 JS 文件"></a>渲染过程碰到 JS 文件</h3><blockquote><p>JavaScript 的加载、解析和执行会阻塞 DOM 的构建。</p></blockquote><p>在构建 <code>DOM</code> 的时候，<code>HTML</code> 解析器如果碰到 <code>JavaScript</code>，那么就会停止构建 <code>DOM</code>，将控制权交给 <code>JavaScript</code> 引擎，等 <code>JavaScript</code> 运行完毕，浏览器再从中断的地方恢复 <code>DOM</code> 构建。</p><p>也就是说：首屏渲染越快，就越不应该在首屏的时候加载 JS 文件，这也就是建议将 script 标签放到 body 标签底部，或者给 script 标签添加 defer/async 属性的原因。</p><h3 id="为什么操作-DOM-慢"><a href="#为什么操作-DOM-慢" class="headerlink" title="为什么操作 DOM 慢"></a>为什么操作 DOM 慢</h3><ol><li>涉及 JS 引擎和渲染引擎两个线程间的通信，损耗性能。</li><li>操作 DOM 可能会重复回流，加剧性能损耗。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6909258409250553869">「面试常问」从输入 URL 到显示发生了什么（ 99 分答案）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改（浏览器的工作原理）&lt;/p&gt;
&lt;h2 id=&quot;整体过程&quot;&gt;&lt;a href=&quot;#整体过程&quot; class=&quot;headerlink&quot; title=&quot;整体过程&quot;&gt;&lt;/a&gt;整体过程&lt;/h
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之本地存储</title>
    <link href="http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <id>http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</id>
    <published>2021-01-27T16:00:00.000Z</published>
    <updated>2021-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="HTTP无状态"><a href="#HTTP无状态" class="headerlink" title="HTTP无状态"></a>HTTP无状态</h2><blockquote><p>HTTP无状态协议，是指协议对于交互性场景没有记忆能力。</p></blockquote><p><code>HTTP</code> 是无状态的，即它不会记住用户的操作，服务器单纯从网络连接上无从知道客户身份, 这让我们在记住用户状态等场景被限制</p><p>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。</p><p>比如服务器不知道某个用户是否已登录过了。因为愚蠢的服务器不知道客户端是否已登录过了,所以每次都要在交互场景(会话)中请求中带上上一次的请求信息，如账号、密码。明明只需要在<code>/login</code>接口中，才需要对比数据库中的账号密码和客户端传的是否一致来确定合法性。这下在添加购物车中也需要再一次的进行同样的重复且没有必要的操作，即降低了响应速度，又对用户不友好（因为每次都需要填账号，密码）。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><code>Cookie</code> 最开始被设计出来其实并不是来做本地存储的，而是为了弥补 <code>HTTP</code> 在状态管理上的不足。</p><p><code>Cookie</code> 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。</p><p>向同一个域名下发送请求，都会携带相同的 <code>Cookie</code>，服务器拿到 <code>Cookie</code> 进行解析，便能拿到客户端的状态。</p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol><li><p>A: 首先，客户端会发送一个<code>http</code>请求到服务器端。</p></li><li><p>B: 服务器端接受客户端请求后，发送一个<code>http</code>响应到客户端，这个响应头，其中就包含<code>Set-Cookie</code>头部。</p></li><li><p>C: 在客户端发起的第二次请求（注意：如果服务器需要我们带上<code>Cookie</code>，我们就需要在B步骤上面拿到这个<code>Cookie</code>然后作为请求头一起发起第二次请求），提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了<code>cookies</code>。尽管，用户可能在和应用程序交互的过程中突然禁用<code>cookies</code>的使用，但是，这个情况基本是不太可能发生的，所以可以不加以考虑，这在实践中也被证明是对的。</p></li></ol><h3 id="Cookie的不可跨域名性"><a href="#Cookie的不可跨域名性" class="headerlink" title="Cookie的不可跨域名性"></a>Cookie的不可跨域名性</h3><p><code>Cookie</code>具有不可跨域名性。根据<code>Cookie</code>规范，浏览器访问<code>Google</code>只会携带<code>Google</code>的<code>Cookie</code>，而不会携带<code>Baidu</code>的<code>Cookie</code>。<code>Google</code>也只能操作<code>Google</code>的<code>Cookie</code>，而不能操作<code>Baidu</code>的<code>Cookie</code>。</p><p><code>Cookie</code>在客户端是由浏览器来管理的。浏览器能够保证<code>Google</code>只会操作<code>Google</code>的<code>Cookie</code>而不会操作<code>Baidu</code>的<code>Cookie</code>，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站<code>Cookie</code>的依据是域名。<code>Google</code>与<code>Baidu</code>的域名不一样，因此<code>Google</code>不能操作<code>Baidu</code>的<code>Cookie</code>。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>cookie, 如果不设置过期时间，cookie保存在内存中，生命周期随浏览器的关闭而结束，如果设置了过期时间，cookie保存在硬盘中，关闭浏览器，cookie数据直到过期时间而消失；cookie是服务器发给客户端的特殊信息，cookie是以文本的形式保存在客户端，每次请求都会带上它；</p><h3 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h3><ul><li>容量缺陷。体积上线 4kb，只能存储少量信息。用户禁用cookie,就会使其功能受限</li><li>性能缺陷。Cookie 请求每次都会携带上完整的 Cookie，随着请求数增多，造成性能浪费。</li><li>安全缺陷。以纯文本的形式在浏览器和服务器中传递，容易被非法截获和篡改。</li></ul><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><h3 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h3><p><code>Local Storge</code> 相对 <code>Cookie</code> 而言，它也是针对同一个域名。<br>同一个域名下，会存储相同的一段 <code>Local Storage</code>。</p><h4 id="设置与取值"><a href="#设置与取值" class="headerlink" title="设置与取值"></a>设置与取值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置：</span></span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jsliang&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;jsliang&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&quot;info&quot;</span>, <span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值：</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> info = <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;info&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="相比-Cookie-优势"><a href="#相比-Cookie-优势" class="headerlink" title="相比 Cookie 优势"></a>相比 Cookie 优势</h4><ol><li>容量。体积上线 <code>5M</code>，大于 <code>Cookie</code> 的 <code>4kb</code>。</li><li>只存在客户端。不参与和服务端的通讯，避免 <code>Cookie</code> 的性能缺陷和安全缺陷。</li><li>接口封装。有 <code>setItem</code> 和 <code>getItem</code> 两个<code>API</code>接口。</li></ol><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ol><li>以 <code>Base64</code> 方式存储官方 <code>Logo</code> 等图片。</li></ol><h3 id="Session-Storage"><a href="#Session-Storage" class="headerlink" title="Session Storage"></a>Session Storage</h3><p>基本上和 <code>Local Stoarge</code> 一致。</p><h4 id="相比Local-Storage："><a href="#相比Local-Storage：" class="headerlink" title="相比Local Storage："></a>相比Local Storage：</h4><p>会话级别的存储。不同于 <code>Local Storage</code> 的持续化存储，<code>Session Storage</code> 当页面关闭的时候就不复存在了。</p><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><ol><li><p>对表单信息做维护。用户刷新页面不丢失。</p></li><li><p>存储本次浏览记录。看过的页面不怕找不到。</p><h3 id="localStorage和sessionStorage："><a href="#localStorage和sessionStorage：" class="headerlink" title="localStorage和sessionStorage："></a>localStorage和sessionStorage：</h3></li><li><p>生命周期：localStorage的生命周期是永久的，关闭页面也不会消失，除非是主动删除；sessionStorage的生命周期是仅在当前会话下有效</p></li><li><p>存储大小：localStorage和sessionStorage的存储数据一般都是5mb;</p></li><li><p>存储内容类型：都只能存储字符串类型；</p></li><li><p>获取方式：localStorage: window.localStorage; sessionStorage: window.sessionStorage;</p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexedDB 是运行在浏览器中的 非关系型数据库。</p></li></ol><p>因为本质上是数据库，所以一般来说容量是没有上线的。</p><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token只能被保存在客户端的cookie或localstorage中，因为用户的状态在服务端的内存中是不能存储的，所以这是一种无状态的认证机制；</p><h3 id="为什么需要token"><a href="#为什么需要token" class="headerlink" title="为什么需要token"></a>为什么需要token</h3><p>众所周知，HTTP 是无状态协议，即它对于交互性场景没有记忆能力。</p><p>但是，如果碰到某些场景，就有点无奈了：</p><ul><li>输入账号密码进行登录</li><li>将商品加入购物车</li><li>点击支付，发现用户要重新登录</li></ul><p>我们可以通过 token 来维持用户的登录态</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><blockquote><p>用户 id + 过期时间 + SecretKey</p></blockquote><p><code>&quot;用户 id&quot; + &quot;过期时间&quot; + SHA1(&quot;用户 id&quot; + &quot;用户口令&quot; + &quot;过期时间&quot; + &quot;SecretKey&quot;)</code></p><p>这样，当浏览器发送请求给服务器，token 会通过 cookie 等形式将上面实例内容传输给服务器。</p><p>服务器拿到数据后，根据用户 id 查找用户口令，并进一步计算是否已过期，从而判断用户是否需要重新登录。</p><p>需要重新登录则跳转到登录页面，不需要重新登录则进行支付流程。</p><h4 id="token认证流程"><a href="#token认证流程" class="headerlink" title="token认证流程"></a>token认证流程</h4><ol><li>用户登录校验，校验成功后就返回<code>Token</code>给客户端;</li><li>客户端收到数据后就保存在客户端;</li><li>客户端每次访问<code>api</code>就携带<code>Token</code>到服务端 ;</li><li>服务端采用<code>filter</code>过滤器校验，校验成功后返回请求数据，校验失败则返回校验码；<h4 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h4></li></ol><p>A：当用户首次登录成功（注册也是一种可以适用的场景）之后, 服务器端就会生成一个token值，这个值，会在服务器保存token值(保存在数据库中)，再将这个token值返回给客户端。</p><p>B：客户端拿到token值之后,进行本地保存（SP存储是大家能够比较支持和易于理解操作的存储）。</p><p>C：当客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个token值附带到参数中发送给服务器。</p><p>D：服务器接收到客户端的请求之后,会取出token值与保存在本地(数据库)中的token值做对比:</p><ul><li>对比一：如果两个 token 值相同， 说明用户登录成功过!当前用户处于登录状态！</li><li>对比二：如果没有这个 token 值, 则说明没有登录成功。</li><li>对比三：如果 token 值不同: 说明原来的登录信息已经失效,让用户重新登录。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ul><ul><li><a href="https://blog.csdn.net/qq_36632174/article/details/102402203">cookie、Session、Token、sessionStorage、localStorage简介</a></li><li><a href="https://blog.csdn.net/yinge0508/article/details/95761173">session,cookie,sessionStorage,localStorage,token的区别？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;HTTP无状态&quot;&gt;&lt;a href=&quot;#HTTP无状态&quot; class=&quot;headerlink&quot; title=&quot;HTTP无状态&quot;&gt;&lt;/a&gt;HTTP无状态&lt;
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之跨域</title>
    <link href="http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E8%B7%A8%E5%9F%9F/"/>
    <id>http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E8%B7%A8%E5%9F%9F/</id>
    <published>2021-01-27T16:00:00.000Z</published>
    <updated>2021-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><blockquote><p>所谓 源，可以指 URL。</p></blockquote><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>简单来看某个 URL 组成；</p><p><code>https://lonelyzou.github.io/longin</code></p><ul><li>名称    举例</li><li>协议    <code>http</code>、<code>https</code></li><li>域名    <code>lonelyzou.github.io</code></li><li>端口    80、443</li><li>其中，如果 URL 上未标明端口，那么 http 默认是 80 端口，https 默认是 443 端口。</li></ul><p>而所谓的同源策略，是指这 3 个（协议、域名、端口）一致的情况下，才属于同源。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>对于下面的 URL，我们判断下哪些属于同源哪些属于不同源：</p><ul><li><a href="https://github.com/LiangJunrong/document-library">https://github.com/LiangJunrong/document-library</a><table><thead><tr><th align="left">URL</th><th align="left">是否同源</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left"><a href="http://github.com/">http://github.com</a></td><td align="left">否</td><td align="left">协议不同</td></tr><tr><td align="left"><a href="https://github2.com/">https://github2.com</a></td><td align="left">否</td><td align="left">域名不同</td></tr><tr><td align="left"><a href="https://github.com:80/LiangJunrong">https://github.com:80/LiangJunrong</a></td><td align="left">否</td><td align="left">https 默认端口为 443</td></tr><tr><td align="left"><a href="https://money.github.com/">https://money.github.com</a></td><td align="left">是</td><td align="left">多级域名和主域名一致</td></tr></tbody></table></li></ul><p>在上面，如果两个页面对应的地址不同源，那么浏览器就会判定跨域，从而导致下面问题：</p><ul><li>Ajax 请求不能发送</li><li>无法获取 DOM 元素并进行操作</li><li>无法读取 Cookie、LocalStorage 和 IndexDB<blockquote><p>有些请求是不受到跨域限制。例如：WebSocket，script、img、iframe、video、audio标签的src属性等。</p></blockquote><h3 id="出于怎样的考虑，浏览器才要设置跨域？"><a href="#出于怎样的考虑，浏览器才要设置跨域？" class="headerlink" title="出于怎样的考虑，浏览器才要设置跨域？"></a>出于怎样的考虑，浏览器才要设置跨域？</h3></li></ul><ol><li><p>首先，跨域只存在于浏览器端，因为我们知道浏览器的形态是很开放的，所以我们需要对它有所限制。</p></li><li><p>其次，同源策略主要是为了保证用户信息的安全，可分为两种：Ajax 同源策略和 DOM 同源策略。</p></li><li><p>Ajax 同源策略主要是使得不同源的页面不能获取 Cookie 且不能发起 Ajax 请求，这样在一定层度上防止了 CSRF 攻击。</p></li><li><p>DOM 同源策略也一样，它限制了不同源页面不能获取 DOM，这样可以防止一些恶意网站在自己的网站中利用 iframe 嵌入正规的网站并迷惑用户，以此来达到窃取用户信息。</p></li></ol><h3 id="实际开发场景为什么会出现跨域："><a href="#实际开发场景为什么会出现跨域：" class="headerlink" title="实际开发场景为什么会出现跨域："></a>实际开发场景为什么会出现跨域：</h3><ul><li>前后端部署的机子，不属于同一台云服务器。</li><li>同一台云服务器，但是你在 <a href="https://github.com/">https://github.com</a> 请求的是 <a href="https://github2.com/">https://github2.com</a> 上的资源。</li></ul><h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><ol><li>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</li><li>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。</li><li>这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？</li></ol><p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p><h2 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h2><h3 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1.jsonp"></a>1.jsonp</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 <code>JSON </code>数据。<code>JSONP</code>请求一定需要对方的服务器做支持才可以。</p><h4 id="JSONP和AJAX对比"><a href="#JSONP和AJAX对比" class="headerlink" title="JSONP和AJAX对比"></a><code>JSONP</code>和<code>AJAX</code>对比</h4><p><code>JSONP</code>和<code>AJAX</code>相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但<code>AJAX</code>属于同源策略，<code>JSONP</code>属于非同源策略（跨域请求)</p><h4 id="JSONP优缺点"><a href="#JSONP优缺点" class="headerlink" title="JSONP优缺点"></a>JSONP优缺点</h4><ul><li>优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</li><li>缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</li></ul><h3 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2.CORS"></a>2.CORS</h3><h4 id="CORS-跨域的原理。"><a href="#CORS-跨域的原理。" class="headerlink" title="CORS 跨域的原理。"></a>CORS 跨域的原理。</h4><p>跨域资源共享（CORS）是一种机制，是 W3C 标准。它允许浏览器向跨源服务器，发出 XMLHttpRequest 或 Fetch 请求。并且整个 CORS 通信过程都是浏览器自动完成的，不需要用户参与。</p><p>而使用这种跨域资源共享的前提是，浏览器必须支持这个功能，并且服务器端也必须同意这种 “跨域” 请求。因此实现 CORS 的关键是服务器需要服务器。</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。</p><p>该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><h4 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h4><p>当你使用 IE&lt;=9, Opera&lt;12, or Firefox&lt;3.5 或者更加老的浏览器，这个时候请使用 JSONP</p><h4 id="CORS方法优点-amp-缺点："><a href="#CORS方法优点-amp-缺点：" class="headerlink" title="CORS方法优点&amp;缺点："></a>CORS方法优点&amp;缺点：</h4><p>优点</p><ul><li>简单，几乎不需要什么开发量，只需要简单配置相应的请求与响应头信息即可。</li><li>支持各种类型的请求（get, post, put等等）。</li></ul><p>缺点</p><ul><li>需要对跨域的服务接口进行一定的改造。如果该服务因为某些原因无法改造，则无法实现。但这种改造还是相对较小的。</li><li>不兼容一些“古董”浏览器。</li></ul><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。</p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>不会触发 CORS 预检请求。这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：</p><ol><li>情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)</li></ol><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><ol start="2"><li>情况二: 人为设置以下集合外的请求头</li></ol><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code> （需要注意额外的限制）</li><li><code>DPR</code></li><li><code>Downlink</code></li><li><code>Save-Data</code></li><li><code>Viewport-Width</code></li><li><code>Width</code></li></ul><ol start="3"><li>情况三：<code>Content-Type</code>的值仅限于下列三者之一：(例如 <code>application/json </code>为非简单请求)</li></ol><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><ol start="4"><li><p>情况四:<br>请求中的任意<code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；<code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。</p></li><li><p>情况五:<br>请求中没有使用 ReadableStream 对象。</p></li></ol><h3 id="3-postMessage"><a href="#3-postMessage" class="headerlink" title="3.postMessage"></a>3.postMessage</h3><blockquote><p>postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一。</p></blockquote><p>它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的 iframe 消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>postMessage() 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><blockquote><p><code>otherWindow.postMessage(message, targetOrigin, [transfer])</code>;</p></blockquote><ul><li>message: 将要发送到其他 window的数据。</li><li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><h4 id="案列"><a href="#案列" class="headerlink" title="案列"></a>案列</h4><p>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递<code>“我爱你”</code>,然后后者传回<code>&quot;我不爱你&quot;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.html</span><br><span class="line">  &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;b.html&quot; frameborder&#x3D;&quot;0&quot; id&#x3D;&quot;frame&quot; onload&#x3D;&quot;load()&quot;&gt;&lt;&#x2F;iframe&gt; &#x2F;&#x2F;等它加载完触发一个事件</span><br><span class="line">  &#x2F;&#x2F;内嵌在http:&#x2F;&#x2F;localhost:3000&#x2F;a.html</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      function load() &#123;</span><br><span class="line">        let frame &#x3D; document.getElementById(&#39;frame&#39;)</span><br><span class="line">        frame.contentWindow.postMessage(&#39;我爱你&#39;, &#39;http:&#x2F;&#x2F;localhost:4000&#39;) &#x2F;&#x2F;发送数据</span><br><span class="line">        window.onmessage &#x3D; function(e) &#123; &#x2F;&#x2F;接受返回数据</span><br><span class="line">          console.log(e.data) &#x2F;&#x2F;我不爱你</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; b.html</span><br><span class="line">  window.onmessage &#x3D; function(e) &#123;</span><br><span class="line">    console.log(e.data) &#x2F;&#x2F;我爱你</span><br><span class="line">    e.source.postMessage(&#39;我不爱你&#39;, e.origin)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4.WebSocket"></a>4.WebSocket</h3><p>WebSocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。</p><p>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。</p><p>简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。</p><p>这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>前端部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  </span><br><span class="line">  <span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:8080&quot;</span>);socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">   socket.send(<span class="string">&quot;秋风的笔记&quot;</span>);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(e.data);  </span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>后端部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&quot;ws&quot;</span>);<span class="keyword">const</span> server = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);server.on(<span class="string">&quot;connection&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;  </span><br><span class="line">  socket.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;    </span><br><span class="line">    socket.send(data);  </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-Node-正向代理"><a href="#5-Node-正向代理" class="headerlink" title="5.Node 正向代理"></a>5.Node 正向代理</h3><blockquote><p>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</p></blockquote><p>代理服务器实现步骤：</p><ul><li>接受客户端请求 。</li><li>将请求 转发给服务器。</li><li>拿到服务器 响应 数据。</li><li>将 响应 转发给客户端。</li></ul><h4 id="cli-工具中的代理"><a href="#cli-工具中的代理" class="headerlink" title="cli 工具中的代理"></a>cli 工具中的代理</h4><ol><li>Webpack (4.x)<br>在webpack中可以配置proxy来快速获得接口代理的能力。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">  entry: &#123;    <span class="attr">index</span>: <span class="string">&quot;./index.js&quot;</span>  &#125;,  </span><br><span class="line">  output: &#123;    </span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,    </span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>)  </span><br><span class="line">  &#125;,  </span><br><span class="line">  devServer: &#123;    </span><br><span class="line">    port: <span class="number">8000</span>,    </span><br><span class="line">    proxy: &#123;      </span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;        </span><br><span class="line">        target: <span class="string">&quot;http://localhost:8080&quot;</span>      </span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  plugins: [    </span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;     </span><br><span class="line">       filename: <span class="string">&quot;index.html&quot;</span>,      </span><br><span class="line">      template: <span class="string">&quot;webpack.html&quot;</span>    </span><br><span class="line">    &#125;)  </span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>修改前端接口请求方式，改为不带域名。（因为现在是同域请求了）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;getlist&quot;</span>&gt;获取列表&lt;button&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;login&quot;</span>&gt;登录&lt;/button&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;  </span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;  </span><br><span class="line">getlist.onclick = <span class="function">() =&gt;</span> &#123;    </span><br><span class="line">  axios.get(<span class="string">&quot;/api/corslist&quot;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;      </span><br><span class="line">    <span class="built_in">console</span>.log(res.data);    </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;;  </span><br><span class="line">login.onclick = <span class="function">() =&gt;</span> &#123;    axios.post(<span class="string">&quot;/api/login&quot;</span>);  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>Vue-cli 2.x<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/index.js</span></span><br><span class="line">...proxyTable: &#123;  <span class="string">&#x27;/api&#x27;</span>: &#123;     <span class="attr">target</span>: <span class="string">&#x27;http://localhost:8080&#x27;</span>,  &#125;&#125;,</span><br><span class="line">..</span><br></pre></td></tr></table></figure></li><li>Vue-cli 3.x<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js 如果没有就新建</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">  devServer: &#123;    </span><br><span class="line">    port: <span class="number">8000</span>,    </span><br><span class="line">    proxy: &#123;      </span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;        </span><br><span class="line">        target: <span class="string">&quot;http://localhost:8080&quot;</span>      </span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li>Parcel (2.x)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .proxyrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;http://localhost:8080&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="charles"><a href="#charles" class="headerlink" title="charles"></a>charles</h4>这是一个测试、开发的神器。<a href="https://juejin.cn/post/6844903665304600589">介绍与使用</a></li></ol><p>利用 charles 进行跨域，本质就是请求的拦截与代理。</p><p>在 tools/map remote 中设置代理</p><h3 id="6-Nginx-反向代理"><a href="#6-Nginx-反向代理" class="headerlink" title="6.Nginx 反向代理"></a>6.Nginx 反向代理</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。<br>只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>先下载nginx，然后将nginx目录下的nginx.conf修改如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass   http:&#x2F;&#x2F;www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http:&#x2F;&#x2F;www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过命令行nginx -s reload启动nginx</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 向前台写cookie</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>   <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="7-window-name-iframe"><a href="#7-window-name-iframe" class="headerlink" title="7.window.name + iframe"></a>7.window.name + iframe</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。<br>其中<code>a.html</code>和<code>b.html</code>是同域的，都是<code>http://localhost:3000;而c.html是http://localhost:4000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html(http://localhost:3000/b.html)</span></span><br><span class="line"> &lt;iframe src=<span class="string">&quot;http://localhost:4000/c.html&quot;</span> frameborder=<span class="string">&quot;0&quot;</span> onload=<span class="string">&quot;load()&quot;</span> id=<span class="string">&quot;iframe&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="keyword">let</span> first = <span class="literal">true</span></span><br><span class="line">   <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(first)&#123;</span><br><span class="line">     <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">       <span class="keyword">let</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">       iframe.src = <span class="string">&#x27;http://localhost:3000/b.html&#x27;</span>;</span><br><span class="line">       first = <span class="literal">false</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span><br><span class="line">       <span class="built_in">console</span>.log(iframe.contentWindow.name);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>b.html为中间代理页，与a.html同域，内容为空。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.html(http://localhost:4000/c.html)</span></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="built_in">window</span>.name = <span class="string">&#x27;我不爱你&#x27;</span></span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="8-location-hash-iframe"><a href="#8-location-hash-iframe" class="headerlink" title="8. location.hash +  iframe"></a>8. location.hash +  iframe</h3><p>实现原理： <code>a.html</code>欲与<code>c.html</code>跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用<code>iframe</code>的<code>location.hash</code>传值，相同域之间直接js访问来通信。<br>具体实现步骤：一开始<code>a.html</code>给<code>c.html</code>传一个<code>hash</code>值，然后<code>c.html</code>收到<code>hash</code>值后，再把<code>hash</code>值传递给<code>b.html</code>，最后<code>b.html</code>将结果放到<code>a.html</code>的<code>hash</code>值中。<br>同样的，<code>a.html</code>和<code>b.html</code>是同域的，都是<code>http://localhost:3000</code>;而<code>c.html</code>是<code>http://localhost:4000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html</span></span><br><span class="line"> &lt;iframe src=<span class="string">&quot;http://localhost:4000/c.html#iloveyou&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//检测hash的变化</span></span><br><span class="line">     <span class="built_in">console</span>.log(location.hash);</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.html</span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.parent.parent.location.hash = location.hash </span><br><span class="line">    <span class="comment">//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span></span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.html</span></span><br><span class="line"> <span class="built_in">console</span>.log(location.hash);</span><br><span class="line">  <span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">  iframe.src = <span class="string">&#x27;http://localhost:3000/b.html#idontloveyou&#x27;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(iframe);</span><br></pre></td></tr></table></figure><h3 id="9-document-domain-iframe"><a href="#9-document-domain-iframe" class="headerlink" title="9.document.domain + iframe"></a>9.document.domain + iframe</h3><p>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。<br>只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。<br>实现原理：两个页面都通过js强制设置<code>document.domain</code>为基础主域，就实现了同域。<br>我们看个例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中<code>a</code>的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line"> helloa</span><br><span class="line">  &lt;iframe src=<span class="string">&quot;http://b.zf1.cn:3000/b.html&quot;</span> frameborder=<span class="string">&quot;0&quot;</span> onload=<span class="string">&quot;load()&quot;</span> id=<span class="string">&quot;frame&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="built_in">document</span>.domain = <span class="string">&#x27;zf1.cn&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(frame.contentWindow.a);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.html</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">   hellob</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">     <span class="built_in">document</span>.domain = <span class="string">&#x27;zf1.cn&#x27;</span></span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h2 id="正向代理与反向代理比较"><a href="#正向代理与反向代理比较" class="headerlink" title="正向代理与反向代理比较"></a>正向代理与反向代理比较</h2><p>从用途上来讲：</p><ul><li>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。</li><li>反向代理的典型用途是为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。</li></ul><p>从安全性来讲：</p><ul><li>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。</li><li>反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</li></ul><p>从使用方来看：</p><ul><li>正向代理是浏览器端进行配置的，与服务器端无关，甚至可以对服务端隐藏。</li><li>反向代理是服务器端配置的，对浏览器端是透明的。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ul><ol><li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li><li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li><li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li><li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903767226351623">九种跨域方式实现原理（完整版）</a></li><li><a href="https://juejin.cn/post/6844904148022870023#heading-0">面试题：nginx有配置过吗?反向代理知道吗?</a></li><li><a href="https://juejin.cn/post/6844904126246027278#heading-0">10种跨域解决方案（附终极大招）</a></li><li><a href="https://segmentfault.com/a/1190000010719058">前端开发如何独立解决跨域问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JS之ES6语法知识点二</title>
    <link href="http://github.com/2021/01/25/JS%E4%B9%8BES6%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"/>
    <id>http://github.com/2021/01/25/JS%E4%B9%8BES6%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/</id>
    <published>2021-01-24T16:00:00.000Z</published>
    <updated>2021-01-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="新增类型"><a href="#新增类型" class="headerlink" title="新增类型"></a>新增类型</h2><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>Symbol 是一个新的原始类型，用来表示一个独一无二的值，可以通过 Symbol() 函数来创建一个 Symbol 类型的值，为了加以区分，可以传入一个字符串作为其描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">s1 === s2  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Symbol 类型无法通过数学运算符进行隐式类型转换，但是可以通过 String() 显示转成字符串或者通过 Boolean() 显示转成布尔值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">String</span>(s)     <span class="comment">// &quot;Symbol(&#x27;foo&#x27;)&quot;</span></span><br><span class="line">s.toString()  <span class="comment">// &quot;Symbol(&#x27;foo&#x27;)&quot;</span></span><br><span class="line"><span class="built_in">Boolean</span>(s)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>引入 Symbol 最大的初衷其实就是为了让它作为对象的属性名而使用，这样就可以有效避免属性名的冲突了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [foo]: <span class="string">&#x27;foo1&#x27;</span>,</span><br><span class="line">    foo: <span class="string">&#x27;foo2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[foo]  <span class="comment">// &#x27;foo1&#x27;</span></span><br><span class="line">obj.foo   <span class="comment">// &#x27;foo2&#x27;</span></span><br></pre></td></tr></table></figure><p>Symbol 属性的不可枚举性，不会被 for…in、for…of、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 等枚举：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;age&#x27;</span>)]: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// &#x27;name&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(person)  <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(person)  <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(person)  <span class="comment">// &#x27;&#123;&quot;name&quot;:&quot;布兰&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>但是可以通过 Object.getOwnPropertySymbols() 获取到对象的所有 Symbol 属性名，返回一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于上面的代码</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(person)  <span class="comment">// [Symbol(age)]</span></span><br></pre></td></tr></table></figure><h3 id="静态方法："><a href="#静态方法：" class="headerlink" title="静态方法："></a>静态方法：</h3><ol><li><p>Symbol.for() 按照描述去全局查找 Symbol，找不到则在全局登记一个：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p> Symbol.for() 的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p></li><li><p>Symbol.keyFor() 根据已经在全局登记的 Symbol 查找其描述：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s)  <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Symbol-的内置值："><a href="#Symbol-的内置值：" class="headerlink" title="Symbol 的内置值："></a>Symbol 的内置值：</h3><ul><li><code>Symbol.hasInstance</code>：指向一个内部方法，当其他对象使用 <code>instanceof</code> 运算符判断是否为此对象的实例时会调用此方法；</li><li><code>Symbol.isConcatSpreadable</code>：指向一个布尔，定义对象用于 <code>Array.prototype.concat()</code> 时是否可展开；</li><li><code>Symbol.species：</code>指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数；</li><li><code>Symbol.match：</code>指向一个函数，当实例对象被 <code>String.prototype.match()</code> 调用时会重新定义<code>match()</code>的行为；</li><li><code>Symbol.replace：</code>指向一个函数，当实例对象被 <code>String.prototype.replace()</code> 调用时会重新定义 <code>replace()</code> 的行为；</li><li><code>Symbol.search：</code>指向一个函数，当实例对象被<code>String.prototype.search()</code>调用时会重新定义 <code>search()</code> 的行为；</li><li><code>Symbol.split</code>：指向一个函数，当实例对象被 <code>String.prototype.split()</code> 调用时会重新定义 <code>split() </code>的行为；</li><li><code> Symbol.iterator：</code>指向一个默认遍历器方法，当实例对象执行 <code>for...of </code>时会调用指定的默认遍历器；</li><li><code>Symbol.toPrimitive：</code>指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值；</li><li><code>Symbol.toStringTag：</code>指向一个函数，当实例对象被 <code>Object.prototype.toString()</code> 调用时其返回值会出现在 <code>toString()</code> 返回的字符串之中表示对象的类型；</li><li><code>Symbol.unscopables：</code>指向一个对象，指定使用 <code>with </code>时哪些属性会被 <code>with </code>环境排除；</li><li><code>Symbol.prototype.description</code> : 描述属性  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let symbol &#x3D; Symbol(&#39;foo&#39;)</span><br><span class="line">symbol.description  &#x2F;&#x2F; &#39;foo&#39;</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2></li></ul><p>Set 是一种新的数据结构，类似数组，但是它没有键只有值，且值都是唯一的。可以通过构造函数生成一个新实例，接收一个数组或者可迭代数据结构作为参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">&#x27;abc&#x27;</span>)      <span class="comment">// Set &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>Set 判断两个值是不是相等用的是 sameValueZero 算法，类似于 ===，唯一的区别是，在 Set 里 NaN 之间被认为是相等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span></span><br><span class="line">set.add(a)</span><br><span class="line">set.add(b)</span><br><span class="line">set.size  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>相同对象的不同实例也被 Set 认为是不相等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line">set.add(a)</span><br><span class="line">set.add(b)</span><br><span class="line">set.size  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>Set 是有顺序的，将按照插入的顺序进行迭代，可以使用 for…of 迭代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">set.add(<span class="number">5</span>)</span><br><span class="line">set.add(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set-实例属性和方法："><a href="#Set-实例属性和方法：" class="headerlink" title="Set 实例属性和方法："></a>Set 实例属性和方法：</h3><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是 <code>Set</code> 函数；</li><li><code>Set.prototype.size</code>：返回 <code>Set</code> 实例的成员总数；</li><li><code>Set.prototype.add(value)</code>：添加某个值，返回 <code>Set</code> 结构本身；</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功；</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员；</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值；</li><li><code>Set.prototype.keys()</code>：返回键名的遍历器；</li><li><code>Set.prototype.values()</code>：返回键值的遍历器；</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器；</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">set.add(<span class="number">5</span>)     <span class="comment">// Set &#123;1, 3, 5&#125;</span></span><br><span class="line">set.size       <span class="comment">// 3</span></span><br><span class="line">set.delete(<span class="number">1</span>)  <span class="comment">// true，1 已被删除</span></span><br><span class="line">set.has(<span class="number">1</span>)     <span class="comment">// false</span></span><br><span class="line">set.keys()     <span class="comment">// SetIterator &#123;3, 5&#125;</span></span><br><span class="line">set.clear()</span><br><span class="line">set.size       <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="Set-应用场景："><a href="#Set-应用场景：" class="headerlink" title="Set 应用场景："></a>Set 应用场景：</h3></li></ul><ol><li><p>数组去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>])]         <span class="comment">// [1, 3, 6]</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>]))  <span class="comment">// [1, 3, 6]</span></span><br></pre></td></tr></table></figure></li><li><p>字符串去重：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&#x27;abcbacd&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>)  <span class="comment">// &#x27;abcd&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>求两个集合的交集/并集/差集：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b])  <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)))  <span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)))  <span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>遍历修改集合成员的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>))     <span class="comment">// Set &#123;2, 3, 6&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(set, <span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>))  <span class="comment">// Set &#123;2, 4, 6&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p><code>WeakSet</code> 对象允许将弱保持对象存储在一个集合中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123;&#125;</span><br><span class="line">ws.add(foo)  <span class="comment">// WeakSet &#123;&#123;&#125;&#125;</span></span><br><span class="line">ws.has(foo)  <span class="comment">// true</span></span><br><span class="line">ws.delete(foo)  <span class="comment">// WeakSet &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>和 Set 的区别：</p><ul><li><code>WeakSet</code> 只能是对象的集合，而不能是任何类型的任意值；</li><li><code>WeakSet</code> 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 <code>WeakSet</code> 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 <code>WeakSet</code> 中没有存储当前对象的列表。正因为这样，WeakSet 是不可枚举的，也就没有 <code>size</code> 属性，没有 <code>clear</code> 和遍历的方法。</li></ul><p>实例方法：</p><ul><li><code>WeakSet.prototype.add(value)</code>：添加一个新元素 <code>value</code>；</li><li><code>WeakSet.prototype.delete(value)</code>：从该 WeakSet 对象中删除 <code>value</code> 这个元素；</li><li><code>WeakSet.prototype.has(value)</code>：返回一个布尔值,  表示给定的值 <code>value </code>是否存在于这个 <code>WeakSet</code> 中；</li></ul><p>应用场景</p><ul><li>储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li><li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在WeakSet结构中的引用就会自动消</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>Map</code> 是一种类似于 <code>Object</code> 的这种键值对的数据结构，区别是对象的键只能是字符串或者 <code>Symbol</code>，而 <code>Map </code>的键可以是任何类型（原始类型、对象或者函数），可以通过 <code>Map</code> 构造函数创建一个实例，入参是具有 <code>Iterator</code> 接口且每个成员都是一个双元素数组 <code>[key, value] </code>的数据结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map1.set(&#123;&#125;, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;布兰&#x27;</span>], [<span class="string">&#x27;age&#x27;</span>, <span class="number">12</span>]]</span><br><span class="line"><span class="keyword">let</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(arr)</span><br></pre></td></tr></table></figure><p>Map 中的键和 Set 里的值一样也必须是唯一的，遵循 sameValueZero 算法，对于同一个键后面插入的会覆盖前面的，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">let</span> foo = &#123;<span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span>&#125;</span><br><span class="line">map.set(foo, <span class="string">&#x27;foo1&#x27;</span>)</span><br><span class="line">map.set(foo, <span class="string">&#x27;foo2&#x27;</span>)</span><br><span class="line">map.get(foo)  <span class="comment">// &#x27;foo2&#x27; </span></span><br></pre></td></tr></table></figure><p>对于键名同为 NaN 以及相同对象而不同实例的处理同 Set 的值一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(a, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">map.set(b, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">map.size    <span class="comment">// 1</span></span><br><span class="line">map.get(a)  <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> d = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">map.set(c, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">map.set(d, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">map.size    <span class="comment">// 3</span></span><br><span class="line">map.get(c)  <span class="comment">// &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="实例属性和方法："><a href="#实例属性和方法：" class="headerlink" title="实例属性和方法："></a>实例属性和方法：</h3><ul><li><p><code>Map.prototype.size</code>：返回 <code>Map </code>对象的键值对数量；</p></li><li><p><code>Map.prototype.set(key, value)</code>：设置 <code>Map</code> 对象中键的值。返回该 <code>Map</code> 对象；</p></li><li><p><code>Map.prototype.get(key)</code>： 返回键对应的值，如果不存在，则返回 <code>undefined</code>；</p></li><li><p><code>Map.prototype.has(key)</code>：返回一个布尔值，表示<code>Map</code>实例是否包含键对应的值；</p></li><li><p><code>Map.prototype.delete(key)</code>： 如果 <code>Map</code> 对象中存在该元素，则移除它并返回 <code>true</code>；</p></li><li><p><code>Map.prototype.clear()</code>： 移除 <code>Map</code> 对象的所有键/值对；</p></li><li><p><code>Map.prototype.keys()</code>：返回一个新的 <code>Iterator</code> 对象， 它按插入顺序包含了 <code>Map</code> 对象中每个元素的键；</p></li><li><p><code>Map.prototype.values()</code>：返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map </code>对象中每个元素的值；</p></li><li><p><code>Map.prototype.entries()</code>：返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map </code>对象中每个元素的<code>[key, value]</code>数组；</p></li><li><p><code>Map.prototype.forEach(callbackFn[, thisArg])</code>：按插入顺序遍历 <code>Map</code>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">map.set(&#123;<span class="attr">a</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;a: 1&#125; &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#123;a: 2&#125; &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"><span class="comment">// &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2></li><li><p>定义：和Map结构类似，成员键只能是对象</p></li><li><p>声明：<code>const set = new WeakMap(arr)</code></p></li><li><p>入参：具有<code>Iterator</code>接口且每个成员都是一个双元素数组的数据结构<br>属性</p></li><li><p><code>constructor</code>：构造函数，返回<code>WeakMap</code></p></li></ul><p>方法</p><ul><li><code>get()</code>：返回键值对</li><li><code>set()</code>：添加键值对，返回实例</li><li><code>delete()</code>：删除键值对，返回布尔</li><li><code>has()</code>：检查键值对，返回布尔</li></ul><p>应用场景</p><ul><li>储存<code>DOM</code>节点：<code>DOM</code>节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li><li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li></ul><p>特点</p><ul><li>成员键都是弱引用，垃圾回收机制不考虑<code>WeakMap</code>结构对此成员键的引用</li><li>成员键不适合引用，它会随时消失，因此<code>ES6</code>规定<code>WeakMap</code>结构不可遍历</li><li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap</code>结构中</li><li>一旦不再需要，成员会自动消失，不用手动删除引用</li><li>弱引用的只是键而不是值，值依然是正常引用</li><li>即使在外部消除了成员键的引用，内部的成员值依然存在</li></ul><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p><code>Proxy</code> 用来定义基本操作的的自定义行为，可以理解为当对目标对象<code>target</code>进行某个操作之前会先进行拦截（执行 <code>handler </code>里定义的方法），必须要对 <code>Proxy</code> 实例进行操作才能触发拦截，对目标对象操作是不会拦截的，可以通过如下方式定义一个代理实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>&#125;, &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`hello, <span class="subst">$&#123;target.name&#125;</span>`</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">instance.name  <span class="comment">// &#x27;hello, 布兰&#x27;</span></span><br></pre></td></tr></table></figure><p>如果 <code>handle</code> 没有设置任何拦截，那么对实例的操作就会转发到目标对象身上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;)</span><br><span class="line">proxy.name = <span class="string">&#x27;布兰&#x27;</span></span><br><span class="line">target.name  <span class="comment">// &#x27;布兰&#x27;</span></span><br></pre></td></tr></table></figure><p>目标对象被 <code>Proxy</code> 代理的时候，内部的 this 会指向代理的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span> === proxy)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">target.m()  <span class="comment">// false</span></span><br><span class="line">proxy.m()   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="静态方法：-1"><a href="#静态方法：-1" class="headerlink" title="静态方法："></a>静态方法：</h3><p>Proxy.revocable() 用以定义一个可撤销的 Proxy：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(target, handler)</span><br><span class="line">  </span><br><span class="line">proxy.foo = <span class="number">123</span></span><br><span class="line">proxy.foo  <span class="comment">// 123</span></span><br><span class="line">revoke()</span><br><span class="line">proxy.foo  <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h3 id="handle-对象的方法："><a href="#handle-对象的方法：" class="headerlink" title="handle 对象的方法："></a>handle 对象的方法：</h3><ul><li><code>get(target, propKey, receiver)</code>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li><li><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置，比如 <code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li><code>has(target, propKey)</code>：拦截 <code>propKey in proxy </code>的操作，返回一个布尔值。</li><li><code>deleteProperty(target, propKey)</code>：拦截 <code>delete proxy[propKey]</code> 的操作，返回一个布尔值。</li><li><code>ownKeys(target)</code>：拦截 <code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in </code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 <code>Object.keys() </code>的返回结果仅包括目标对象自身的可遍历属性。</li><li><code>getOwnPropertyDescriptor(target, propKey)</code>：拦截<code>Object</code>.- <code>getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li><code>defineProperty(target, propKey, propDesc)</code>：拦截 <code>Object</code>.<code>defineProperty(proxy, propKey, propDesc)</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li><code>preventExtensions(target)</code>：拦截 <code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li><code>getPrototypeOf(target)</code>：拦截 <code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li><code>isExtensible(target)</code>：拦截 <code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li><code>setPrototypeOf(target, proto)</code>：拦截 <code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li><code>apply(target, object, args)</code>：拦截<code> Proxy</code> 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li><code>construct(target, args)</code>：拦截 <code>Proxy</code> 实例作为构造函数调用的操作，比如 <code>new proxy(...args)</code>。<h3 id="与Object-defineProperty对比"><a href="#与Object-defineProperty对比" class="headerlink" title="与Object.defineProperty对比"></a>与Object.defineProperty对比</h3><code>Object.defineProperty</code>：数据劫持：直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</li></ul><p>在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。数据劫持最典型的应用 —–&gt; 双向的数据绑定</p><ul><li><p>Object.defineProperty</p><p>  只能监听对象(Object)，不能监听数组的变化，无法触发push, pop, shift, unshift,splice, sort, reverse。<br>  必须遍历对象的每个属性<br>  只能劫持当前对象属性，如果想深度劫持，必须深层遍历嵌套的对象</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> value = <span class="number">1</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;listenA&#x27;</span>, &#123;</span><br><span class="line">writable: <span class="literal">true</span>,  <span class="comment">//可修改</span></span><br><span class="line">enumerable: <span class="literal">true</span>,  <span class="comment">// 可枚举   for...in...   Object.keys()</span></span><br><span class="line">configurable: <span class="literal">true</span>,  <span class="comment">// 可配置，可删除</span></span><br><span class="line">get: <span class="function">() =&gt;</span> value,</span><br><span class="line">set: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`set obj.listenA .. <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">    value = val</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">obj.listenA = <span class="number">2</span> <span class="comment">//set obj.listenA .. 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.listenA)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>Proxy</p><ul><li>可以直接监听对象而非属性</li><li>可以直接监听数组的变化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 代理整个对象</span><br><span class="line">let proxyObj &#x3D; new Proxy(&#123;&#125;, &#123;</span><br><span class="line">get: (target, key, receiver) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;getting $&#123;key&#125;!&#96;);</span><br><span class="line">    return target[key];</span><br><span class="line">&#125;,</span><br><span class="line">set: (target, key, value, receiver) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(target, key, value, receiver);</span><br><span class="line">    return target[key] &#x3D; value;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxyObj.val &#x3D; 1;    &#x2F;&#x2F; &#123;&#125; val 1 &#123;&#125;</span><br><span class="line">proxyObj.val;       &#x2F;&#x2F; getting val!</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;代理数组</span><br><span class="line">let proxyArr &#x3D; new Proxy([], &#123;</span><br><span class="line">get: (target, key, receiver) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;getting $&#123;key&#125;!&#96;);</span><br><span class="line">    return target[key];</span><br><span class="line">&#125;,</span><br><span class="line">set: (target, key, value, receiver) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(target, key, value, receiver);</span><br><span class="line">    return (target[key] &#x3D; value);</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">proxyArr[0] &#x3D; 1; &#x2F;&#x2F;  &#123;&#125; val 1 &#123;&#125;</span><br><span class="line">console.log(proxyArr[0]); &#x2F;&#x2F;  getting val!  &#x2F;&#x2F; 1</span><br><span class="line">console.log(proxyArr); &#x2F;&#x2F; [1]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903959283367950#heading-0">1.5万字概括ES6全部特性(已更新ES2020)</a></li><li><a href="https://juejin.cn/post/6895898051559456776#heading-0">送你一份精心总结的3万字ES6实用指南（上）</a></li><li><a href="https://juejin.cn/post/6896986598999588872#heading-0">「建议收藏」送你一份精心总结的3万字ES6实用指南（下）</a></li><li><a href="https://juejin.cn/post/6844903775329583112#heading-1">近一万字的ES6语法知识点补充</a></li><li><a href="https://juejin.cn/post/6844903679976275976#heading-1">ES6、ES7、ES8特性一锅炖(ES6、ES7、ES8学习指南)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;新增类型&quot;&gt;&lt;a href=&quot;#新增类型&quot; class=&quot;headerlink&quot; title=&quot;新增类型&quot;&gt;&lt;/a&gt;新增类型&lt;/h2&gt;&lt;h3 id=&quot;S
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之ES6语法知识点一</title>
    <link href="http://github.com/2021/01/23/JS%E4%B9%8BES6%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"/>
    <id>http://github.com/2021/01/23/JS%E4%B9%8BES6%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/</id>
    <published>2021-01-22T16:00:00.000Z</published>
    <updated>2021-01-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><blockquote><p>声明方法：var、const、let、function、class、import</p></blockquote><h3 id="let-const特性"><a href="#let-const特性" class="headerlink" title="let,const特性"></a>let,const特性</h3><ol><li><p>const：声明一个常量，let：声明一个变量；const/let 声明的常量/变量都只能作用于代码块（块级作用域或函数作用域）里；</p></li><li><p>const/let 不存在变量提升，所以在代码块里必须先声明然后才可以使用，这叫暂时性死区；</p></li><li><p>const/let 不允许在同一个作用域内，重复声明；</p></li><li><p>const 声明时必须初始化，且后期不能被修改，但如果初始化的是一个对象，那么不能修改的是该对象的内存地址；</p></li><li><p>const/let 在全局作用域中声明的常量/变量不会挂到顶层对象（浏览器中是 window ）的属性中；</p></li></ol><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h3 id="解构类型："><a href="#解构类型：" class="headerlink" title="解构类型："></a>解构类型：</h3><ol><li><p>字符串解构</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c = <span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;12&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)  <span class="comment">// &#x27;1&#x27; &#x27;2&#x27; &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数值解构</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toFixed</span>: tf&#125; = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log( tf.call(<span class="built_in">Math</span>.PI, <span class="number">2</span>) )  <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure></li><li><p>布尔值解构</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: ts&#125; = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log( ts.call(<span class="literal">false</span>) )  <span class="comment">// &#x27;false&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>数组解构：等号右侧的数据具有 Iterator 接口可以进行数组形式的解构赋值；</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构不成功的变量值为 undefined</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)  <span class="comment">// 1, 2, undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以设置默认值</span></span><br><span class="line"><span class="keyword">let</span> [x, y, z = <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>]</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z)  <span class="comment">// 1, 2, null</span></span><br></pre></td></tr></table></figure><p> 什么样的数据具有 Iterator 接口呢？如果一个对象能够通过 [Symbol.iterator] 访问，且能够返回一个符合迭代器协议的对象，那么该对象就是可迭代的。目前内置的可迭代对象有：String、Array、TypeArray、Map、Set、arguments 和 NodeList 等。</p></li><li><p>对象解构：与数组按照索引位置进行解构不同，对象解构是按照属性名进行解构赋值，如果在当前对象属性匹配不成功则会去对象的原型属性上查找：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认写法</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: name, <span class="attr">age</span>: age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改名且设置默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: name1, <span class="attr">age</span>: age1 = <span class="number">12</span> &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name1, age1)  <span class="comment">// &#x27;布兰&#x27; 12</span></span><br></pre></td></tr></table></figure></li><li><p>函数参数解构：其实就是运用上面的对象解构和数组解构规则；</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([x, y])</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;)  <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;)        <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;)            <span class="comment">// [0, 0]</span></span><br><span class="line">move()              <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="解构要点："><a href="#解构要点：" class="headerlink" title="解构要点："></a>解构要点：</h3><ul><li>只要等号两边的模式相同（同是对象或同是数组），则左边的变量会被赋予对应的值；</li><li>解构不成功的变量值为 undefined；</li><li>默认值生效的前提是当等号右边对应的值全等于 undefined 的时候；</li><li>只要等号右边的值不是对象或者数组，则会进行自动装箱将其转成对象；</li><li>null 和 undefined 都无法转成对象，所以无法解构。</li></ul><h3 id="解构应用："><a href="#解构应用：" class="headerlink" title="解构应用："></a>解构应用：</h3><ol><li>交换变量的值； <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x]</span><br><span class="line"><span class="built_in">console</span>.log(x, y)  <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure></li><li>通过函数返回对象属性 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParams</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">        age: <span class="number">12</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name, age&#125; = getParams()</span><br></pre></td></tr></table></figure></li><li>通过定义函数参数来声明变量 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;布兰&#x27;</span>,</span><br><span class="line">    age: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line">init(person)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 普通用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;name, age&#125; = person</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 更简洁用法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">&#123;name, age&#125;</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>指定函数参数默认值 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPerson</span>(<span class="params">&#123;name = <span class="string">&#x27;布兰&#x27;</span>, age = <span class="number">12</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name, age)</span><br><span class="line">&#125;</span><br><span class="line">initPerson()  <span class="comment">// &#x27;布兰&#x27; 12</span></span><br><span class="line">initPerson(&#123;<span class="attr">age</span>: <span class="number">20</span>&#125;)  <span class="comment">// &#x27;布兰&#x27; 20</span></span><br></pre></td></tr></table></figure></li><li>提取 JSON 数据 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> responseData = &#123;</span><br><span class="line">    code: <span class="number">1000</span>,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    message: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> &#123; code, data = &#123;&#125; &#125; = responseData</span><br></pre></td></tr></table></figure></li><li>遍历 Map 结构 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>)</span><br><span class="line">map.set(<span class="string">&#x27;xiamen&#x27;</span>, <span class="string">&#x27;厦门&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>输入模块的指定方法和属性 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; readFile, writeFile &#125; = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h2></li></ol><ul><li>模板字符串: <code>`$&#123;name&#125;`</code></li><li>Unicode表示法：大括号包含表示Unicode字符(\u{0xXX}或\u{0XXX})</li><li>字符串遍历：可通过for-of遍历字符串</li><li>字符串模板：可单行可多行可插入变量的增强版字符串</li><li>标签模板：函数参数的特殊调用</li><li>String.raw()：返回把字符串所有变量替换且对斜杠进行转义的结果</li><li>String.fromCodePoint()：返回码点对应字符</li><li>codePointAt()：返回字符对应码点(String.fromCodePoint()的逆操作)</li><li>normalize()：把字符的不同表示方法统一为同样形式，返回新字符串-(Unicode正规化)</li><li>repeat()：把字符串重复n次，返回新字符串</li><li>matchAll()：返回正则表达式在字符串的所有匹配</li><li>includes()：是否存在指定字符串</li><li>startsWith()：是否存在字符串头部指定字符串</li><li>endsWith()：是否存在字符串尾部指定字符串</li></ul><h2 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h2><ul><li>二进制表示法：0b或0B开头表示二进制(0bXX或0BXX)</li><li>八进制表示法：0o或0O开头表示二进制(0oXX或0OXX)</li><li>Number.EPSILON：数值最小精度</li><li>Number.MIN_SAFE_INTEGER：最小安全数值(-2^53)</li><li>Number.MAX_SAFE_INTEGER：最大安全数值(2^53)</li><li>Number.parseInt()：返回转换值的整数部分</li><li>Number.parseFloat()：返回转换值的浮点数部分</li><li>Number.isFinite()：是否为有限数值</li><li>Number.isNaN()：是否为NaN</li><li>Number.isInteger()：是否为整数</li><li>Number.isSafeInteger()：是否在数值安全范围内</li><li>Math.trunc()：返回数值整数部分</li><li>Math.sign()：返回数值类型(正数1、负数-1、零0)</li><li>Math.cbrt()：返回数值立方根</li><li>Math.clz32()：返回数值的32位无符号整数形式</li><li>Math.imul()：返回两个数值相乘</li><li>Math.fround()：返回数值的32位单精度浮点数形式</li><li>Math.hypot()：返回所有数值平方和的平方根</li><li>Math.expm1()：返回e^n - 1</li><li>Math.log1p()：返回1 + n的自然对数(Math.log(1 + n))</li><li>Math.log10()：返回以10为底的n的对数</li><li>Math.log2()：返回以2为底的n的对数</li><li>Math.sinh()：返回n的双曲正弦</li><li>Math.cosh()：返回n的双曲余弦</li><li>Math.tanh()：返回n的双曲正切</li><li>Math.asinh()：返回n的反双曲正弦</li><li>Math.acosh()：返回n的反双曲余弦</li><li>Math.atanh()：返回n的反双曲正切</li></ul><h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><ol><li><p>对象属性简写</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;aa&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name,</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;aa&#x27;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性名表达式：在用对象字面量定义对象的时候，允许通过属性名表达式来定义对象属性</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    [name]: <span class="string">&#x27;aa&#x27;</span>,</span><br><span class="line">    [<span class="string">&#x27;get&#x27;</span>+ name]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Object.is()：用来判断两个值是否相等，表现基本和 === 一样，除了以下两种情况：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span>            <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>          <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>Object.assign()：合并对象(浅拷贝)，返回原对象</p><p> Object.assign() 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target），如果有同名属性，则后面的会直接替换前面的：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> source1 = &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">d</span>: &#123;<span class="attr">e</span>: <span class="number">1</span>, <span class="attr">f</span>: <span class="number">2</span>&#125; &#125;</span><br><span class="line"><span class="keyword">let</span> source2 = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: &#123;<span class="attr">g</span>: <span class="number">3</span>&#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2)</span><br><span class="line">target  <span class="comment">// &#123; a: 3, b: 3, c: 4, d: &#123;g: 3&#125; &#125;</span></span><br></pre></td></tr></table></figure><p> Object.assign() 实行的是浅拷贝，如果源对象某个属性是对象，那么拷贝的是这个对象的引用：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> source = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line">target.a.b = <span class="number">3</span></span><br><span class="line">source.a.b  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p>__proto__：返回或设置对象的原型对象</p></li><li><p>Object.values()</p><p> 返回一个由对象自身所有可遍历属性的属性值组成的数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="number">12</span>,</span><br><span class="line">    enumrable: <span class="literal">false</span>  <span class="comment">// age 属性将不可遍历</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(person))  <span class="comment">// [&#x27;布兰&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似 str.split(&#x27;&#x27;) 效果</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(<span class="string">&#x27;abc&#x27;</span>))  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>Object.entries()</p><p> 返回一个由对象自身所有可遍历属性的键值对组成的数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(person))  <span class="comment">// [[&quot;name&quot;, &quot;布兰&quot;], [&quot;age&quot;, 12]]</span></span><br></pre></td></tr></table></figure><p> 利用这个方法可以很好的将对象转成正在的 Map 结构：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(person))</span><br><span class="line"><span class="built_in">console</span>.log(map)  <span class="comment">// Map &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Object.fromEntries()</p><p>Object.fromEntries() 方法是 Object.entries() 的逆操作，用于将一个键值对数组转为对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> keyValueArr = <span class="built_in">Object</span>.entries(person)   <span class="comment">// [[&#x27;name&#x27;, &#x27;布兰&#x27;], [&#x27;age&#x27;, 12]]</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(arr)  <span class="comment">// &#123; name: &#x27;布兰&#x27;, age: 12 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Object.getOwnPropertyDescriptors()</p><p>Object.getOwnPropertyDescriptor() 会返回指定对象某个自身属性的的描述对象，而 Object.getOwnPropertyDescriptors() 则是返回指定对象自身所有属性的描述对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person))</span><br><span class="line"><span class="comment">//&#123; </span></span><br><span class="line"><span class="comment">//  name: &#123; configurable: true, enumerable: true, value: &quot;布兰&quot;, writable: true &#125;,</span></span><br><span class="line"><span class="comment">//  age: &#123;configurable: false, enumerable: false, value: 12, writable: false&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>配合 Object.create() 可以实现浅克隆：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="built_in">Object</span>.create(</span><br><span class="line">    <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>Object.setPrototypeOf()与Object.getPrototypeOf()</p><p>Object.setPrototypeOf() 用于设置对象原型，Object.getPrototypeOf() 用于读取对象原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;布兰&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, &#123;<span class="attr">name</span>: <span class="string">&#x27;动物&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person)  <span class="comment">// &#123;name: &#x27;动物&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h2><ol><li><p>数组扩展运算符</p><p> 数组扩展运算符（…）将数组展开成用逗号分隔的参数序列，只能展开一层数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用一：函数传参</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用二：数组合并</span></span><br><span class="line"><span class="keyword">let</span> merge = [...[<span class="number">1</span>, <span class="number">2</span>], ...[<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, <span class="number">6</span>]  <span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用三：浅克隆</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> clone = [...a]</span><br><span class="line">a === clone  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用四：数组解构</span></span><br><span class="line"><span class="keyword">const</span> [x, ...y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x  <span class="comment">// 1</span></span><br><span class="line">y  <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.from()</p><p> Array.from()可以将类数组对象（ NodeList，arguments）和可迭代对象转成数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用一：字符串转数组</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;foo&#x27;</span>)  <span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用二：数组合并去重</span></span><br><span class="line"><span class="keyword">let</span> merge = [...[<span class="number">1</span>, <span class="number">2</span>], ...[<span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(merge))  <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用三：arguments 转数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p> 如果 Array.from() 带第二个参数 mapFn，将对生成的新数组执行一次 map 操作：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x )    <span class="comment">// [1, 4, 9]</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> ++i)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.of()</p><p> Array.of()将一组参数转成数组：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayOf</span>(<span class="params">...params</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].slice.call(params)</span><br><span class="line">&#125;</span><br><span class="line">arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.copyWithin()</p><p> Array.copyWithin()在当前数组内部，将制定位置的成员复制到其他位置（会覆盖原来位置的成员），最后返回一个新数组。接收 3 个参数，参数为负数表示右边开始计算：</p><ul><li>target（必选）：替换位置的索引；</li><li>start（可选）：从该位置开始读取数据，默认为 0；</li><li>end（可选）：从该位置结束读取数据（不包括该位置的数据），默认为原数组长度；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-1</span>)         <span class="comment">// [1, 2, 3, 4, 1]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1</span>)          <span class="comment">// [1, 1, 2, 3, 4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)    <span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-3</span>, <span class="number">-1</span>)  <span class="comment">// [3, 4, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>查找第一个出现的子成员：find() 和 findIndex()：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出第一个偶数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>].find(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span> val % <span class="number">2</span> === <span class="number">0</span>)       <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出第一个偶数的索引位置</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>].findIndex(<span class="function">(<span class="params">val, index, arr</span>) =&gt;</span> val % <span class="number">2</span> === <span class="number">0</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>fill() 使用给定的值来填充数组，有 3 个参数：</p><ul><li>value：填充值；</li><li>start（可选），开始索引，默认为 0；</li><li>end（可选）：结束索引，默认为数组长度，不包括该索引位置的值；<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化空数组</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">1</span>)  <span class="comment">// [1, 1, 1]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].fill(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>)  <span class="comment">// [1, 2, &#x27;a&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过 keys()（键名）、entries()（键值）和 values()（键值对） 获取数组迭代器对象，可以被 for…of 迭代，</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)  <span class="comment">// &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)  <span class="comment">// [0, &#x27;a&#x27;] [0, &#x27;b&#x27;] [0, &#x27;c&#x27;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组空位</p><p> 指数组没有值，比如：[,,]，而像这种 [undefined] 是不包含空位的。由于 ES6 之前的一些 API 对空位的处理规则很不一致，所以实际操作的时候应该尽量避免空位的出现，而为了改变这个现状，ES6 的 API 会默认将空位处理成 undefined：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[<span class="number">1</span>, , <span class="number">3</span>].values()]  <span class="comment">// [1, undefined, 3]</span></span><br><span class="line">[<span class="number">1</span>, , <span class="number">3</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> x === <span class="literal">undefined</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.includes</p><p> 判断一个数组是否包含某个元素，之前一般是这么做的：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) &gt;= <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (~arr.indexOf(el)) &#123;&#125;</span><br></pre></td></tr></table></figure><p> 而现在你可以这么做了：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.includes(el)) &#123;&#125;</span><br></pre></td></tr></table></figure><p> indexOf 会返回找到元素在数组中的索引位置，判断的逻辑是是否严格相等，所以他在遇到 NaN 的时候不能正确返回索引，但是 includes 解决了这个问题：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">3</span>].indexOf(<span class="literal">NaN</span>)   <span class="comment">// -1</span></span><br><span class="line">[<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">3</span>].includes(<span class="literal">NaN</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.prototype.flat()</code>: 扁平化嵌套数组和移除数组中的空项:</p><p>arr.flat(depth) 按照 depth （不传值的话默认是 1）深度拍平一个数组，并且将结果以新数组形式返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// depth 默认是 1</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">console</span>.log(arr1.flat())  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Infinity，可展开任意深度的嵌套数组；自动跳过空数组；</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, , [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]]]]</span><br><span class="line"><span class="built_in">console</span>.log(arr2.flat(<span class="literal">Infinity</span>))</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>用 reduce 实现拍平一层数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> newStr = arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc.concat(cur), [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">const</span> flattened = <span class="function"><span class="params">arr</span> =&gt;</span> [].concat(...arr)</span><br><span class="line">flattened(arr)</span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.flatMap()</p><p>flatMap(callback) 使用映射函数 callback 映射每个元素，callback 每次的返回值组成一个数组，并且将这个数组执行类似 arr.flat(1) 的操作进行拍平一层后最后返回结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// 将 [[2], [4], [6], [8]] 数组拍平一层得到最终结果：[2, 4, 6, 8]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h2><ol><li><p>函数参数默认值</p><ul><li><p>参数不能有同名的</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, x, y = <span class="number">1</span></span>) </span>&#123;&#125;  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li><li><p>函数体内不能用 let 和 const 声明同参数名的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>length：返回没有指定默认值的参数个数</p><p>  如果设置默认值的参数不是尾参数，则 length 不再计入后面的参数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>)</span>&#123;&#125;).length      <span class="comment">// 2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">1</span></span>)</span>&#123;&#125;).length  <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>)</span>&#123;&#125;).length  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>rest/spread参数(…)：返回函数多余参数</p><ul><li>形式：以数组的形式存在，之后不能再有其他参数</li><li>作用：代替Arguments对象</li><li>length：返回没有指定默认值的参数个数但不包括rest/spread参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, ...y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> y) &#123;</span><br><span class="line">        coonsole.log(val)  <span class="comment">// 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>严格模式：在严格条件下运行JS</p><ul><li>应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式</li><li>规避限制的办法有两个：设置全局的严格模式或者在函数体外在包一个立即执行函数并且声明严格模式：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">2</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二</span></span><br><span class="line"><span class="keyword">let</span> f = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y = <span class="number">2</span></span>) </span>&#123;&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>箭头函数(=&gt;)</p><p> 箭头函数语法比函数表达式更简洁，并且没有自己的 this、arguments，不能用作构造函数和用作生成器。</p><ul><li>箭头函数误区<ul><li>函数体内的this是定义时所在的对象而不是使用时所在的对象</li><li>可让this指向固定化，这种特性很有利于封装回调函数</li><li>不可当作构造函数，因此箭头函数不可使用new命令</li><li>不可使用yield命令，因此箭头函数不能用作Generator函数</li><li>不可使用Arguments对象，此对象在函数体内不存在(可用rest/spread参数代替)</li><li>返回对象时必须在对象外面加上括号</li></ul></li></ul></li><li><p>尾调用优化：只保留内层函数的调用帧</p><ul><li>尾调用<ul><li>定义：某个函数的最后一步是调用另一个函数</li><li>形式：function f(x) { return g(x); }</li></ul></li><li>尾递归<ul><li>定义：函数尾调用自身</li><li>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</li><li>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</li></ul></li></ul></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903959283367950#heading-0">1.5万字概括ES6全部特性(已更新ES2020)</a></li><li><a href="https://juejin.cn/post/6895898051559456776#heading-0">送你一份精心总结的3万字ES6实用指南（上）</a></li><li><a href="https://juejin.cn/post/6896986598999588872#heading-0">「建议收藏」送你一份精心总结的3万字ES6实用指南（下）</a></li><li><a href="https://juejin.cn/post/6844903775329583112#heading-1">近一万字的ES6语法知识点补充</a></li><li><a href="https://juejin.cn/post/6844903679976275976#heading-1">ES6、ES7、ES8特性一锅炖(ES6、ES7、ES8学习指南)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;声
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
</feed>
