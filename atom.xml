<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤舟的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2021-01-19T16:00:00.000Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>孤舟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS之EventLoop(事件循环)</title>
    <link href="http://github.com/2021/01/20/JS%E4%B9%8BEventLoop(%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF)/"/>
    <id>http://github.com/2021/01/20/JS%E4%B9%8BEventLoop(%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF)/</id>
    <published>2021-01-19T16:00:00.000Z</published>
    <updated>2021-01-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="一-浏览器中的Event-Loop"><a href="#一-浏览器中的Event-Loop" class="headerlink" title="一 浏览器中的Event Loop"></a>一 浏览器中的Event Loop</h2><blockquote><p>Event Loop 即事件循环，是指浏览器或 Node 的一种解决 JavaScript 单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。</p></blockquote><h3 id="单线程和多线程"><a href="#单线程和多线程" class="headerlink" title="单线程和多线程"></a>单线程和多线程</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>JavaScript 是一个单线程的语言。</p><p>单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。</p><p>以 Chrome 浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程。</p><p>一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。</p><p>当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p><h4 id="浏览器内核是怎样的？"><a href="#浏览器内核是怎样的？" class="headerlink" title="浏览器内核是怎样的？"></a>浏览器内核是怎样的？</h4><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用 CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p><p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p><ul><li>GUI 渲染线程：解析 HTML、CSS 等。在 JavaScript 引擎线程运行脚本期间，GUI 渲染线程处于挂起状态，也就是被 “冻结” 了。</li><li>JavaScript 引擎线程：负责处理 JavaScript 脚本。</li><li>定时触发器线程：setTimeout、setInterval 等。事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行。</li><li>事件触发线程：负责将准备好的事件交给 JS 引擎执行。</li><li>异步 http 请求线程：负责执行异步请求之类函数的线程，例如 Promise.then()、ajax 等。</li></ul><ol><li><p>GUI 渲染线程</p><p> 主要负责页面的渲染，解析 HTML、CSS，构建 DOM 树，布局和绘制等。<br> 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。<br> 该线程与 JS 引擎线程互斥，当执行 JS 引擎线程时，GUI 渲染会被挂起，当任务队列空闲时，JS 引擎才会去执行 GUI 渲染。</p></li><li><p>JS 引擎线程</p><p> 该线程当然是主要负责处理 JavaScript 脚本，执行代码。<br> 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS 引擎线程的执行。<br> 当然，该线程与 GUI 渲染线程互斥，当 JS 引擎线程执行 JavaScript 脚本时间过长，将导致页面渲染的阻塞。</p></li><li><p>定时器触发线程</p><p> 负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。<br> 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行。</p></li><li><p>事件触发线程</p><p> 主要负责将准备好的事件交给 JS 引擎线程执行。<br> 比如 setTimeout 定时器计数结束， ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS 引擎线程的执行。</p></li><li><p>异步 http 请求线程</p><p> 负责执行异步请求一类的函数的线程，如： Promise，axios，ajax 等。<br> 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待 JS 引擎线程执行。</p><h4 id="为什么不设计成多线程？"><a href="#为什么不设计成多线程？" class="headerlink" title="为什么不设计成多线程？"></a>为什么不设计成多线程？</h4><p>JS是可以去操作DOM的。</p></li></ol><p>假设有个 DOM 节点，现在有线程 A 操作它，删除了这个 DOM；<br>然后线程 B 又操作它，修改了这个 DOM 某部分。<br>这肯定不可以。（多线程可以互不干预的操作一段内存空间）<br>所以干脆设计成一个单线程，安全稳妥不出事。</p><p>哪怕后期 HTML5 出了个 Web Worker 也是不允许操作 DOM 结构的，可以完成一些分布式的计算。</p><p>对于dom结构我们必须顺序操纵，坚决不允许出现对同一个dom同时进行操作。</p><h4 id="为什么需要异步？"><a href="#为什么需要异步？" class="headerlink" title="为什么需要异步？"></a>为什么需要异步？</h4><p>这时候又有问题了，如果调用某个接口（Ajax），或者加载某张图片的时候，我们卡住了，这样页面是不是就一直不能渲染？</p><p>然后因为单线程只能先让前面的程序走完，即便这个接口或者图片缓过来了，我下面还有其他任务没做呢，这不就卡死了么？</p><p>所以这时候异步来了：</p><p>在涉及某些需要等待的操作的时候，我们就选择让程序继续运行。</p><p>等待接口或者图片返回过来后，就通知程序我做好了，你可以继续调用了。</p><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><h4 id="为什么会有-Event-Loop？"><a href="#为什么会有-Event-Loop？" class="headerlink" title="为什么会有 Event Loop？"></a>为什么会有 Event Loop？</h4><p>JavaScript 线程一次只能做一件事。<br>如果碰到一些需要等待的程序，例如 setTimeout 等，那就歇菜了。<br>所以，JavaScript 为了协调事件、用户交互、脚本、渲染、网络等，就搞出来一个 事件循环（Event Loop）。</p><h4 id="什么是-Event-Loop？"><a href="#什么是-Event-Loop？" class="headerlink" title="什么是 Event Loop？"></a>什么是 Event Loop？</h4><p>JavaScript 从 script 开始读取，然后不断循环，从 “<code>任务队列</code>” 中读取执行事件的过程，就是 事件循环（<code>Event Loop</code>）。</p><h4 id="Event-Loop-执行过程"><a href="#Event-Loop-执行过程" class="headerlink" title="Event Loop 执行过程"></a>Event Loop 执行过程</h4><p>Event Loop 执行过程如下：</p><ol><li>一开始整个脚本 script 作为一个宏任务执行</li><li>执行过程中，同步代码 直接执行，宏任务 进入宏任务队列，微任务 进入微任务队列。</li><li>当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完毕。</li><li>执行浏览器 UI 线程的渲染工作。</li><li>检查是否有 Web Worker 任务，有则执行。</li><li>执行完本轮的宏任务，回到步骤 2，依次循环，直到宏任务和微任务队列为空。</li></ol><p>事件循环中的异步队列有两种：宏任务队列（MacroTask）和 微任务队列（MicroTask）。</p><p>Web Worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。</p><h4 id="宏任务队列可以有多个，微任务队列只有一个。"><a href="#宏任务队列可以有多个，微任务队列只有一个。" class="headerlink" title="宏任务队列可以有多个，微任务队列只有一个。"></a>宏任务队列可以有多个，微任务队列只有一个。</h4><p>宏任务 包括：</p><ul><li>script</li><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I/O</li><li>UI rendering</li></ul><p>微任务 包括：</p><ul><li>MutationObserver(html5 新特性)</li><li>Promise.then()/catch()</li><li>以 Promise 为基础开发的其他技术，例如 fetch API</li><li>V8 的垃圾回收过程</li><li>Node 独有的 process.nextTick</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ol><li><p>案例一</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise1&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p> 最后输出结果是 Promise1，setTimeout1，Promise2，setTimeout2</p><p> 一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出 Promise1，同时会生成一个宏任务 setTimeout2<br> 然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1<br> 在执行宏任务 setTimeout1 时会生成微任务 Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2<br> 清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</p></li><li><p>案例二</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： script start</span></span><br><span class="line"><span class="comment">//       async2 end</span></span><br><span class="line"><span class="comment">//       Promise</span></span><br><span class="line"><span class="comment">///      script end</span></span><br><span class="line"><span class="comment">//       async1 end</span></span><br><span class="line"><span class="comment">//       promise1</span></span><br><span class="line"><span class="comment">//       promise2</span></span><br><span class="line"><span class="comment">//       setTimeout</span></span><br></pre></td></tr></table></figure></li></ol><p>这里需要先理解async/await。<br>async/await 在底层转换成了 promise 和 then 回调函数。<br>也就是说，这是 promise 的语法糖。<br>每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。<br>async/await 的实现，离不开 Promise。从字面意思来理解，async 是“异步”的简写，而 await 是 async wait 的简写可以认为是等待异步方法执行完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> p</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化理解为：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> RESOLVE(p).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="node中的event-loop"><a href="#node中的event-loop" class="headerlink" title="node中的event loop"></a>node中的event loop</h2><h3 id="三大关键阶段"><a href="#三大关键阶段" class="headerlink" title="三大关键阶段"></a>三大关键阶段</h3><p>首先，梳理一下 nodejs 三个非常重要的执行阶段:</p><ol><li>执行 定时器回调 的阶段。检查定时器，如果到了时间，就执行回调。这些定时器就是setTimeout、setInterval。这个阶段暂且叫它timer。</li></ol><ol start="2"><li><p>轮询(英文叫poll)阶段。因为在node代码中难免会有异步操作，比如文件I/O，网络I/O等等，那么当这些异步操作做完了，就会来通知JS主线程，怎么通知呢？就是通过’data’、’connect’等事件使得事件循环到达 poll 阶段。到达了这个阶段后:</p><p> 如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到timer阶段。</p><p> 如果没有定时器, 会去看回调函数队列。</p><p> 如果队列不为空，拿出队列中的方法依次执行</p><p> 如果队列为空，检查是否有 setImmdiate 的回调</p><p> 有则前往check阶段(下面会说)</p><p> 没有则继续等待，相当于阻塞了一段时间(阻塞时间是有上限的), 等待 callback 函数加入队列，加入后会立刻执行。一段时间后自动进入 check 阶段。</p></li><li><p>check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。</p></li></ol><p>这三个阶段为一个循环过程。不过现在的eventLoop并不完整，我们现在就来一一地完善。</p><h3 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h3><p>首先，当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候 nodejs 会进入到 I/O异常的回调阶段。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。</p><p>并且在 check 阶段结束后还会进入到 关闭事件的回调阶段。如果一个 socket 或句柄（handle）被突然关闭，例如 socket.destroy()，<br>‘close’ 事件的回调就会在这个阶段执行。</p><p>梳理一下，nodejs 的 eventLoop 分为下面的几个阶段:</p><ol><li>timer 阶段</li><li>I/O 异常回调阶段</li><li>空闲、预备状态(第2阶段结束，poll 未触发之前)</li><li>poll 阶段</li><li>check 阶段</li><li>关闭事件的回调阶段</li></ol><h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这里我要说，node版本 &gt;= 11和在 11 以下的会有不同的表现。<br>首先说 node 版本 &gt;= 11的，它会和浏览器表现一致，一个定时器运行完立即运行相应的微任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">time2</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure><p>而 node 版本小于 11 的情况下，对于定时器的处理是:</p><p>若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务。</p><p>因此会打印出这样的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure><h3 id="关于process-nextTick的一点说明"><a href="#关于process-nextTick的一点说明" class="headerlink" title="关于process.nextTick的一点说明"></a>关于process.nextTick的一点说明</h3><p>process.nextTick 是一个独立于 eventLoop 的任务队列。<br>在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。</p><h2 id="nodejs-和-浏览器关于eventLoop的主要区别"><a href="#nodejs-和-浏览器关于eventLoop的主要区别" class="headerlink" title="nodejs 和 浏览器关于eventLoop的主要区别"></a>nodejs 和 浏览器关于eventLoop的主要区别</h2><p>两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。</p><h3 id="为啥会有-浏览器-Event-Loop-和-Node-js-Event-Loop？"><a href="#为啥会有-浏览器-Event-Loop-和-Node-js-Event-Loop？" class="headerlink" title="为啥会有 浏览器 Event Loop 和 Node.js Event Loop？"></a>为啥会有 浏览器 Event Loop 和 Node.js Event Loop？</h3><p>简单来说：</p><p>你的页面放到了浏览器去展示，你的数据放到了后台处理（将 Node.js 看成 PHP、Java 等后端语言），这两者能没有区别么？！<br>再仔细一点：</p><ul><li>Node.js：Node.js 的 Event Loop 是基于 libuv。libuv 已经对 Node.js 的 Event Loop 作出了实现。</li><li>浏览器：浏览器的 Event Loop 是基于 HTML5 规范 的。而 HTML5 规范中只是定义了浏览器中的 Event Loop 的模型，具体实现留给了浏览器厂商。<blockquote><p>libuv 是一个多平台支持库，主要用于异步 I/O。它最初是为 Node.js 开发的，现在 Luvit、Julia、pyuv 和其他的框架也使用它。</p></blockquote></li></ul><h2 id="浏览器与Node执行顺序的对比"><a href="#浏览器与Node执行顺序的对比" class="headerlink" title="浏览器与Node执行顺序的对比"></a>浏览器与Node执行顺序的对比</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">浏览器输出：</span></span><br><span class="line"><span class="comment">time1</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">time2</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Node输出：</span></span><br><span class="line"><span class="comment">time1</span></span><br><span class="line"><span class="comment">time2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><ul><li><p>在这个例子中，Node的逻辑如下：</p><p>最初timer1和timer2就在timers阶段中。开始时首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；<br>至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2。</p><p>而浏览器则因为两个setTimeout作为两个MacroTask, 所以先输出timer1, promise1，再输出timer2，promise2。</p></li><li><p>为了证明我们的理论，把代码改成下面的样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Node输出：</span></span><br><span class="line"><span class="comment">timer1               timer2</span></span><br><span class="line"><span class="comment">promise1    或者     promise2</span></span><br><span class="line"><span class="comment">timer2               timer1</span></span><br><span class="line"><span class="comment">promise2             promise1</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></li></ul><p>按理说setTimeout(fn,0)应该比setImmediate(fn)快，应该只有第二种结果，为什么会出现两种结果呢？<br>这是因为Node 做不到0毫秒，最少也需要1毫秒。实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。</p><p>另外，如果已经过了Timer阶段，那么setImmediate会比setTimeout更快，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;test.js&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>));</span><br><span class="line">  setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，setImmediate才会早于setTimeout执行。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000013861128">一篇文章教会你Event loop——浏览器和Node</a></li><li><a href="https://juejin.cn/post/6844904004007247880#heading-10">原生JS灵魂之问(下)</a></li><li><a href="https://zhuanlan.zhihu.com/p/54882306">浏览器与Node的事件循环(Event Loop)有何区别?</a></li><li><a href="https://juejin.cn/post/6844903764202094606#heading-0">一次弄懂Event Loop（彻底解决此类面试问题）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;一-浏览器中的Event-Loop&quot;&gt;&lt;a href=&quot;#一-浏览器中的Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;一 
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之Promise</title>
    <link href="http://github.com/2021/01/20/JS%E4%B9%8BPromise/"/>
    <id>http://github.com/2021/01/20/JS%E4%B9%8BPromise/</id>
    <published>2021-01-19T16:00:00.000Z</published>
    <updated>2021-01-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="Promise-初探"><a href="#Promise-初探" class="headerlink" title="Promise 初探"></a>Promise 初探</h2><h3 id="什么是-Promise？"><a href="#什么是-Promise？" class="headerlink" title="什么是 Promise？"></a>什么是 Promise？</h3><p>Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。现已被 ES6 纳入进规范中。</p><p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p><h3 id="Promise-出现的原因"><a href="#Promise-出现的原因" class="headerlink" title="Promise 出现的原因"></a>Promise 出现的原因</h3><ol><li>为了解决回调地狱带来的负面作用<ul><li>代码臃肿。</li><li>可读性差。</li><li>耦合度过高，可维护性差。</li><li>代码复用性差。</li><li>容易滋生 bug。</li><li>只能在回调里处理异常。</li></ul></li><li>解决异步嵌套的问题。</li></ol><h3 id="Promise-如何使用？常用的方法有哪些？它们的作用是什么？"><a href="#Promise-如何使用？常用的方法有哪些？它们的作用是什么？" class="headerlink" title="Promise 如何使用？常用的方法有哪些？它们的作用是什么？"></a>Promise 如何使用？常用的方法有哪些？它们的作用是什么？</h3><h4 id="1-new-Promise"><a href="#1-new-Promise" class="headerlink" title="1. new Promise"></a>1. new Promise</h4><p>首先，我们先看看如何走一个 new Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(resolve); <span class="comment">// [Function]</span></span><br><span class="line">  <span class="built_in">console</span>.log(reject); <span class="comment">// [Function]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise); <span class="comment">// Promise &#123; &lt;pending&gt; &#125;</span></span><br></pre></td></tr></table></figure><p>然后，我们对这几个概念进行区分：</p><ol><li><p>Promise 对象是一个构造函数，用来生成 Promise 实例，所以 new Promise() 不足奇怪。</p></li><li><p>new Promise() 传入一个函数，这个函数可以带 2 个参数：resolve 和 reject。</p></li><li><p>resolve 的作用是将 Promise 对象的状态从 “未完成” 变为 “成功”（pending -&gt; resolved）</p></li><li><p>reject 的作用是将 Promise 对象的状态从 “未完成” 变为 “失败”（pending -&gt; rejected）</p></li><li><p>在没有执行 resolve 和 reject 之前，它们还是 pending 的。</p><h4 id="2-Promise-状态"><a href="#2-Promise-状态" class="headerlink" title="2. Promise 状态"></a>2. Promise 状态</h4></li><li><p>Promise 有 3 种状态：pending、fulfilled、rejected</p><ul><li><p>初始状态：pending</p></li><li><p>成功状态：fulfilled（实际打印会看到 resolved）</p></li><li><p>失败状态：rejected</p><p>如果你在 new Promise 中用了 resolve()，那么它就会走 .then()；</p><p>如果你用的是 reject()，那么它就走 .catch()。</p></li></ul></li><li><p>Promise 的状态一经改变就不能再进行更改。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;成功 1&#x27;</span>);</span><br><span class="line">  reject(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">  resolve(<span class="string">&#x27;成功 2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;res：&#x27;</span>, res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;err：&#x27;</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出啥？=&gt; res： 成功 1</span></span><br></pre></td></tr></table></figure></li><li><p>Promise 也是不允许返回的：</p><p> 你将状态改为了 resolved，那么就不能再改了，只能.then()！</p></li></ol><h3 id="Promise也有一些缺点。"><a href="#Promise也有一些缺点。" class="headerlink" title="Promise也有一些缺点。"></a>Promise也有一些缺点。</h3><ol><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ol><p>如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。</p><h3 id="基本用法-API"><a href="#基本用法-API" class="headerlink" title="基本用法(API)"></a>基本用法(API)</h3><ol><li>Promise.resolve(value)<blockquote><p>类方法，该方法返回一个以 value 值解析后的 Promise 对象</p></blockquote></li></ol><ul><li>如果这个值是个 thenable（即带有 then 方法），返回的 Promise 对象会“跟随”这个 thenable 的对象，采用它的最终状态（指 resolved/rejected/pending/settled）</li><li>如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。</li><li>其他情况以该值为成功状态返回一个 Promise 对象。</li></ul><p>上面是 resolve 方法的解释，传入不同类型的 value 值，返回结果也有区别。</p><ol><li><p>如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="number">123</span>);</span><br><span class="line">    &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p0 = <span class="keyword">new</span> <span class="built_in">Promise</span>(fn);</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(p0);</span><br><span class="line"><span class="comment">// 返回为true，返回的 Promise 即是 入参的 Promise 对象。</span></span><br><span class="line"><span class="built_in">console</span>.log(p0 === p1);</span><br></pre></td></tr></table></figure><ol start="2"><li>传入 thenable 对象，返回 Promise 对象跟随 thenable 对象的最终状态。</li></ol><p>ES6 Promises 里提到了 Thenable 这个概念，简单来说它就是一个非常类似 Promise 的东西。最简单的例子就是 jQuery.ajax，它的返回值就是 thenable 对象。但是要谨记，并不是只要实现了 then 方法就一定能作为 Promise 对象来使用。</p><p>如果传入的 value 本身就是 thenable 对象，返回的 promise 对象会跟随 thenable 对象的状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">&#x27;/test/test.json&#x27;</span>));<span class="comment">// =&gt; promise对象</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>返回一个状态已变成 resolved 的 Promise 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">123</span>); </span><br><span class="line"><span class="comment">//打印p1 可以看到p1是一个状态置为resolved的Promise对象</span></span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br></pre></td></tr></table></figure><ol start="2"><li>Promise.reject</li></ol><p>类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。</p></li></ol><ol start="3"><li><p>Promise.prototype.then</p><p> 实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。</p></li><li><p>Promise.prototype.catch</p><p> 实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息。</p></li><li><p>Promise.prototype.finally()</p><p> finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。finally方法里面的操作，是与状态无关的，不依赖于 Promise 的执行结果。该方法是 ES2018 引入标准的。</p></li></ol><ol start="6"><li><p>Promise.race()</p><p> 类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败。<br> 。</p></li><li><p>Promise.all()</p><p> 类方法，多个 Promise 任务同时执行。<br> 如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。  如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1,p2])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;等到两个异步完成后，再执行&#x27;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>Promise.any()</p><p> ES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</p><p> Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。</p></li><li><p>Promise.allSettled()</p><p> Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 ES2020 引入。</p></li></ol><h2 id="Promise的一些应用"><a href="#Promise的一些应用" class="headerlink" title="Promise的一些应用"></a>Promise的一些应用</h2><ol><li><p>加载图片</p><p> 我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>用Promise对象实现的 Ajax 操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="built_in">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">&quot;/posts.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Contents: &#x27;</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ol><ul><li><a href="https://juejin.cn/post/6844903625609707534">面试精选之Promise</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise">ECMAScript 6 入门(阮一峰)</a></li><li><a href="https://blog.csdn.net/weixin_37719279/article/details/80950713">ES6之Promise常见面试题</a></li><li><a href="https://juejin.cn/post/6844903509934997511">Promise 必知必会（十道题）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;Promise-初探&quot;&gt;&lt;a href=&quot;#Promise-初探&quot; class=&quot;headerlink&quot; title=&quot;Promise 初探&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之作用域和执行上下文篇</title>
    <link href="http://github.com/2021/01/15/JS%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AF%87/"/>
    <id>http://github.com/2021/01/15/JS%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AF%87/</id>
    <published>2021-01-14T16:00:00.000Z</published>
    <updated>2021-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h3 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>1.概念</p><ul><li><p>作用域是指程序源代码中定义变量的区域。</p><p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p></li><li><p>静态作用域与动态作用域区别</p><p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p><p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p></li></ul><ol start="2"><li>案例理解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value &#x3D; 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结果是 1</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>静态作用域分析</p><p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p></li><li><p>动态作用域分析</p><p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p></li></ul><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><blockquote><p>JavaScript引擎并非一行一行地分析和执行程序，而是一段一段地分析，顺序执行。</p></blockquote><ul><li><p>概念</p><p>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p></li><li><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul></li><li><p>可执行代码</p><ul><li><p>js的可执行代码(executable code)的类型：全局代码、函数代码、eval代码。</p></li><li><p>举个例子</p><p>当javaScript引擎执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution contexts)”</p></li></ul></li><li><p>JavaScript 中有 3 种执行上下文类型：</p><ol><li>全局执行上下文：这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li>函数执行上下文：每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤。</li><li>Eval 函数执行上下文：执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。</li></ol></li></ul><h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>执行栈，也就是在其它编程语言中所说的 “调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。</p><p>当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p><p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><h4 id="模拟理解"><a href="#模拟理解" class="headerlink" title="模拟理解"></a>模拟理解</h4><p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [];</span><br></pre></td></tr></table></figure><p>  试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>JavaScript 遇到下面的这段代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fun3() &#123;</span><br><span class="line">    console.log(&#39;fun3&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun2() &#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure><p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 伪代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun1()</span><br><span class="line">ECStack.push(&lt;fun1&gt; functionContext);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun1中竟然调用了fun2，还要创建fun2的执行上下文</span><br><span class="line">ECStack.push(&lt;fun2&gt; functionContext);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 擦，fun2还调用了fun3！</span><br><span class="line">ECStack.push(&lt;fun3&gt; functionContext);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun3执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun2执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fun1执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span><br></pre></td></tr></table></figure><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><blockquote><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p></blockquote><p>因为不同执行上下文下的变量对象稍有不同，所以有全局上下文下的变量对象和函数上下文下的变量对象。</p><p>全局上下文中的变量对象就是全局对象</p><h4 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h4><ul><li><p>概念</p><p>在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</p><p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p></li><li><p>执行过程</p><ul><li>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做： 1.进入执行上下文   2.代码执行</li></ul></li><li><p>进入执行上下文</p><p>  当进入执行上下文时，这时候还没有执行代码，</p><p>变量对象会包括：</p><ol><li><p>函数的所有形参 (如果是函数上下文)</p><p> 由名称和对应值组成的一个变量对象的属性被创建<br> 没有实参，属性值设为 undefined</p></li><li><p>函数声明</p><p> 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建<br> 如果变量对象已经存在相同名称的属性，则完全替换这个属性</p></li><li><p>变量声明</p><p> 由名称和对应值（undefined）组成一个变量对象的属性被创建；<br> 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</p></li></ol></li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  var b &#x3D; 2;</span><br><span class="line">  function c() &#123;&#125;</span><br><span class="line">  var d &#x3D; function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b &#x3D; 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(1);</span><br></pre></td></tr></table></figure><p>在进入执行上下文后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: undefined,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行<br>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p><p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO &#x3D; &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 3,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p><p>全局上下文的变量对象初始化是全局对象</p><p>函数上下文的变量对象初始化只包括 Arguments 对象</p><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p><p>在代码执行阶段，会再次修改变量对象的属性值</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><blockquote><p>本文参考网站：</p></blockquote><ul><li><a href="https://juejin.cn/post/6844903479429824526">JavaScript深入系列15篇</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h3 id=&quot;词法作用域和动态作用域&quot;&gt;&lt;a href=&quot;#词法作用域和动态作用域&quot; class=&quot;headerlink&quot; title=&quot;词法作用域和动态作用域&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之闭包篇</title>
    <link href="http://github.com/2021/01/15/JS%E4%B9%8B%E9%97%AD%E5%8C%85%E7%AF%87/"/>
    <id>http://github.com/2021/01/15/JS%E4%B9%8B%E9%97%AD%E5%8C%85%E7%AF%87/</id>
    <published>2021-01-14T16:00:00.000Z</published>
    <updated>2021-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结(copy)，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h3 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h3><h4 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h4><blockquote><p>红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，</p></blockquote><blockquote><p>MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。<br>（其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）</p></blockquote><p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量。</p><p>当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。</p><p>简单来说：</p><p>在函数 A 中还有函数 B，函数 B 调用了函数 A 中的变量，那么函数 B 就称为函数 A 的闭包。</p><h4 id="闭包产生的原因"><a href="#闭包产生的原因" class="headerlink" title="闭包产生的原因?"></a>闭包产生的原因?</h4><ul><li>首先要明白作用域链的概念，其实很简单，在ES5中只存在两种作用域————全局作用域和函数作用域，</li><li>当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，</li><li>值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。</li></ul><p>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">function f1() &#123;</span><br><span class="line">  var a &#x3D; 2</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    var a &#x3D; 3;</span><br><span class="line">    console.log(a);&#x2F;&#x2F;3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，f1的作用域指向有全局作用域(window)和它本身，而f2的作用域指向全局作用域(window)、f1和它本身。而且作用域是从最底层向上找，直到找到全局作用域window为止，如果全局还没有的话就会报错。</p><h4 id="闭包产生的本质"><a href="#闭包产生的本质" class="headerlink" title="闭包产生的本质"></a>闭包产生的本质</h4><p>闭包产生的本质就是，当前环境中存在指向父级作用域的引用。</p><p>还是举上面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var a &#x3D; 2</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    console.log(a);&#x2F;&#x2F;2</span><br><span class="line">  &#125;</span><br><span class="line">  return f2;</span><br><span class="line">&#125;</span><br><span class="line">var x &#x3D; f1();</span><br><span class="line">x();</span><br></pre></td></tr></table></figure><p>这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。<br>那是不是只有返回函数才算是产生了闭包呢？、<br>回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f3;</span><br><span class="line">function f1() &#123;</span><br><span class="line">  var a &#x3D; 2</span><br><span class="line">  f3 &#x3D; function() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line">f3();</span><br></pre></td></tr></table></figure><p>让f1执行，给f3赋值后，等于说现在f3拥有了window、f1和f3本身这几个作用域的访问权限，还是自底向上查找，最近是在f1中找到了a,因此输出2。<br>在这里是外面的变量f3存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变。</p><h3 id="闭包好处和坏处"><a href="#闭包好处和坏处" class="headerlink" title="闭包好处和坏处"></a>闭包好处和坏处</h3><ul><li><p>好处：</p><p>  缓存。将变量隐藏起来不被 GC 回收。<br>  实现柯里化。利用闭包特性完成柯里化。</p></li><li><p>坏处：</p><p>  内存消耗。闭包产生的变量无法被销毁。<br>  性能问题。由于闭包内部变量优先级高于外部变量，所以需要多查找作用域链的一个层次，一定程度影响查找速度。</p><h3 id="闭包有哪些表现形式"><a href="#闭包有哪些表现形式" class="headerlink" title="闭包有哪些表现形式?"></a>闭包有哪些表现形式?</h3><p>哪些地方能体现闭包的存在？</p></li><li><p>返回一个函数。<br>刚刚已经举例。<br>作为函数参数传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">function foo()&#123;</span><br><span class="line">  var a &#x3D; 2;</span><br><span class="line">  function baz()&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(baz);</span><br><span class="line">&#125;</span><br><span class="line">function bar(fn)&#123;</span><br><span class="line">  &#x2F;&#x2F; 这就是闭包</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出2，而不是1</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></li><li><p>在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。</p><p>以下的闭包保存的仅仅是window和当前作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定时器</span><br><span class="line">setTimeout(function timeHandler()&#123;</span><br><span class="line">  console.log(&#39;111&#39;);</span><br><span class="line">&#125;，100)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 事件监听</span><br><span class="line">$(&#39;#app&#39;).click(function()&#123;</span><br><span class="line">  console.log(&#39;DOM Listener&#39;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2;</span><br><span class="line">(function IIFE()&#123;</span><br><span class="line">  &#x2F;&#x2F; 输出2</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ul><p>如何解决下面的循环输出问题？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 1; i &lt;&#x3D; 5; i ++)&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>为什么会全部输出6？如何改进，让它输出1，2，3，4，5？(方法越多越好)</p><p>因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。</p></li><li><p>解决方法：</p><p>1、利用IIFE(立即执行函数表达式)当每次for循环时，把此时的i变量传递到定时器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 1;i &lt;&#x3D; 5;i++)&#123;</span><br><span class="line">  (function(j)&#123;</span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line">      console.log(j)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、给定时器传入第三个参数, 作为timer函数的第一个函数参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i&#x3D;1;i&lt;&#x3D;5;i++)&#123;</span><br><span class="line">  setTimeout(function timer(j)&#123;</span><br><span class="line">    console.log(j)</span><br><span class="line">  &#125;, 0, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用ES6中的let</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i &#x3D; 1; i &lt;&#x3D; 5; i++)&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let使JS发生革命性的变化，让JS有函数作用域变为了块级作用域，用let后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; i &#x3D; 1</span><br><span class="line">&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; i &#x3D; 2</span><br><span class="line">&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; i &#x3D; 3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因此能输出正确的结果。</p></li></ul><blockquote><p>本文参考(copy)网站：</p></blockquote><ul><li><p><a href="https://juejin.cn/post/6844903974378668039">J原生JS灵魂之问</a></p></li><li><p><a href="https://juejin.cn/post/6844903769646317576#heading-1">发现 JavaScript 中闭包的强大威力</a></p></li><li><p><a href="http://blog.leapoahead.com/2015/09/15/js-closure/">JavaScript闭包的底层运行机制</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结(copy)，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h3 id=&quot;闭包的理解&quot;&gt;&lt;a href=&quot;#闭包的理解&quot; class=&quot;headerlink&quot; title=&quot;闭包的理解&quot;&gt;&lt;/a&gt;闭包的理解&lt;/h3
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之类型篇</title>
    <link href="http://github.com/2021/01/15/JS%E4%B9%8B%E7%B1%BB%E5%9E%8B%E7%AF%87/"/>
    <id>http://github.com/2021/01/15/JS%E4%B9%8B%E7%B1%BB%E5%9E%8B%E7%AF%87/</id>
    <published>2021-01-14T16:00:00.000Z</published>
    <updated>2021-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="JS数据类型基础概念"><a href="#JS数据类型基础概念" class="headerlink" title="JS数据类型基础概念"></a>JS数据类型基础概念</h2><h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><p>JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：</p><h3 id="JS原始数据类型和引用数据类型"><a href="#JS原始数据类型和引用数据类型" class="headerlink" title="JS原始数据类型和引用数据类型"></a>JS原始数据类型和引用数据类型</h3><ol><li>7种JS原始数据类型</li></ol><ul><li>boolean</li><li>null</li><li>undefined</li><li>number</li><li>string</li><li>symbol</li><li>bigint</li></ul><ol start="2"><li>引用数据类型:</li></ol><ul><li>对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）</li></ul><h4 id="说出下面运行的结果，解释原因。"><a href="#说出下面运行的结果，解释原因。" class="headerlink" title="说出下面运行的结果，解释原因。"></a>说出下面运行的结果，解释原因。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function test(person) &#123;</span><br><span class="line">  person.age &#x3D; 26</span><br><span class="line">  person &#x3D; &#123;</span><br><span class="line">    name: &#39;hzj&#39;,</span><br><span class="line">    age: 18</span><br><span class="line">  &#125;</span><br><span class="line">  return person</span><br><span class="line">&#125;</span><br><span class="line">const p1 &#x3D; &#123;</span><br><span class="line">  name: &#39;fyq&#39;,</span><br><span class="line">  age: 19</span><br><span class="line">&#125;</span><br><span class="line">const p2 &#x3D; test(p1)</span><br><span class="line">console.log(p1) &#x2F;&#x2F; -&gt; ?</span><br><span class="line">console.log(p2) &#x2F;&#x2F; -&gt; ?</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结果:</span><br><span class="line">p1：&#123;name: “fyq”, age: 26&#125;</span><br><span class="line">p2：&#123;name: “hzj”, age: 18&#125;</span><br></pre></td></tr></table></figure><p>原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用person.age = 26确实改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。</p><h4 id="typeof-null-输出-object问题？"><a href="#typeof-null-输出-object问题？" class="headerlink" title="typeof null 输出 object问题？"></a>typeof null 输出 object问题？</h4><p>结论: 。<br>解释: 首先null不是对象，typeof null 会输出 object，这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。</p><h4 id="‘1’-toString-为什么可以调用？"><a href="#‘1’-toString-为什么可以调用？" class="headerlink" title="‘1’.toString()为什么可以调用？"></a>‘1’.toString()为什么可以调用？</h4><p>其实在这个语句运行的过程中做了这样几件事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; new Object(&#39;1&#39;);</span><br><span class="line">s.toString();</span><br><span class="line">s &#x3D; null;</span><br></pre></td></tr></table></figure><ol><li>第一步: 创建Object类实例。注意为什么不是String ？ 由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。</li><li>第二步: 调用实例方法。</li><li>第三步: 执行完方法立即销毁这个实例。<br>整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean, Number和String。</li></ol><blockquote><p>参考:《JavaScript高级程序设计(第三版)》P118</p></blockquote><h4 id="0-1-0-2为什么不等于0-3？"><a href="#0-1-0-2为什么不等于0-3？" class="headerlink" title="0.1+0.2为什么不等于0.3？"></a>0.1+0.2为什么不等于0.3？</h4><p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p><h3 id="如何理解BigInt"><a href="#如何理解BigInt" class="headerlink" title="如何理解BigInt?"></a>如何理解BigInt?</h3><h4 id="什么是BigInt"><a href="#什么是BigInt" class="headerlink" title="什么是BigInt?"></a>什么是BigInt?</h4><p>BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。</p><h4 id="为什么需要BigInt"><a href="#为什么需要BigInt" class="headerlink" title="为什么需要BigInt?"></a>为什么需要BigInt?</h4><p>在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？</p><p>这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(999999999999999);</span><br><span class="line">&#x2F;&#x2F; 输出10000000000000000</span><br></pre></td></tr></table></figure><p>同时也会有一定的安全性问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9007199254740992 &#x3D;&#x3D;&#x3D; 9007199254740993;    &#x2F;&#x2F; → true 居然是true!</span><br></pre></td></tr></table></figure><h4 id="如何创建并使用BigInt？"><a href="#如何创建并使用BigInt？" class="headerlink" title="如何创建并使用BigInt？"></a>如何创建并使用BigInt？</h4><p>要创建BigInt，只需要在数字末尾追加n即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log( 9007199254740995n );    &#x2F;&#x2F; → 9007199254740995n    </span><br><span class="line">console.log( 9007199254740995 );     &#x2F;&#x2F; → 9007199254740996</span><br></pre></td></tr></table></figure><p>另一种创建BigInt的方法是用BigInt()构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInt(&quot;9007199254740995&quot;);    &#x2F;&#x2F; → 9007199254740995n</span><br></pre></td></tr></table></figure><p>简单使用如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">10n + 20n;    &#x2F;&#x2F; → 30n    </span><br><span class="line">10n - 20n;    &#x2F;&#x2F; → -10n    </span><br><span class="line">+10n;         &#x2F;&#x2F; → TypeError: Cannot convert a BigInt value to a number    </span><br><span class="line">-10n;         &#x2F;&#x2F; → -10n    </span><br><span class="line">10n * 20n;    &#x2F;&#x2F; → 200n    </span><br><span class="line">20n &#x2F; 10n;    &#x2F;&#x2F; → 2n    </span><br><span class="line">23n % 10n;    &#x2F;&#x2F; → 3n    </span><br><span class="line">10n ** 3n;    &#x2F;&#x2F; → 1000n    </span><br><span class="line"></span><br><span class="line">const x &#x3D; 10n;    </span><br><span class="line">++x;          &#x2F;&#x2F; → 11n    </span><br><span class="line">--x;          &#x2F;&#x2F; → 9n</span><br><span class="line">console.log(typeof x);   &#x2F;&#x2F;&quot;bigint&quot;</span><br></pre></td></tr></table></figure><p>值得警惕的点</p><ul><li>BigInt不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js代码。</li></ul><ul><li><p>因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 + 10n;    &#x2F;&#x2F; → TypeError</span><br></pre></td></tr></table></figure></li><li><p>不能将BigInt传递给Web api和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(2n, 4n, 6n);    &#x2F;&#x2F; → TypeError</span><br></pre></td></tr></table></figure></li><li><p>当 Boolean 类型与 BigInt 类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(0n)&#123;&#x2F;&#x2F;条件判断为false</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if(3n)&#123;&#x2F;&#x2F;条件为true</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>元素都为BigInt的数组可以进行sort。</p></li></ul><p>  BigInt可以正常地进行位运算，如|、&amp;、&lt;&lt;、&gt;&gt;和^</p><p>浏览器兼容性</p><ul><li>其实现在的兼容性并不怎么好，只有chrome67、firefox、Opera这些主流实现</li></ul><h3 id="JS数据类型检测"><a href="#JS数据类型检测" class="headerlink" title="JS数据类型检测"></a>JS数据类型检测</h3><ol><li>typeof 是否能正确判断类型？<br>对于原始类型来说，除了 null 都可以调用typeof显示正确的类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 &#x2F;&#x2F; &#39;number&#39;</span><br><span class="line">typeof &#39;1&#39; &#x2F;&#x2F; &#39;string&#39;</span><br><span class="line">typeof undefined &#x2F;&#x2F; &#39;undefined&#39;</span><br><span class="line">typeof true &#x2F;&#x2F; &#39;boolean&#39;</span><br><span class="line">typeof Symbol() &#x2F;&#x2F; &#39;symbol&#39;</span><br></pre></td></tr></table></figure>但对于引用数据类型，除了函数之外，都会显示”object”。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof [] &#x2F;&#x2F; &#39;object&#39;</span><br><span class="line">typeof &#123;&#125; &#x2F;&#x2F; &#39;object&#39;</span><br><span class="line">typeof console.log &#x2F;&#x2F; &#39;function&#39;</span><br></pre></td></tr></table></figure>因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const Person &#x3D; function() &#123;&#125;</span><br><span class="line">const p1 &#x3D; new Person()</span><br><span class="line">p1 instanceof Person &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">var str1 &#x3D; &#39;hello world&#39;</span><br><span class="line">str1 instanceof String &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">var str2 &#x3D; new String(&#39;hello world&#39;)</span><br><span class="line">str2 instanceof String &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li><li>instanceof能否判断基本数据类型？<br>能。比如下面这种方式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class PrimitiveNumber &#123;</span><br><span class="line">  static [Symbol.hasInstance](x) &#123;</span><br><span class="line">    return typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(111 instanceof PrimitiveNumber) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>如果你不知道Symbol，可以看看MDN上关于hasInstance的解释。<br>其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。</li><li>能不能手动实现一下instanceof的功能？<br>核心: 原型链的向上查找。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">    &#x2F;&#x2F;基本数据类型直接返回false</span><br><span class="line">    if(typeof left !&#x3D;&#x3D; &#39;object&#39; || left &#x3D;&#x3D;&#x3D; null) return false;</span><br><span class="line">    &#x2F;&#x2F;getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象</span><br><span class="line">    let proto &#x3D; Object.getPrototypeOf(left);</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        &#x2F;&#x2F;查找到尽头，还没找到</span><br><span class="line">        if(proto &#x3D;&#x3D; null) return false;</span><br><span class="line">        &#x2F;&#x2F;找到相同的原型对象</span><br><span class="line">        if(proto &#x3D;&#x3D; right.prototype) return true;</span><br><span class="line">        proto &#x3D; Object.getPrototypeOf(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>测试:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(myInstanceof(&quot;111&quot;, String)); &#x2F;&#x2F;false</span><br><span class="line">console.log(myInstanceof(new String(&quot;111&quot;), String));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure></li><li>constructor检测类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 123;</span><br><span class="line">var str &#x3D; &#39;abcdef&#39;;</span><br><span class="line">var bool &#x3D; true;</span><br><span class="line">var arr &#x3D; [1, 2, 3, 4];</span><br><span class="line">var json &#x3D; &#123; name: &#39;jsliang&#39;, age: 25 &#125;;</span><br><span class="line">var func &#x3D; function () &#123; console.log(&#39;this is function&#39;); &#125;</span><br><span class="line">var und &#x3D; undefined;</span><br><span class="line">var nul &#x3D; null;</span><br><span class="line">var date &#x3D; new Date();</span><br><span class="line">var reg &#x3D; &#x2F;^[a-zA-Z]&#123;5,20&#125;$&#x2F;;</span><br><span class="line">var error &#x3D; new Error();</span><br><span class="line"></span><br><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var Tom &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  Tom.constructor &#x3D;&#x3D;&#x3D; Person,</span><br><span class="line">  num.constructor &#x3D;&#x3D;&#x3D; Number,</span><br><span class="line">  str.constructor &#x3D;&#x3D;&#x3D; String,</span><br><span class="line">  bool.constructor &#x3D;&#x3D;&#x3D; Boolean,</span><br><span class="line">  arr.constructor &#x3D;&#x3D;&#x3D; Array,</span><br><span class="line">  json.constructor &#x3D;&#x3D;&#x3D; Object,</span><br><span class="line">  func.constructor &#x3D;&#x3D;&#x3D; Function,</span><br><span class="line">  date.constructor &#x3D;&#x3D;&#x3D; Date,</span><br><span class="line">  reg.constructor &#x3D;&#x3D;&#x3D; RegExp,</span><br><span class="line">  error.constructor &#x3D;&#x3D;&#x3D; Error</span><br><span class="line">);</span><br></pre></td></tr></table></figure>得到的所有结果都是 true，除了 undefined 和 null，其他类型基本可以通过 constructor 判断。</li></ol><p>不过因为 constructor 的属性是可以被修改的，可能导致检测出的结果不正确。</p><ol start="5"><li><p>Array.prototype.toString.call检测类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 123;</span><br><span class="line">var str &#x3D; &#39;abcdef&#39;;</span><br><span class="line">var bool &#x3D; true;</span><br><span class="line">var arr &#x3D; [1, 2, 3, 4];</span><br><span class="line">var json &#x3D; &#123; name: &#39;jsliang&#39;, age: 25 &#125;;</span><br><span class="line">var func &#x3D; function () &#123; console.log(&#39;this is function&#39;); &#125;</span><br><span class="line">var und &#x3D; undefined;</span><br><span class="line">var nul &#x3D; null;</span><br><span class="line">var date &#x3D; new Date();</span><br><span class="line">var reg &#x3D; &#x2F;^[a-zA-Z]&#123;5,20&#125;$&#x2F;;</span><br><span class="line">var error &#x3D; new Error();</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  Object.prototype.toString.call(num), &#x2F;&#x2F; [object Number]</span><br><span class="line">  Object.prototype.toString.call(str), &#x2F;&#x2F; [object String]</span><br><span class="line">  Object.prototype.toString.call(bool), &#x2F;&#x2F; [object Boolean]</span><br><span class="line">  Object.prototype.toString.call(arr), &#x2F;&#x2F; [object Array]</span><br><span class="line">  Object.prototype.toString.call(json), &#x2F;&#x2F; [object Object]</span><br><span class="line">  Object.prototype.toString.call(func), &#x2F;&#x2F; [object Function]</span><br><span class="line">  Object.prototype.toString.call(und), &#x2F;&#x2F; [object Undefined]</span><br><span class="line">  Object.prototype.toString.call(nul), &#x2F;&#x2F; [object Null]</span><br><span class="line">  Object.prototype.toString.call(date), &#x2F;&#x2F; [object Date]</span><br><span class="line">  Object.prototype.toString.call(reg), &#x2F;&#x2F; [object RegExp]</span><br><span class="line">  Object.prototype.toString.call(error), &#x2F;&#x2F; [object Error]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一个完美的判断方法，可以检测上面提到的所有类型，只需要将它的结果 result.slice(8, -1) 就能得到具体的类型。</p></li><li><p>Object.is和===的区别？<br>Object在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。<br>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function is(x, y) &#123;</span><br><span class="line">  if (x &#x3D;&#x3D;&#x3D; y) &#123;</span><br><span class="line">    &#x2F;&#x2F;运行到1&#x2F;x &#x3D;&#x3D;&#x3D; 1&#x2F;y的时候x和y都为0，但是1&#x2F;+0 &#x3D; +Infinity， 1&#x2F;-0 &#x3D; -Infinity, 是不一样的</span><br><span class="line">    return x !&#x3D;&#x3D; 0 || y !&#x3D;&#x3D; 0 || 1 &#x2F; x &#x3D;&#x3D;&#x3D; 1 &#x2F; y;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;NaN&#x3D;&#x3D;&#x3D;NaN是false,这是不对的，我们在这里做一个拦截，x !&#x3D;&#x3D; x，那么一定是 NaN, y 同理</span><br><span class="line">    &#x2F;&#x2F;两个都是NaN的时候返回true</span><br><span class="line">    return x !&#x3D;&#x3D; x &amp;&amp; y !&#x3D;&#x3D; y;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="JS数据类型转换"><a href="#JS数据类型转换" class="headerlink" title="JS数据类型转换"></a>JS数据类型转换</h3></li><li><p>[] == ![]结果是什么？为什么？<br>解析:<br>== 中，左右两边都需要转换为数字然后进行比较。<br>[]转换为数字为0。<br>![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true,<br>因此![]为false，进而在转换成数字，变为0。<br>0 == 0 ， 结果为true</p></li><li><p>JS中类型转换有哪几种？<br>JS中，类型转换只有三种：</p></li></ol><p>转换成数字<br>转换成布尔值<br>转换成字符串</p><p>转换具体规则如下:</p><p>注意”Boolean 转字符串”这行结果指的是 true 转字符串的例子</p><ol start="3"><li>== 和 ===有什么区别？<br>===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如’1’===1的结果是false，因为一边是string，另一边是number。<br>复制代码<br>==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下：</li></ol><p>两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false<br>判断的是否是null和undefined，是的话就返回true<br>判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较<br>判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较<br>如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#123;a: 1&#125; &#x3D;&#x3D; true);&#x2F;&#x2F;false</span><br><span class="line">console.log(&#123;a: 1&#125; &#x3D;&#x3D; &quot;[object Object]&quot;);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><ol start="4"><li>对象转原始类型是根据什么流程运行的？<br>对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</li></ol><p>如果Symbol.toPrimitive()方法，优先调用再返回<br>调用valueOf()，如果转换为原始类型，则返回<br>调用toString()，如果转换为原始类型，则返回<br>如果都没有返回原始类型，会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  value: 3,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return 4;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;5&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line">    return 6</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj + 1); &#x2F;&#x2F; 输出7</span><br></pre></td></tr></table></figure><ol start="5"><li>如何让if(a == 1 &amp;&amp; a == 2)条件成立？<br>13 使 a == 1 &amp;&amp; a == 2 成立</li></ol><ul><li><p>方法一</p><p>在类型转换的时候，我们知道了对象如何转换成原始数据类型。如果部署了 [Symbol.toPrimitive]，那么返回的就是 Symbol.toPrimitive 的返回值。</p><p>当然，我们也可以把此函数部署在 valueOf 或者是 toString 接口上，效果相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;利用闭包延长作用域的特性</span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">  [Symbol.toPrimitive]: (function () &#123;</span><br><span class="line">    let i &#x3D; 1;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      return i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二</p><p>利用 Object.defineProperty 在 window/global 上定义 a 属性，获取 a 属性时，会调用 get</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let val &#x3D; 1;</span><br><span class="line">Object.defineProperty(window, &#39;a&#39;, &#123;</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    return val++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>方法三</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3];</span><br><span class="line">a.join &#x3D; a.shift;</span><br></pre></td></tr></table></figure><p>数组的 toString 方法返回一个字符串，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</p><p>因此，我们可以重新 join 方法。返回第一个元素，并将其删除。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;JS数据类型基础概念&quot;&gt;&lt;a href=&quot;#JS数据类型基础概念&quot; class=&quot;headerlink&quot; title=&quot;JS数据类型基础概念&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之类型篇</title>
    <link href="http://github.com/2021/01/15/JS%E4%B9%8Bthis%E7%AF%87/"/>
    <id>http://github.com/2021/01/15/JS%E4%B9%8Bthis%E7%AF%87/</id>
    <published>2021-01-14T16:00:00.000Z</published>
    <updated>2021-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="this问题"><a href="#this问题" class="headerlink" title="this问题"></a>this问题</h2><p>先记住 1 句话：</p><ul><li><strong><code>this</code> 永远指向最后调用它的那个对象</strong></li></ul><p>再牢记 2 句话：</p><ul><li>普通函数中 <code>this</code> 的指向，是 <code>this</code> <strong>执行时</strong>的上下文</li><li>箭头函数中 <code>this</code> 的指向，是 <code>this</code> <strong>定义时</strong>的上下文</li></ul><p>作用域链和 <code>this</code> 是两套不同的系统，它们之间基本没太多联系。</p><p><code>this</code> 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 <code>this</code>。</p><p>执行上下文分为 3 种：</p><ul><li>全局执行上下文</li><li>函数执行上下文</li><li><code>eval</code> 执行上下文</li></ul><blockquote><p>注意这里是浏览器中的 <code>this</code>，和 Node 中的 <code>this</code> 是不一样的。</p></blockquote><h2 id="三-全局执行上下文中的-this"><a href="#三-全局执行上下文中的-this" class="headerlink" title="三 全局执行上下文中的 this"></a><a name="chapter-three" id="chapter-three"></a>三 全局执行上下文中的 this</h2><p>在 Chrome 控制台中输入：<code>this</code>，你会看到答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Window &#123;<span class="attr">postMessage</span>: ƒ, <span class="attr">blur</span>: ƒ, <span class="attr">focus</span>: ƒ, <span class="attr">close</span>: ƒ, <span class="attr">parent</span>: Window, …&#125;</span><br></pre></td></tr></table></figure><p>全局执行上下文中的 <code>this</code> 是指向 <code>Window</code> 的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>这段代码也是输出 <code>Window</code>，为什么？</p><p>记住 <code>this</code> 就是谁调用它就指向谁。</p><p>我们在全局对象中调用 <code>foo</code>，实际上就相当于 <code>window.foo()</code> 的一个调用，那么就是指向 <code>Window</code>。</p><blockquote><p>在执行上面代码之后，其实小伙伴可以在 Chrome 的控制台输入 <code>window</code>，会看到里面存在 <code>foo()</code> 方法。</p></blockquote><blockquote><p>注意这里是非严格模式。严格模式下的全局对象是 <code>undefined</code>，那就会报错误 <code>Uncaught TypeError: Cannot read property &#39;name&#39; of undefined</code></p></blockquote><h2 id="四-函数执行上下文中的-this"><a href="#四-函数执行上下文中的-this" class="headerlink" title="四 函数执行上下文中的 this"></a><a name="chapter-four" id="chapter-four"></a>四 函数执行上下文中的 this</h2><p>在上面我们知道，一般的调用方法，是调用 <code>window</code> 上的方法。</p><p>那怎么获取当前函数的 <code>this</code> 呢？</p><h3 id="4-1-通过-call-bind-apply-改变-this"><a href="#4-1-通过-call-bind-apply-改变-this" class="headerlink" title="4.1 通过 call/bind/apply 改变 this"></a><a name="chapter-four-one" id="chapter-four-one"></a>4.1 通过 call/bind/apply 改变 this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.myName = <span class="string">&#x27;jsliang&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.myName = <span class="string">&#x27;zhazhaliang&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.myName); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>这时候的 <code>this</code> 指向 <code>window</code>，所以输出结果为；</p><ul><li>zhazhaliang</li><li>undefined</li></ul><p>通过 <code>call</code> 绑定后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.myName = <span class="string">&#x27;jsliang&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.myName = <span class="string">&#x27;zhazhaliang&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo.call(foo);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.myName); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><ul><li>jsliang</li><li>zhazhaliang</li></ul><p>当然你也可以换成 <code>apply</code> 和 <code>bind</code>，这里不做累述。</p><h3 id="4-2-通过对象调用方法设置"><a href="#4-2-通过对象调用方法设置" class="headerlink" title="4.2 通过对象调用方法设置"></a><a name="chapter-four-two" id="chapter-four-two"></a>4.2 通过对象调用方法设置</h3><p>使用对象来调用其内部的一个方法，该方法的 <code>this</code> 是指向对象本身的。</p><ul><li><strong>案例 1</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis(); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>答案：输出 <code>jsliang</code>。</p><p>我们要时刻牢记：<strong>谁调用的指向谁</strong>。这里是通过 <code>myObj</code> 进行的一个调用，所以此刻的 <code>this</code> 指向 <code>myObj</code>。而 <code>myObj</code> 里面存有 <code>name: jsliang</code>，所以输出 <code>jsliang</code>。</p><p>当然，我们要有自知之明：</p><ul><li><strong>案例 2</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> foo = myObj.showThis;</span><br><span class="line">foo(); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>这时候它又变成 <code>window</code> 指向了，此刻 <code>let foo = myObj.showThis</code> 只是一个定义，真正执行是在 <code>foo()</code>。那么此刻 <code>foo()</code> 是咋搞的呢？<code>window.foo()</code> 啊！毋庸置疑输出 <code>undefined</code>。</p><ul><li><strong>案例 3</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> foo = myObj.showThis;</span><br><span class="line">foo(); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>一般来说，这段代码输出应该是 <code>undefined</code>。</p><p>但是，这里需要注意的是，<code>window.name</code> 是当前 <code>window</code> 的名称，它是 <code>window.open()</code> 打开新网页这个方法的第二个参数的值。</p><p>所以这里输出的 <code>window.name</code> 是个空值 <code>&#39;&#39;</code>，或者当前存在的 <code>window</code> 的名称。</p><p><strong>jsliang</strong> 通过一个例子带小伙伴们看看这个是怎么来的：</p><blockquote><p>index.html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>jsliang<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>打开新网页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.btn&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.open(<span class="string">&#x27;index.html&#x27;</span>, <span class="string">&#x27;jsliang 的网页&#x27;</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在新打开的网页中的控制台，输入 <code>window.name</code>，获取 <code>jsliang 的网页</code>。</p><p>结论：</p><ul><li>在全局环境中调用一个函数，函数内部的 <code>this</code> 指向的是全局变量 <code>window</code>。</li><li>通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 <code>this</code> 指向对象本身。</li></ul><h3 id="4-3-通过构造函数中设置"><a href="#4-3-通过构造函数中设置" class="headerlink" title="4.3 通过构造函数中设置"></a><a name="chapter-four-three" id="chapter-four-three"></a>4.3 通过构造函数中设置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;jsliang&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> Foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;zhazhaliang&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo.name); <span class="comment">// 输出啥？</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>答案是：</p><ul><li>zhazhaliang</li><li>jsliang</li></ul><p>在将这个答案的缘故之前，我们看下 <code>new Foo()</code> 中，JavaScript 引擎做了什么事：</p><ul><li>首先创建一个空对象 <code>tempObj = &#123;&#125;</code>。</li><li>接着调用 <code>Foo.apply</code> 方法，将 <code>tempObj</code> 作为 <code>apply</code> 方法的参数，这样当 <code>Foo</code> 的执行上下文创建时，它的 <code>this</code> 就指向 <code>tempObj</code> 对象。</li><li>然后执行 <code>Foo</code> 函数，此时的 <code>Foo</code> 函数执行上下文中的 <code>this</code> 指向了 <code>tempObj</code> 对象。</li><li>最后返回 <code>tempObj</code> 对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">func, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> tempObj = &#123;&#125;;</span><br><span class="line">  func.apply(tempObj, args);</span><br><span class="line">  <span class="keyword">return</span> tempObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;jsliang&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> Foo = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = myNew(Foo, <span class="string">&#x27;zhazhaliang&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.name); <span class="comment">// 输出啥？</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.age); <span class="comment">// 输出啥？</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>如上，我们可以看到此时 <code>this</code> 是属于 <code>tempObj</code> 的，绑定到 <code>foo</code> 上去了，从而获取到：</p><ul><li>zhazhaliang</li><li>25</li><li>jsliang</li></ul><p>当然，了解到这里，我们还是完善下 <code>new</code> 这个手写方法，免得误导小伙伴们觉得 <code>new</code> 就做了那么点事：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">func, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 判断方法体</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;第一个参数必须是方法体&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 创建新对象</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 这个对象的 __proto__ 指向 func 这个类的原型对象</span></span><br><span class="line">  <span class="comment">// 即实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性</span></span><br><span class="line">  obj.__proto__ = <span class="built_in">Object</span>.create(func.prototype);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了兼容 IE 可以让步骤 2 和 步骤 3 合并</span></span><br><span class="line">  <span class="comment">// const obj = Object.create(func.prototype);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 通过 apply 绑定 this 执行并且获取运行后的结果</span></span><br><span class="line">  <span class="keyword">let</span> result = func.apply(obj, args);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 5. 如果构造函数返回的结果是引用数据类型，则返回运行后的结果</span></span><br><span class="line">  <span class="comment">// 否则返回新创建的 obj</span></span><br><span class="line">  <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result !== <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> isFunction = <span class="keyword">typeof</span> result === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> isObject || isFunction ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 用来测试第 5 点</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;返回引用数据类型&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来测试第 2 点和第 3 点</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> me = myNew(Person, <span class="string">&#x27;jsliang&#x27;</span>); <span class="comment">// 用来测试第 4 点</span></span><br><span class="line">me.sayName(); <span class="comment">// My name is jsliang</span></span><br><span class="line"><span class="built_in">console</span>.log(me); <span class="comment">// Person &#123;name: &#x27;jsliang&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来测试第 1 点</span></span><br><span class="line"><span class="comment">// const you = myNew(&#123; name: &#x27;jsliang&#x27; &#125;, &#x27;jsliang&#x27;); // 报错：第一个参数必须是方法体</span></span><br></pre></td></tr></table></figure><p>这样，我们就知道构造函数中的 <code>new</code> 是怎么一回事了。</p><h2 id="五-this-设计缺陷和应对方案"><a href="#五-this-设计缺陷和应对方案" class="headerlink" title="五 this 设计缺陷和应对方案"></a><a name="chapter-five" id="chapter-five"></a>五 this 设计缺陷和应对方案</h2><h3 id="5-1-嵌套函数中的-this-不会从外层函数中继承"><a href="#5-1-嵌套函数中的-this-不会从外层函数中继承" class="headerlink" title="5.1 嵌套函数中的 this 不会从外层函数中继承"></a><a name="chapter-five-one" id="chapter-five-one"></a>5.1 嵌套函数中的 this 不会从外层函数中继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  myName: <span class="string">&quot;jsliang&quot;</span>, </span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis();</span><br></pre></td></tr></table></figure><p>答案是：</p><ol><li>jsliang</li><li>undefined</li></ol><p><strong>解决方法一：通过 <code>that</code> 控制 <code>this</code> 指向</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  myName: <span class="string">&quot;jsliang&quot;</span>, </span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(that.myName); <span class="comment">// 输出啥？</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis();</span><br></pre></td></tr></table></figure><p>这样都输出 <code>jsliang</code> 了。</p><p><strong>解决方法二：通过 ES6 的箭头函数解决问题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  myName: <span class="string">&quot;jsliang&quot;</span>, </span><br><span class="line">  showThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line">    <span class="keyword">const</span> bar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出啥？</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">myObj.showThis();</span><br></pre></td></tr></table></figure><p>这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 <code>this</code> 取决于它的外部函数，即谁调用它 <code>this</code> 就继承自谁。</p><h3 id="5-2-普通函数中-this-指向全局对象-window"><a href="#5-2-普通函数中-this-指向全局对象-window" class="headerlink" title="5.2 普通函数中 this 指向全局对象 window"></a><a name="chapter-five-two" id="chapter-five-two"></a>5.2 普通函数中 this 指向全局对象 window</h3><p>在实际工作中，我们并不希望函数执行上下文中的 <code>this</code> 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。</p><p>如果要让函数执行上下文中的 <code>this</code> 指向某个对象，最好的方式是通过 <code>call</code> 方法来显示调用。</p><p>这个问题可以通过设置 JavaScript 的 <strong>严格模式</strong> 来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 <code>this</code> 值是 <code>undefined</code>，这就解决上面的问题了。</p><h2 id="六-React-中-this-指向"><a href="#六-React-中-this-指向" class="headerlink" title="六 React 中 this 指向"></a><a name="chapter-six" id="chapter-six"></a>六 React 中 this 指向</h2><p>来源于：<code>this.handleClik = this.handleClick.bind(this);</code></p><p>为什么要这么操作呢？</p><p>我们先看一份代码比对：</p><blockquote><p>代码 1：对象调用字段中 this</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出 jsliang</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">test.getName();</span><br></pre></td></tr></table></figure><blockquote><p>代码 2：存放到全局变量中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出 undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> func = test.getName;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>所以，React 中对应的方法，如果没有进行绑定，那么 <code>this</code> 就会混乱指向全局对象 <code>window</code>。</p><p>那么如何修正这个问题呢？</p><blockquote><p>注：网友指出：<strong>下面这 4 种方法的比对其实是有误的，普通对象没法跟类做对比</strong></p></blockquote><blockquote><p>当然，<strong>jsliang</strong> 在这里还是想列举出来</p></blockquote><blockquote><p>具体结论，相信 <code>202X</code> 年我们再次复习的时候，有机会就去逐步解答内心疑惑。</p></blockquote><blockquote><p>所以，为了避免矛盾冲突，小伙伴们可以跳过本章</p></blockquote><h3 id="6-1-解决方案一：提前-bind-绑定-this"><a href="#6-1-解决方案一：提前-bind-绑定-this" class="headerlink" title="6.1 解决方案一：提前 bind 绑定 this"></a><a name="chapter-six-one" id="chapter-six-one"></a>6.1 解决方案一：提前 bind 绑定 this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出 jsliang</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">test.getName = test.getName.bind(test);</span><br><span class="line"><span class="keyword">const</span> func = test.getName;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>对应 React 中的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">  <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;btn <span class="number">1</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="6-2-解决方案二：调用时-bind-绑定-this"><a href="#6-2-解决方案二：调用时-bind-绑定-this" class="headerlink" title="6.2 解决方案二：调用时 bind 绑定 this"></a><a name="chapter-six-two" id="chapter-six-two"></a>6.2 解决方案二：调用时 bind 绑定 this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出 jsliang</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> func = test.getName.bind(test);</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>对应 React 中的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)&#125;&gt;btn <span class="number">2</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="6-3-解决方案三：返回一个箭头函数"><a href="#6-3-解决方案三：返回一个箭头函数" class="headerlink" title="6.3 解决方案三：返回一个箭头函数"></a><a name="chapter-six-three" id="chapter-six-three"></a>6.3 解决方案三：返回一个箭头函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName); <span class="comment">// 输出 jsliang</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> func = <span class="function">() =&gt;</span> test.getName();</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>对应 React 中的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.handleClick()&#125;&gt;btn <span class="number">3</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="6-4-解决方案四：将调用方法变成箭头函数（失败）"><a href="#6-4-解决方案四：将调用方法变成箭头函数（失败）" class="headerlink" title="6.4 解决方案四：将调用方法变成箭头函数（失败）"></a><a name="chapter-six-four" id="chapter-six-four"></a>6.4 <del>解决方案四：将调用方法变成箭头函数（失败）</del></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123;</span><br><span class="line">  myName: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  getName: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> func = test.getName;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>对应 React 中的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handleClick2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;jsliang 2021&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123;<span class="built_in">this</span>.handleClick2&#125;&gt;btn <span class="number">4</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure><p><strong>但是，这种方法失败了，返回 <code>undefined</code>，是什么缘故呢？</strong></p><p>网友指出：</p><ul><li>这 4 种方法的比对其实是有误的，普通对象没法跟类做对比</li></ul><p>当然，<strong>jsliang</strong> 还是想列举出来，具体结论，相信后面有机会会逐步解答内心疑惑。</p><h3 id="6-5-React-的-this-指向实际内容"><a href="#6-5-React-的-this-指向实际内容" class="headerlink" title="6.5 React 的 this 指向实际内容"></a><a name="chapter-six-five" id="chapter-six-five"></a>6.5 React 的 this 指向实际内容</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line">    <span class="comment">// this.handleClick = this.handleClick.bind(this);</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.isToggleOn ? <span class="string">&#x27;ON&#x27;</span> : <span class="string">&#x27;OFF&#x27;</span>&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Toggle /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>已知上面方法，编译后变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...代码省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Toggle = <span class="comment">/*#__PURE__*/</span><span class="function"><span class="keyword">function</span> (<span class="params">_React$Component</span>) </span>&#123;</span><br><span class="line">  _inherits(Toggle, _React$Component);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> _super = _createSuper(Toggle);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Toggle</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this;</span><br><span class="line"></span><br><span class="line">    _classCallCheck(<span class="built_in">this</span>, Toggle);</span><br><span class="line"></span><br><span class="line">    _this = _super.call(<span class="built_in">this</span>, props);</span><br><span class="line">    _this.state = &#123;</span><br><span class="line">      isToggleOn: <span class="literal">true</span></span><br><span class="line">    &#125;; <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line">    <span class="comment">// this.handleClick = this.handleClick.bind(this);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(Toggle, [&#123;</span><br><span class="line">    key: <span class="string">&quot;handleClick&quot;</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// 输出是 undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    key: <span class="string">&quot;render&quot;</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span>React.createElement(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">        onClick: <span class="built_in">this</span>.handleClick</span><br><span class="line">      &#125;, <span class="built_in">this</span>.state.isToggleOn ? <span class="string">&#x27;ON&#x27;</span> : <span class="string">&#x27;OFF&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Toggle;</span><br><span class="line">&#125;(React.Component);</span><br></pre></td></tr></table></figure><p>主要看 <code>_createClass</code> 方法，第一个参数是被创建的类，第二个参数是一个数组，数组里面是这个被创建类中的方法。</p><p>很显然，代码中 <code>handleClick</code> 输出的 <code>this</code>，肯定是 <code>undefined</code>。</p><p>而 <code>render</code> 方法返回的是 <code>React.createElement</code>，在这个方法中，<code>this</code> 被指向了 <code>_createClass</code> 方法的第一个参数，也就是 <code>Toggle</code> 。</p><p>这时候，如果这个方法变成箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时箭头函数是 <code>this</code> 定义时的上下文。</p><p>当我们点击按钮的时候，会调用 <code>handleClick</code> 方法来处理事件，而 <code>handleClick</code> 是在 <code>Toggle</code> 方法中定义的，所以 <code>this</code> 指代 <code>Toggle</code> 这个类。</p><h3 id="6-6-React-的-this-指向解决方案"><a href="#6-6-React-的-this-指向解决方案" class="headerlink" title="6.6 React 的 this 指向解决方案"></a><a name="chapter-six-six" id="chapter-six-six"></a>6.6 React 的 this 指向解决方案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;jsliang 2020&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;jsliang 2021&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="comment">// 四种绑定方法</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&#x27;App&#x27;</span>&gt;</span><br><span class="line">        &#123;<span class="comment">/* 方法一：通过 constructor 中进行 bind 绑定 */</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;btn <span class="number">1</span>&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/* 方法二：在里边绑定 this */</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)&#125;&gt;btn <span class="number">2</span>&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/* 方法三：通过箭头函数返回事件 */</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.handleClick()&#125;&gt;btn <span class="number">3</span>&lt;/button&gt;</span><br><span class="line">        </span><br><span class="line">        &#123;<span class="comment">/* 方法四：让方法变成箭头函数 */</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick2&#125;&gt;btn <span class="number">4</span>&lt;/button&gt;</span><br><span class="line">        </span><br><span class="line">        &#123;<span class="comment">/* 额外：直接调用不需要绑定 this */</span>&#125;</span><br><span class="line">        &#123;<span class="built_in">this</span>.handleClick()&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h2 id="七-小结"><a href="#七-小结" class="headerlink" title="七 小结"></a>七 小结</h2><p>先记住 1 句话：</p><ul><li><strong><code>this</code> 永远指向最后调用它的那个对象</strong></li></ul><p>再牢记 2 句话：</p><ul><li>普通函数中 <code>this</code> 的指向，是 <code>this</code> <strong>执行时</strong>的上下文</li><li>箭头函数中 <code>this</code> 的指向，是 <code>this</code> <strong>定义时</strong>的上下文</li></ul><h2 id="八-题目"><a href="#八-题目" class="headerlink" title="八 题目"></a>八 题目</h2><h3 id="8-1-this-题目解析-5-步曲"><a href="#8-1-this-题目解析-5-步曲" class="headerlink" title="8.1 this 题目解析 5 步曲"></a><a name="chapter-eight-one" id="chapter-eight-one"></a>8.1 this 题目解析 5 步曲</h3><ul><li>第一题</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window name&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;jsliang&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// 输出啥？</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;inner：&#x27;</span> + <span class="built_in">this</span>); <span class="comment">// 输出啥？</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;outer：&#x27;</span> + <span class="built_in">this</span>); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window name</span><br><span class="line">inner：window name</span><br><span class="line">outer：window name</span><br></pre></td></tr></table></figure><p>解析：这里的 <code>a()</code> 可以看成 <code>window.a()</code>，所以是都指向 <code>window</code> 里面的。</p><ul><li>第二题</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window name&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// 输出啥？</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();</span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：jsliang</p><p>解析：现在是 <code>a.fn()</code>，所以这个指向 <code>a</code>，因此输出 <code>jsliang</code></p><ul><li>第三题</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window name&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="comment">// name: &#x27;jsliang&#x27;,</span></span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// 输出啥？</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();</span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：undefined</p><p>解析：很明显，<code>a</code> 里面并没有 <code>name</code> 方法了，所以 <code>a.fn()</code> 找不到 <code>a</code> 对象里面有 <code>name</code>，因此输出 <code>undefined</code></p><ul><li>第四题</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window name&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// 输出啥？</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = a.fn;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：<code>window name</code></p><p>解析：代码 <code>var f = a.fn</code> 并没有调用 <code>a.fn</code>，而是做了个定义。在 <code>f()</code> 的时候才调用了，此时的 <code>fn()</code> 是 <code>window.fn()</code>，所以指向了 <code>window</code>，因此输出 <code>window name</code></p><ul><li>第五题</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window name&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;jsliang&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  innerFn();</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>答案：<code>window name</code></p><p>解析：小伙伴理解理解看看</p><h3 id="8-2-let-const-的-this"><a href="#8-2-let-const-的-this" class="headerlink" title="8.2 let/const 的 this"></a><a name="chapter-eight-two" id="chapter-eight-two"></a>8.2 let/const 的 this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.b);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：<code>undefined</code>、<code>undefined</code>、<code>undefined</code></p><p>解析：如果把 <code>var</code> 改成了 <code>let</code> 或者 <code>const</code>，变量是不会被绑定到 <code>window</code> 上的，所以此时会打印出三个 <code>undefined</code>。</p><h3 id="8-3-箭头函数的-this"><a href="#8-3-箭头函数的-this" class="headerlink" title="8.3 箭头函数的 this"></a>8.3 箭头函数的 this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window name&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.func1();</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func1(); <span class="comment">// 输出啥？</span></span><br><span class="line">a.func2(); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jsliang</span><br><span class="line">jsliang</span><br></pre></td></tr></table></figure><p>解析：箭头函数的 <code>this</code> 指向函数定义时的 <code>this</code>，而非执行时。箭头函数中没有 <code>this</code> 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 <code>this</code> 绑定的是最近一层非箭头函数的 <code>this</code>，否则，<code>this</code> 为 <code>undefined</code>。</p><h3 id="8-4-求输出结果"><a href="#8-4-求输出结果" class="headerlink" title="8.4 求输出结果"></a>8.4 求输出结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, foo &#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> foo2 = obj.foo;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo2</span>: obj.foo &#125;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// 输出啥？</span></span><br><span class="line">foo2(); <span class="comment">// 输出啥？</span></span><br><span class="line">obj2.foo2(); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li><code>obj.foo()</code>：<code>obj</code> 调用 <code>foo()</code>，所以指向 <code>obj</code>，输出 <code>1</code></li><li><code>foo2()</code>：实际上是 <code>window.foo2()</code>，指向 <code>window</code>，输出 <code>2</code></li><li><code>obj2.foo2()</code>：<code>obj2</code> 调用 <code>foo2()</code>，指向 <code>obj2</code>，输出 <code>3</code></li></ul><h3 id="8-5-隐式绑定丢失问题"><a href="#8-5-隐式绑定丢失问题" class="headerlink" title="8.5 隐式绑定丢失问题"></a><a name="chapter-eight-five" id="chapter-eight-five"></a>8.5 隐式绑定丢失问题</h3><h4 id="8-5-1-求输出结果"><a href="#8-5-1-求输出结果" class="headerlink" title="8.5.1 求输出结果"></a><a name="chapter-eight-five-one" id="chapter-eight-five-one"></a>8.5.1 求输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, foo &#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">doFoo(obj.foo); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：<code>Window &#123;...&#125;</code>、<code>2</code></p><p>解析：<strong>隐式绑定丢失问题</strong>。<code>deFoo</code> 传参 <code>obj.foo</code> 的时候，此刻 <code>foo</code> 还没被执行，所以在 <code>doFoo</code> 中 <code>fn()</code> 就相当于 <code>window.fn()</code>，所以指向到 <code>window</code> 啦！</p><blockquote><p>注意此时调用的时候，查找的 <code>fn</code> 是 <code>window</code> 上的 <code>fn</code>，而不是 <code>doFoo</code> 里的，<code>doFoo</code> 并没有设置 <code>fn</code> 这个方法。</p></blockquote><h4 id="8-5-2-求输出结果"><a href="#8-5-2-求输出结果" class="headerlink" title="8.5.2 求输出结果"></a><a name="chapter-eight-five-two" id="chapter-eight-five-two"></a>8.5.2 求输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, foo &#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">3</span>, doFoo &#125;;</span><br><span class="line"></span><br><span class="line">obj2.doFoo(obj.foo); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：<code>&#123; a: 3, doFoo: f &#125;</code>、<code>2</code></p><p>解析：</p><ol><li>此刻的 <code>fn()</code> 调用，查找到的位置还是 <code>window.foo()</code>，所以调用的时候会指向 <code>window</code>。</li><li>这里的 <code>fn()</code> 是通过传参进来的，而不是 <code>doFoo</code> 里面存在的，所以执行的时候 <code>this</code> 找到的是 <code>foo</code> 定义的位置，实际上还是 <code>window.fn()</code></li><li>如何改正这个问题？</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  fn.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, foo &#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">3</span>, doFoo &#125;;</span><br><span class="line"></span><br><span class="line">obj2.doFoo(obj.foo);</span><br></pre></td></tr></table></figure><h3 id="8-6-显示绑定问题"><a href="#8-6-显示绑定问题" class="headerlink" title="8.6 显示绑定问题"></a>8.6 显示绑定问题</h3><h4 id="8-6-1-求输出结果"><a href="#8-6-1-求输出结果" class="headerlink" title="8.6.1 求输出结果"></a>8.6.1 求输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 输出啥？</span></span><br><span class="line">foo.call(obj); <span class="comment">// 输出啥？</span></span><br><span class="line">foo().call(obj); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">Uncaught TypeError: Cannot read property &#39;call&#39; of undefined</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li><code>foo()</code>：指向 <code>window</code></li><li><code>foo.call(obj)</code>：将 <code>foo</code> 的 <code>this</code> 指向了 <code>obj</code></li><li><code>foo().call(obj)</code>：先执行 <code>foo()</code>，输出 <code>2</code>，然后它是无返回的，相当于 <code>undefined.call(obj)</code>，直接报错</li></ul><h4 id="8-6-2-求输出结果"><a href="#8-6-2-求输出结果" class="headerlink" title="8.6.2 求输出结果"></a>8.6.2 求输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 输出啥？</span></span><br><span class="line">foo.call(obj); <span class="comment">// 输出啥？</span></span><br><span class="line">foo().call(obj); <span class="comment">// 输出啥？</span></span><br></pre></td></tr></table></figure><p>上面代码输出啥？</p><hr><p>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>解析：前面 3 个不用说，和上面一题一样。</p><p>最后一个 <code>return function &#123; this.a &#125;</code>，所以变成这个方法来 <code>call(obj)</code>，因此输出 <code>obj</code> 中的 <code>a</code>，也就是 <code>1</code>。 </p><h3 id="8-7-求输出结果"><a href="#8-7-求输出结果" class="headerlink" title="8.7 求输出结果"></a>8.7 求输出结果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.location);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo();</span><br></pre></td></tr></table></figure><p>请选择：</p><ul><li>A：当前窗口的 <code>Location</code> 对象</li><li>B：<code>undefined</code></li><li>C：<code>null</code></li><li>D：<code>TypeError</code></li></ul><hr><p>答案：D</p><p>解析：如果没有 <code>use strict</code>，那么选 A；如果是严格模式，那就是 D，严格模式下禁止 <code>this</code> 关键字指向全局对象。</p><h3 id="8-8-阐述题"><a href="#8-8-阐述题" class="headerlink" title="8.8 阐述题"></a>8.8 阐述题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userInfo = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jsliang&#x27;</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">  sex: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">  updateInfo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 模拟 XMLHttpRequest 请求延时</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = <span class="string">&quot;zhazhaliang&quot;</span></span><br><span class="line">      <span class="built_in">this</span>.age = <span class="number">30</span>;</span><br><span class="line">      <span class="built_in">this</span>.sex = <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">userInfo.updateInfo();</span><br></pre></td></tr></table></figure><p>解决这里的 <code>this</code> 指向问题，求得最终结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: <span class="string">&quot;zhazhaliang&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  sex: <span class="string">&quot;female&quot;</span>,</span><br><span class="line">  updateInfo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>),</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><hr><p>答案：<code>setTimeout(() =&gt; &#123;&#125;)</code> 即可。</p><h2 id="九-参考文献"><a href="#九-参考文献" class="headerlink" title="九 参考文献"></a>九 参考文献</h2><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://juejin.im/post/6844904083707396109">再来40道this面试题酸爽继续</a>【阅读建议：1h】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://www.cnblogs.com/painsOnline/p/5102359.html">this,this,再次讨论javascript中的this,超全面</a>【阅读建议：10min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://juejin.im/post/59748cbb6fb9a06bb21ae36d">JavaScript中的this</a>【阅读建议：10min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/mqyqingfeng/Blog/issues/7">JavaScript深入之从ECMAScript规范解读this</a>【阅读建议：20min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://www.jianshu.com/p/d647aa6d1ae6">前端基础进阶（七）：全方位解读this</a>【阅读建议：20min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/axuebin/articles/issues/6">JavaScript基础心法——this</a>【阅读建议：20min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://time.geekbang.org/column/article/128427">11 | this：从JavaScript执行上下文的视角讲清楚this</a>【阅读建议：2hour】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://www.jianshu.com/p/159eabf152d0">浅谈react 中的 this 指向</a>【阅读建议：10min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://note.youdao.com/ynoteshare1/index.html?id=3d64b603405bcbb2c3cad3f750e5341d&type=note">react的性能优化</a>【阅读建议：5min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/qq_34829447/article/details/81705977">React事件处理函数必须使用bind(this)的原因</a>【阅读建议：10min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/AiHuanhuan110/article/details/106424812">由React构造函数中bind引起的this指向理解（React组件的方法为什么要用bind绑定this）</a>【阅读建议：20min】</li><li><input checked="" disabled="" type="checkbox"> <a href="https://blog.csdn.net/yiersan__/article/details/108004911">React中this.handleClick = this.handleClick.bind(this)中的this指向问题</a>【阅读建议：10min】</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;this问题&quot;&gt;&lt;a href=&quot;#this问题&quot; class=&quot;headerlink&quot; title=&quot;this问题&quot;&gt;&lt;/a&gt;this问题&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之CSS篇</title>
    <link href="http://github.com/2020/12/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BCSS%E7%AF%87/"/>
    <id>http://github.com/2020/12/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BCSS%E7%AF%87/</id>
    <published>2020-12-02T16:00:00.000Z</published>
    <updated>2020-12-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS高频面试题及参考答案</p><h2 id="CSS高频面试题"><a href="#CSS高频面试题" class="headerlink" title="CSS高频面试题"></a>CSS高频面试题</h2><h3 id="是否了解盒模型，介绍一下标准的-CSS-盒子模型与低版本的-IE-盒子模型有什么不同box-sizing常用的属性有哪些-分别有啥作用"><a href="#是否了解盒模型，介绍一下标准的-CSS-盒子模型与低版本的-IE-盒子模型有什么不同box-sizing常用的属性有哪些-分别有啥作用" class="headerlink" title="是否了解盒模型，介绍一下标准的 CSS 盒子模型与低版本的 IE 盒子模型有什么不同box-sizing常用的属性有哪些? 分别有啥作用?"></a>是否了解盒模型，介绍一下标准的 CSS 盒子模型与低版本的 IE 盒子模型有什么不同box-sizing常用的属性有哪些? 分别有啥作用?</h3><blockquote><p>盒子模型是CSS布局中的核心概念 一个box 等于 自身+内边距+边框+外边距</p></blockquote><ul><li>CSS3中有一个属性 box-sizing</li><li>border-box 指的是怪异盒模型 W3C规范的标准</li><li>content-box 指的是标准盒模型 IE盒子模型 IExplore制定的标准</li><li>在IExplore中，若HTML文档缺失声明则会触发怪异盒模型<ul><li>W3C盒子模型：可通过box-sizing: content-box来设置，他包含content+padding+border+margin。</li><li>IE盒子模型：可通过box-sizing: border-box来设置，content+margin。其中content包含width , border，padding。</li></ul></li></ul><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><blockquote><p>block formatting context，块级格式化上下文。</p></blockquote><ul><li>产生了BFC的，形成了独立容器，他的特性就是不会再布局中影响到外边的元素。<h4 id="介绍-Box-block-formatting-context"><a href="#介绍-Box-block-formatting-context" class="headerlink" title="介绍 Box, block formatting context"></a>介绍 Box, block formatting context</h4></li></ul><ol><li>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。</li><li>元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。</li><li>有哪些盒子：</li></ol><ul><li><p>block-level box:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line">- inline-level box:</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line">    display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line">4. Formatting context 　</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line">    Formatting context 是 W3C CSS2.1 规范中的一个概念。</span><br><span class="line">    它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</span><br><span class="line">    最常见的 Formatting context 有 Block fomatting context (简称BFC)和Inline formatting context (简称IFC)。</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">#### BFC布局规则：</span><br><span class="line">1. 内部的Box会在垂直方向，一个接一个地放置。</span><br><span class="line">2. BFC的区域不会与float box重叠。</span><br><span class="line">3. 内部的Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</span><br><span class="line">4. 计算BFC的高度时，浮动元素也参与计算。(清除浮动   haslayout)</span><br><span class="line">5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</span><br><span class="line"></span><br><span class="line">#### BFC什么时候出现(哪些元素会生成BFC?)</span><br><span class="line">1. 根元素</span><br><span class="line">2. float属性不为none</span><br><span class="line">3. position为absolute或fixed</span><br><span class="line">4. overflow不为visible</span><br><span class="line">5. display为inline-block, table-cell, table-caption, flex, inline-flex</span><br><span class="line"></span><br><span class="line">#### 除了BFC，还有IFC、GFC、FFC的概念</span><br><span class="line"></span><br><span class="line">- GFC：可简单理解为grid布局</span><br><span class="line">- FFC：可简单理解为flex布局。</span><br><span class="line">- IFC:内联格式化上下文，简单理解为：inline-block。</span><br><span class="line"></span><br><span class="line">水平方向上的 margin，border 和 padding在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。包含那些框的长方形区域，会形成一行，叫做行框。</span><br><span class="line">inline-block的元素的内部是一个BFC，但是它本身可以和其它inline元素一起形成IFC。</span><br><span class="line"></span><br><span class="line">#### 作用与场景</span><br><span class="line"></span><br><span class="line">- 防止margin 发生重叠（相邻元素的外边距重叠问题）</span><br><span class="line"></span><br><span class="line">我们先看一般的情况下,上下元素都有margin 的情况下，会出现重叠的情况,实际只有 50px，所谓的塌陷其实是两个BFC的相邻盒或父子盒相互作用时产生的效果，两个盒子会取相邻边最大margin作为相邻边的共用margin。</span><br></pre></td></tr></table></figure><p>.box1 {<br>margin-bottom: 50px;<br>}<br>.box2 {<br>margin-top: 50px;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 防止浮动节点被覆盖</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line">.parent &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  &#x2F;* 当父元素不写高度的时候会发生高度塌陷 *&#x2F;</span><br><span class="line">  &#x2F;* height: 100px; *&#x2F;</span><br><span class="line">  border: 1px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.float &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 50px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  background-color: #eee;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">- 清除浮动</span><br></pre></td></tr></table></figure><p>overflow: auto;<br>/* 或者 */<br>display: flow-root;<br>```</p><h3 id="请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式："><a href="#请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式：" class="headerlink" title="请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式："></a>请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式：</h3><blockquote><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p></blockquote><h4 id="浮动元素引起的问题和解决办法？"><a href="#浮动元素引起的问题和解决办法？" class="headerlink" title="浮动元素引起的问题和解决办法？"></a>浮动元素引起的问题和解决办法？</h4><p>浮动元素引起的问题：</p></li><li><p>父元素的高度无法被撑开，影响与父元素同级的元素与浮动元素同级的非浮动元素（内联元素）会跟随其后若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;content: &quot;.&quot;;display: block;height: 0;clear: both;visibility: hidden;&#125;</span><br><span class="line">.clearfix&#123;display: inline-block;&#125; &#x2F;* for IE&#x2F;Mac *&#x2F;</span><br></pre></td></tr></table></figure><h4 id="清除浮动的几种方法："><a href="#清除浮动的几种方法：" class="headerlink" title="清除浮动的几种方法："></a>清除浮动的几种方法：</h4></li><li><p>额外标签法</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;clear:both;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）</span><br></pre></td></tr></table></figure></li><li><p>使用after伪类</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#parent:after&#123;</span><br><span class="line">content:&quot;.&quot;;</span><br><span class="line">height:0;</span><br><span class="line">visibility:hidden;</span><br><span class="line">display:block;</span><br><span class="line">clear:both;</span><br><span class="line">&#125;</span><br><span class="line">注意这里是给父元素加</span><br></pre></td></tr></table></figure></li><li><p>设置overflow为hidden或者auto</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1;</span><br><span class="line">&#x2F;&#x2F; zoom:1用于兼容IE6。</span><br></pre></td></tr></table></figure></li></ul><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><ul><li>flex，即弹性布局。一个由css3引入，为我们的盒子属性带来灵活性的一种布局方式。一旦父级采用了flex布局，里边的子控件将收flex布局限制，部分原本的样式（如float:left）也会失效。</li><li>基本api: <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></li><li>特别注意：<br>flex:0 0 30%的意义：等于flex-grow=0（默认不放大）+flex-shrink=0（不缩小）+flex-basis=30%（ 项目占据主轴的空间）</li></ul><h3 id="css3新特性"><a href="#css3新特性" class="headerlink" title="css3新特性"></a>css3新特性</h3><ol><li>背景，支持RGBA透明度，一次多背景图</li><li>支持媒体查询</li><li>支持阴影，渐变，</li><li>支持边框图片，border-image: url(border.png) 30 30 round</li><li>支持transform位移系列</li><li>支持过渡效果transition</li><li>支持自定义字体</li><li>引入flex/grid布局</li><li>引入多种选择器</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS高频面试题及参考答案&lt;/p&gt;
&lt;h2 id=&quot;CSS高频面试题&quot;&gt;&lt;a href=&quot;#CSS高频面试题&quot; class=&quot;headerlink&quot; title=&quot;CSS高频面试题&quot;&gt;&lt;/a&gt;CSS高频面试题&lt;/h2&gt;&lt;h3 id=&quot;是否了解盒模型，介绍一下标准的-CSS-
      
    
    </summary>
    
    
      <category term="面试" scheme="http://github.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://github.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>vue的总结</title>
    <link href="http://github.com/2020/08/27/vue%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://github.com/2020/08/27/vue%E7%9A%84%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-27T02:32:57.000Z</published>
    <updated>2020-08-27T02:32:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><h2 id="vue基础点"><a href="#vue基础点" class="headerlink" title="vue基础点"></a>vue基础点</h2><h3 id="vue的优点"><a href="#vue的优点" class="headerlink" title="vue的优点"></a>vue的优点</h3><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，压缩后大小只有几十kb；<br>简单易学：国人开发，中文文档，易于理解和学习；<br>双向数据绑定<br>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；<br>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；<br>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；<br>运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。<br>vue做SPA应用的用户体验还是不错的，性能也比较好，开发起来也比较简单，也能实现前后端分离</p><p>vue的大量封装既是优点又是缺点，对于seo不好</p><h3 id="vue-常用指令"><a href="#vue-常用指令" class="headerlink" title="vue 常用指令"></a>vue 常用指令</h3><ul><li>v-html / v-text：把值中的标签渲染出来</li><li>v-model： 放在表单元素上的，实现双向数据绑定</li><li>v-bind（缩写 :）：用于绑定行内属性</li><li>v-if / v-show 是否能显示，true 能显示，false 不能显示</li><li>v-cloak：需要配合 css 使用：解决小胡子显示问题</li><li>v-once 对应的标签只渲染一次</li><li>v-for ：循环显示元素</li><li>v-on 事件绑定</li></ul><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>Vue.js 为 v-on 提供了事件修饰符，修饰符是由点开头的指令后缀来表示的。</p><ul><li>stop：阻止事件继续传播</li><li>prevent：阻止事件默认行为</li><li>capture：添加事件监听器时使用事件捕获模式</li><li>self：当前元素触发时才触发事件处理函数</li><li>once：事件只触发一次</li><li>passive：告诉浏览器你不想阻止事件的默认行为，不能和.prevent 一起使用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop&#x3D;&quot;toDo&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;toSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent&#x3D;&quot;toDo&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture&#x3D;&quot;toDo&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;div v-on:click.self&#x3D;&quot;toDo&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="line">&lt;a v-on:click.once&#x3D;&quot;toDo&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="line">&lt;div v-on:scroll.passive&#x3D;&quot;onScroll&quot;&gt;...&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HTML知识点</title>
    <link href="http://github.com/2020/08/14/HTML%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://github.com/2020/08/14/HTML%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-08-13T16:00:00.000Z</published>
    <updated>2020-08-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是关于html的一些常见知识点，主要是方便本人查看，在这里存个记录</p><h2 id="HTML知识点"><a href="#HTML知识点" class="headerlink" title="HTML知识点"></a>HTML知识点</h2><h3 id="HTML5在标签、属性、存储、API上的新特性"><a href="#HTML5在标签、属性、存储、API上的新特性" class="headerlink" title="HTML5在标签、属性、存储、API上的新特性"></a>HTML5在标签、属性、存储、API上的新特性</h3><ol><li>标签：新增语义化标签（aside / figure / section / header / footer / nav等），增加多媒体标签video和audio，使得样式和结构更加分离</li><li>属性：增强表单，主要是增强了input的type属性；meta增加charset以设置字符集；script增加async以异步加载脚本</li><li>存储：增加localStorage、sessionStorage和indexedDB，引入了application cache对web和应用进行缓存</li><li>API：增加拖放API、地理定位、SVG绘图、canvas绘图、Web Worker、WebSocket</li></ol><h3 id="doctype的作用"><a href="#doctype的作用" class="headerlink" title="doctype的作用"></a>doctype的作用</h3><blockquote><p>声明文档类型，告知浏览器用什么文档标准解析这个文档</p></blockquote><ul><li>怪异模式：浏览器使用自己的模式解析文档，不加doctype时默认为怪异模式</li><li>标准模式：浏览器以W3C的标准解析文档</li></ul><h3 id="语义化的意义是什么"><a href="#语义化的意义是什么" class="headerlink" title="语义化的意义是什么"></a>语义化的意义是什么</h3><ul><li>开发者容易理解</li><li>机器容易理解结构(搜索、读屏软件)</li><li>有助于SEO</li><li>semantic 、microdata</li></ul><h3 id="前端储存及区别"><a href="#前端储存及区别" class="headerlink" title="前端储存及区别"></a>前端储存及区别</h3><ul><li>cookies： HTML5之前本地储存的主要方式，大小只有4k，HTTP请求头会自动带上cookie，兼容性好</li><li>localStorage：HTML5新特性，持久性存储，即使页面关闭也不会被清除，以键值对的方式存储，大小为5M</li><li>sessionStorage：HTML5新特性，操作及大小同localStorage，和- - - localStorage的区别在于sessionStorage在选项卡(页面)被关闭时即清除，且不同选项卡之间的sessionStorage不互通</li><li>IndexedDB： NoSQL型数据库，类比MongoDB，使用键值对进行储存，异步操作数据库，支持事务，储存空间可以在250MB以上，但是IndexedDB受同源策略限制</li><li>Web SQL：是在浏览器上模拟的关系型数据库，开发者可以通过SQL语句来操作Web SQL，是HTML5以外一套独立的规范，兼容性差</li></ul><h3 id="href和src有什么区别"><a href="#href和src有什么区别" class="headerlink" title="href和src有什么区别"></a>href和src有什么区别</h3><p>href（hyperReference）即超文本引用：当浏览器遇到href时，会并行的地下载资源，不会阻塞页面解析，例如我们使用<link>引入CSS，浏览器会并行地下载CSS而不阻塞页面解析. 因此我们在引入CSS时建议使用<link>而不是@import</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href&#x3D;&quot;style.css&quot; rel&#x3D;&quot;stylesheet&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>src（resource）即资源，当浏览器遇到src时，会暂停页面解析，直到该资源下载或执行完毕，这也是script标签之所以放底部的原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h3><p>iframe会阻塞主页面的Onload事件；<br>搜索引擎的检索程序无法解读这种页面，不利于SEO;<br>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p><blockquote><p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题。</p></blockquote><h3 id="meta有哪些属性，作用是什么"><a href="#meta有哪些属性，作用是什么" class="headerlink" title="meta有哪些属性，作用是什么"></a>meta有哪些属性，作用是什么</h3><p>meta标签用于描述网页的元信息，如网站作者、描述、关键词，meta通过name=xxx和content=xxx的形式来定义信息，常用设置如下：</p><ul><li>charset：定义HTML文档的字符集<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot; &gt;</span><br></pre></td></tr></table></figure></li><li>http-equiv：可用于模拟http请求头，可设置过期时间、缓存、刷新<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＜meta http-equiv&#x3D;&quot;expires&quot; content&#x3D;&quot;Wed, 20 Jun 2019 22:33:00 GMT&quot;＞</span><br></pre></td></tr></table></figure></li><li>viewport：视口，用于控制页面宽高及缩放比例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta </span><br><span class="line">    name&#x3D;&quot;viewport&quot; </span><br><span class="line">    content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="viewport有哪些参数，作用是什么"><a href="#viewport有哪些参数，作用是什么" class="headerlink" title="viewport有哪些参数，作用是什么"></a>viewport有哪些参数，作用是什么</h3><ul><li>width/height，宽高，默认宽度980px</li><li>initial-scale，初始缩放比例，1~10</li><li>maximum-scale/minimum-scale，允许用户缩放的最大/小比例</li><li>user-scalable，用户是否可以缩放 (yes/no)</li></ul><h3 id="http-equive属性的作用和参数"><a href="#http-equive属性的作用和参数" class="headerlink" title="http-equive属性的作用和参数"></a>http-equive属性的作用和参数</h3><ul><li>expires，指定过期时间</li><li>progma，设置no-cache可以禁止缓存</li><li>refresh，定时刷新</li><li>set-cookie，可以设置cookie</li><li>X-UA-Compatible，使用浏览器版本</li><li>apple-mobile-web-app-status-bar-style，针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是关于html的一些常见知识点，主要是方便本人查看，在这里存个记录&lt;/p&gt;
&lt;h2 id=&quot;HTML知识点&quot;&gt;&lt;a href=&quot;#HTML知识点&quot; class=&quot;headerlink&quot; title=&quot;HTML知识点&quot;&gt;&lt;/a&gt;HTML知识点&lt;/h2&gt;&lt;h3 id=&quot;HTM
      
    
    </summary>
    
    
      <category term="html" scheme="http://github.com/categories/html/"/>
    
    
      <category term="html" scheme="http://github.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Markdown编写指南</title>
    <link href="http://github.com/2020/08/05/Markdown%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"/>
    <id>http://github.com/2020/08/05/Markdown%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/</id>
    <published>2020-08-05T07:56:31.000Z</published>
    <updated>2020-08-05T07:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要是怕自己记不住</p><h2 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown"></a>什么是Markdown</h2><p>Markdown是一种轻量级标记语言，通过纯文本的方式编写文档，然后再通过工具转化成HTML，PDF，图片等格式，实现Write Once，Read Everywhere的效果。下面直接开始指南</p><h2 id="Markdown基础语法"><a href="#Markdown基础语法" class="headerlink" title="Markdown基础语法"></a>Markdown基础语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*强调文本（斜体）*</span> <span class="emphasis">_强调文本（斜体）_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**加粗文本**</span> <span class="strong">__加粗文本__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*着重的强调文本（加粗和斜体）<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">==标记文本==</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">~~删除文本~~</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">&gt; 引用文本</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">下标: 把字缩放，适合用来表现公式类的</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">H~2~O is是液体。</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">2^10^ 运算结果是 1024。</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br></pre></td></tr></table></figure><p><em>强调文本（斜体）</em> <em>强调文本（斜体）</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p><strong><em>着重的强调文本（加粗和斜体）</em></strong></p><p>==标记文本==</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H<del>2</del>O is是液体。</p><p>2^10^ 运算结果是 1024。</p><h3 id="字号及颜色"><a href="#字号及颜色" class="headerlink" title="字号及颜色"></a>字号及颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;font size&#x3D;1&gt;大小为1的字体&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font size&#x3D;6&gt;大小为6的字体&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font color&#x3D;gray size&#x3D;4&gt;gray颜色的字&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;green size&#x3D;4&gt;green颜色的字&lt;&#x2F;font&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font size=1>大小为1的字体</font><br><font size=6>大小为6的字体</font></p><p><font color=gray size=4>gray颜色的字</font><br><font color=green size=5>green颜色的字</font></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><blockquote><p>Markdown中并无下划线的原生语法，可以通过HTML的u标签来实现。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;我带下划线&lt;&#x2F;u&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><u>我带下划线</u></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">无序列表</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 项目</span><br><span class="line"><span class="bullet">*</span> 项目</span><br><span class="line"><span class="bullet">+</span> 项目</span><br><span class="line"></span><br><span class="line">有序列表</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 项目1</span><br><span class="line"><span class="bullet">2.</span> 项目2</span><br><span class="line"><span class="bullet">3.</span> 项目3</span><br><span class="line"></span><br><span class="line">列表混合及嵌套</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 测试啊</span><br><span class="line"><span class="bullet">  -</span> 真的测试啊</span><br><span class="line"><span class="bullet">  -</span> 你不信啊</span><br><span class="line"><span class="bullet">    1.</span> 我是三级有序列表</span><br><span class="line"><span class="bullet">    2.</span> 呵呵哒</span><br><span class="line"><span class="bullet">  -</span> 唉</span><br><span class="line"></span><br><span class="line">可勾选列表</span><br><span class="line"><span class="bullet">-</span> [ ] 计划任务</span><br><span class="line"><span class="bullet">-</span> [x] 完成任务</span><br></pre></td></tr></table></figure><p><strong><em>无序列表</em></strong></p><ul><li>项目</li></ul><ul><li>项目</li></ul><ul><li>项目</li></ul><p><strong><em>有序列表</em></strong></p><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><p><strong><em>列表混合及嵌套</em></strong></p><ul><li>测试啊<ul><li>真的测试啊</li><li>你不信啊<ol><li>我是三级有序列表</li><li>呵呵哒</li></ol></li><li>唉</li></ul></li></ul><p><strong><em>可勾选列表</em></strong></p><ul><li><input disabled="" type="checkbox"> 计划任务</li><li><input checked="" disabled="" type="checkbox"> 完成任务</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一段引用      &#x2F;&#x2F;在&#96;&gt;&#96;后面有 1 个空格</span><br><span class="line"></span><br><span class="line">&gt; 代码块形式引用在&#96;&gt;&#96;后面有 5 个空格， </span><br><span class="line">&gt; 例子：</span><br><span class="line">&gt;</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&gt; 一级引用</span><br><span class="line">&gt; &gt; 二级引用</span><br><span class="line">&gt; &gt; &gt; 三级引用</span><br><span class="line"></span><br><span class="line">&gt; 标题加引用</span><br><span class="line">&gt; #### 标题加引用</span><br><span class="line">&gt;</span><br><span class="line">&gt; 1. 这是第一行列表项</span><br><span class="line">&gt; 2. 这是第二行列表项</span><br></pre></td></tr></table></figure><blockquote><p>普通引用在<code>&gt;</code>后面有 1 个空格</p></blockquote><blockquote><p>代码块形式引用在<code>&gt;</code>后面有 5 个空格，<br>例子：</p></blockquote><pre><code>protected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);&#125;</code></pre><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p></blockquote></blockquote></blockquote><blockquote><p>标题加引用</p><h4 id="这是一个四级标题"><a href="#这是一个四级标题" class="headerlink" title="这是一个四级标题"></a>这是一个四级标题</h4><ol><li>这是第一行列表项</li><li>这是第二行列表项</li></ol></blockquote><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">图片  ![<span class="string">图片文本(可忽略)</span>](<span class="link">图片地址</span>)</span><br><span class="line"><span class="code">      ![图片文本(可忽略)](图片地址 &quot;可选标题&quot;)</span></span><br><span class="line"><span class="code">带尺寸： &lt;img src=&quot;https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg&quot; width=10%&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">链接： [链接文本](链接地址)</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">[![百度](https://www.baidu.com/img/bd_logo1.png)](https://www.baidu.com/)</span></span><br></pre></td></tr></table></figure><blockquote><p>链接又分为行内式、参考式和 自动链接</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">这是行内式链接：[<span class="string">博客</span>](<span class="link">https://lonelyzou.github.io/</span>)。</span><br><span class="line"></span><br><span class="line">这是参考式链接：[<span class="string">博客</span>][<span class="symbol">url</span>]，其中url为链接标记，可置于文中任意位置。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">url</span>]: <span class="link">https://lonelyzou.github.io &quot;博客&quot;</span></span><br><span class="line"></span><br><span class="line">链接标记格式为：[链接标记文本]:  链接地址  链接title(可忽略)</span><br><span class="line"></span><br><span class="line">这是自动链接：直接使用<span class="code">`&lt;&gt;`</span>括起来<span class="xml"><span class="tag">&lt;<span class="name">https:</span>//<span class="attr">blog.csdn.net</span>/<span class="attr">a1056244734</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">这是图片：![][头像]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">头像</span>]: <span class="link">https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg</span></span><br><span class="line"></span><br><span class="line">带尺寸： <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg&quot;</span> <span class="attr">width</span>=<span class="string">10%</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这是行内式链接：<a href="https://lonelyzou.github.io/">博客</a>。</p><p>这是参考式链接：<a href="https://lonelyzou.github.io/" title="博客">博客</a>，其中url为链接标记，可置于文中任意位置。</p><p>链接标记格式为：[链接标记文本]:  链接地址  链接title(可忽略)</p><p>这是自动链接：直接使用<code>&lt;&gt;</code>括起来<a href="https://blog.csdn.net/a1056244734">https://blog.csdn.net/a1056244734</a></p><p>这是图片：<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg"></p><p>![logo](<a href="https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg">https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg</a> logo)</p><p>带尺寸的图片: <img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg" width=10%></p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><blockquote><p>在一行中用三个以上的*、-、_来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式: 空行 --- 或 <span class="strong">**<span class="emphasis">* 或 <span class="strong">__<span class="emphasis">_</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">空行</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">---</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">这是空行</span></span></span></span></span><br></pre></td></tr></table></figure><p>空行</p><hr><p>这是空行</p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><blockquote><p>在行尾添加两个空格加回车表示换行：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一行后面加<span class="code">`&lt;br&gt;`</span><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span>换行</span><br></pre></td></tr></table></figure><p>这是一行后面加<code>&lt;br&gt;</code><br>换行</p><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：反引号+内容+反引号</span><br><span class="line"></span><br><span class="line"><span class="code">`module.exports= ()=&gt;&#123;&#125;`</span></span><br></pre></td></tr></table></figure><p><code>module.exports= ()=&gt;&#123;&#125;</code></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><blockquote><p>行内代码</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：反引号+内容+反引号</span><br><span class="line"></span><br><span class="line"><span class="code">`module.exports= ()=&gt;&#123;&#125;`</span></span><br></pre></td></tr></table></figure><blockquote><p>多行代码</p></blockquote><ol><li>代码区块使用 4 个空格或 1 个制表符(Tab)</li><li>使用```包裹一段代码，并指定一种语言（也可以不指定）</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：<span class="code">```+内容+```</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文字高亮"><a href="#文字高亮" class="headerlink" title="文字高亮"></a>文字高亮</h3><blockquote><p>有的markdown展示不支持</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">===听说我要呗高亮了===</span><br><span class="line"></span><br><span class="line">==是啊==</span><br><span class="line"></span><br><span class="line">==亮瞎眼了==</span><br></pre></td></tr></table></figure><p>===听说我要呗高亮了===</p><p>==是啊==</p><p>==亮瞎眼了==</p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```javascript</span></span><br><span class="line"><span class="code">// 我是 js 高亮</span></span><br><span class="line"><span class="code">import vue from &#x27;vue&#x27;;</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我是 js 高亮</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个具有注脚的文本。[^1]</span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">注脚的解释</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个具有注脚的文本。<a href="%E6%B3%A8%E8%84%9A%E7%9A%84%E8%A7%A3%E9%87%8A">^1</a></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Markdown将文本转换为 HTML。</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*[HTML]: 超文本标记语言</span></span><br></pre></td></tr></table></figure><p>Markdown将文本转换为 HTML。</p><p>*[HTML]: 超文本标记语言</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><blockquote><p>默认的列左对齐,也支持设置居中和右对齐, 横杆大于等于3， 列的竖必须闭合才能代表一列！</p></blockquote><ul><li>默认对齐(左对齐) :  :—-</li><li>居中对齐 : :—:</li><li>右对齐: —:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 默认左对齐     |       居中对齐       |     右对齐 |</span><br><span class="line">| :--- | :------------------: | -------: |</span><br><span class="line">| 珂朵莉 | 珂朵莉 | 珂朵莉 |</span><br><span class="line">| 珂朵莉 | 珂朵莉 | 珂朵莉 |</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">默认左对齐</th><th align="center">居中对齐</th><th align="right">右对齐</th></tr></thead><tbody><tr><td align="left">珂朵莉</td><td align="center">珂朵莉</td><td align="right">珂朵莉</td></tr><tr><td align="left">珂朵莉</td><td align="center">珂朵莉</td><td align="right">珂朵莉</td></tr></tbody></table><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><blockquote><p>「Markdown 语言」不负责实现段首缩进，所以我们只能手写，添加空格转义符，<a href="https://blog.csdn.net/a1056244734/article/details/106410927">前端HTML空格转义符总结</a></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`Math.abs(x)`</span></span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;返回一个数的绝对值。<span class="code">`在这里插入代码片`</span></span><br></pre></td></tr></table></figure><p><code>Math.abs(x)</code></p><p>&emsp;&emsp;返回一个数的绝对值。<code>在这里插入代码片</code></p><h3 id="高级技巧-HTML元素"><a href="#高级技巧-HTML元素" class="headerlink" title="高级技巧 - HTML元素"></a>高级技巧 - HTML元素</h3><blockquote><p>支持HTML元素<br>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 &gt;HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等。<br><br>如这里看不到效果，说明此网站Markdown实现不支持插入HTML标签</p></blockquote><h3 id="高级技巧-转义"><a href="#高级技巧-转义" class="headerlink" title="高级技巧 - 转义"></a>高级技巧 - 转义</h3><blockquote><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Markdown支持对以下特殊符号的转义：</span><br><span class="line">\   反斜线</span><br><span class="line">&#96;   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure><h3 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h3><p>常见命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br><span class="line">缩写：</span><br><span class="line"></span><br><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br><span class="line">组合命令：</span><br><span class="line"></span><br><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><hr><blockquote><p>本文参考网站：</p></blockquote><ul><li><a href="https://juejin.im/post/6844904030389403655#heading-27">Markdown超详细使用说明</a></li><li><a href="https://blog.csdn.net/a1056244734/article/details/107381675">Markdown编辑器常用语法使用指南（CSDN通用）</a></li><li><a href="https://juejin.im/post/6844904018636963847#heading-25">Markdown上手指南）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要是怕自己记不住&lt;/p&gt;
&lt;h2 id=&quot;什么是Markdown&quot;&gt;&lt;a href=&quot;#什么是Markdown&quot; class=&quot;headerlink&quot; title=&quot;什么是Markdown&quot;&gt;&lt;/a&gt;什么是Markdown&lt;/h2&gt;&lt;p&gt;Markdown是一种轻量级标记语
      
    
    </summary>
    
    
      <category term="markdown" scheme="http://github.com/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://github.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>butterfly一些文章和页面配置</title>
    <link href="http://github.com/2020/08/05/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE/"/>
    <id>http://github.com/2020/08/05/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2020-08-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是butterfly的一些文章和页面配置，主要是方便本人查看，在这里存个记录</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="这个markdown文章的一些配置"><a href="#这个markdown文章的一些配置" class="headerlink" title="这个markdown文章的一些配置"></a>这个markdown文章的一些配置</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments：</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">auto<span class="emphasis">_open:</span></span><br><span class="line"><span class="emphasis">copyright:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author:</span><br><span class="line">copyright<span class="emphasis">_author_</span>href:</span><br><span class="line">copyright<span class="emphasis">_url:</span></span><br><span class="line"><span class="emphasis">copyright_</span>info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer：</span><br><span class="line">highlight<span class="emphasis">_shrink：</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">写法</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">【必需】文章标题</td></tr><tr><td align="left">date</td><td align="left">【必需】文章创建日期</td></tr><tr><td align="left">updated</td><td align="left">【可选】文章更新日期</td></tr><tr><td align="left">tags</td><td align="left">【可选】文章标籤</td></tr><tr><td align="left">categories</td><td align="left">【可选】文章分类</td></tr><tr><td align="left">keywords</td><td align="left">【可选】文章关键字</td></tr><tr><td align="left">description</td><td align="left">【可选】文章描述</td></tr><tr><td align="left">top_img</td><td align="left">【可选】文章顶部图片</td></tr><tr><td align="left">cover</td><td align="left">【可选】文章缩略图 (如果没有设置 top_img, 文章页顶部将显示缩略图，可设为 false / 图片地址 / 留空)</td></tr><tr><td align="left">comments</td><td align="left">【可选】显示文章评论模块 (默认 true)</td></tr><tr><td align="left">toc</td><td align="left">【可选】显示文章 TOC (默认为设置中 toc 的 enable 配置)</td></tr><tr><td align="left">toc_number</td><td align="left">【可选】显示 toc_number (默认为设置中 toc 的number 配置)</td></tr><tr><td align="left">auto_open</td><td align="left">【可选】是否自动打开 TOC (默认为设置中 toc 的 auto_open 配置)</td></tr><tr><td align="left">copyright</td><td align="left">【可选】显示文章版权模块 (默认为设置中 post_copyright 的 enable 配置)</td></tr><tr><td align="left">copyright_author</td><td align="left">【可选】文章版权模块的文章作者</td></tr><tr><td align="left">copyright_author_href</td><td align="left">【可选】文章版权模块的文章作者链接</td></tr><tr><td align="left">copyright_url</td><td align="left">【可选】文章版权模块的文章连结链接</td></tr><tr><td align="left">copyright_info</td><td align="left">【可选】文章版权模块的版权声明文字</td></tr><tr><td align="left">mathjax</td><td align="left">【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">katex</td><td align="left">【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">aplayer</td><td align="left">【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td></tr><tr><td align="left">highlight_shrink</td><td align="left">【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</td></tr></tbody></table><h3 id="页面的一些配置"><a href="#页面的一些配置" class="headerlink" title="页面的一些配置"></a>页面的一些配置</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer：</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink：</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">写法</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">【必需】页面标题</td></tr><tr><td align="left">date</td><td align="left">【必需】页面创建日期</td></tr><tr><td align="left">type</td><td align="left">【必需】标籤、分类和友情链接三个页面需要配置</td></tr><tr><td align="left">updated</td><td align="left">【可选】页面更新日期</td></tr><tr><td align="left">description</td><td align="left">【可选】页面描述</td></tr><tr><td align="left">keywords</td><td align="left">【可选】页面关键字</td></tr><tr><td align="left">comments</td><td align="left">【可选】显示页面评论模块 (默认 true)</td></tr><tr><td align="left">top_img</td><td align="left">【可选】页面顶部图片</td></tr><tr><td align="left">mathjax</td><td align="left">【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">katex</td><td align="left">【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">aside</td><td align="left">【可选】显示侧边栏 (默认 true)</td></tr><tr><td align="left">aplayer</td><td align="left">【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td></tr><tr><td align="left">highlight_shrink</td><td align="left">【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</td></tr></tbody></table><p><a href="https://demo.jerryc.me/posts/4aa8abbe/#Tabs">文章Markdown更多技巧</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是butterfly的一些文章和页面配置，主要是方便本人查看，在这里存个记录&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;h3 id=&quot;这个markdown文章的一些配置&quot;
      
    
    </summary>
    
    
      <category term="butterfly" scheme="http://github.com/categories/butterfly/"/>
    
    
      <category term="butterfly" scheme="http://github.com/tags/butterfly/"/>
    
  </entry>
  
</feed>
