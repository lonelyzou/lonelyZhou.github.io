<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤舟的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2021-01-14T16:00:00.000Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>孤舟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS之作用域和执行上下文篇</title>
    <link href="http://github.com/2021/01/15/JS%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AF%87/"/>
    <id>http://github.com/2021/01/15/JS%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AF%87/</id>
    <published>2021-01-14T16:00:00.000Z</published>
    <updated>2021-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h3 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>1.概念</p><ul><li><p>作用域是指程序源代码中定义变量的区域。</p><p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p></li><li><p>静态作用域与动态作用域区别</p><p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p><p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p></li></ul><ol start="2"><li>案例理解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var value &#x3D; 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value &#x3D; 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 结果是 1</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>静态作用域分析</p><p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p></li><li><p>动态作用域分析</p><p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p></li></ul><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><blockquote><p>JavaScript引擎并非一行一行地分析和执行程序，而是一段一段地分析，顺序执行。</p></blockquote><ul><li><p>概念</p><p>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p></li><li><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul></li><li><p>可执行代码</p><ul><li><p>js的可执行代码(executable code)的类型：全局代码、函数代码、eval代码。</p></li><li><p>举个例子</p><p>当javaScript引擎执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution contexts)”</p></li></ul></li><li><p>JavaScript 中有 3 种执行上下文类型：</p><ol><li>全局执行上下文：这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li>函数执行上下文：每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤。</li><li>Eval 函数执行上下文：执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。</li></ol></li></ul><h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>执行栈，也就是在其它编程语言中所说的 “调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。</p><p>当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p><p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><h4 id="模拟理解"><a href="#模拟理解" class="headerlink" title="模拟理解"></a>模拟理解</h4><p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECStack &#x3D; [];</span><br></pre></td></tr></table></figure><p>  试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    ECStack &#x3D; [</span><br><span class="line">        globalContext</span><br><span class="line">    ];</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line">JavaScript 遇到下面的这段代码了：</span><br></pre></td></tr></table></figure><p>function fun3() {<br>    console.log(‘fun3’)<br>}</p><p>function fun2() {<br>    fun3();<br>}</p><p>function fun1() {<br>    fun2();<br>}</p><p>fun1();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：</span><br></pre></td></tr></table></figure><p>// 伪代码</p><p>// fun1()<br>ECStack.push(<fun1> functionContext);</p><p>// fun1中竟然调用了fun2，还要创建fun2的执行上下文<br>ECStack.push(<fun2> functionContext);</p><p>// 擦，fun2还调用了fun3！<br>ECStack.push(<fun3> functionContext);</p><p>// fun3执行完毕<br>ECStack.pop();</p><p>// fun2执行完毕<br>ECStack.pop();</p><p>// fun1执行完毕<br>ECStack.pop();</p><p>// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">### 变量对象</span><br><span class="line">&gt; 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</span><br><span class="line"></span><br><span class="line">因为不同执行上下文下的变量对象稍有不同，所以有全局上下文下的变量对象和函数上下文下的变量对象。</span><br><span class="line"></span><br><span class="line">全局上下文中的变量对象就是全局对象</span><br><span class="line"></span><br><span class="line">#### 函数上下文</span><br><span class="line">- 概念</span><br><span class="line"></span><br><span class="line">  在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。</span><br><span class="line"></span><br><span class="line">  活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</span><br><span class="line"></span><br><span class="line">  活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</span><br><span class="line"></span><br><span class="line">- 执行过程</span><br><span class="line">  - 执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做： 1.进入执行上下文   2.代码执行</span><br><span class="line">- 进入执行上下文</span><br><span class="line"></span><br><span class="line">    当进入执行上下文时，这时候还没有执行代码，</span><br><span class="line"></span><br><span class="line">  变量对象会包括：</span><br><span class="line"></span><br><span class="line">  1. 函数的所有形参 (如果是函数上下文)</span><br><span class="line"></span><br><span class="line">      由名称和对应值组成的一个变量对象的属性被创建</span><br><span class="line">      没有实参，属性值设为 undefined</span><br><span class="line"></span><br><span class="line">  2. 函数声明</span><br><span class="line"></span><br><span class="line">      由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</span><br><span class="line">      如果变量对象已经存在相同名称的属性，则完全替换这个属性</span><br><span class="line">  3. 变量声明</span><br><span class="line"></span><br><span class="line">      由名称和对应值（undefined）组成一个变量对象的属性被创建；</span><br><span class="line">      如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</span><br><span class="line"></span><br><span class="line">举个例子：</span><br></pre></td></tr></table></figure><p>function foo(a) {<br>  var b = 2;<br>  function c() {}<br>  var d = function() {};</p><p>  b = 3;</p><p>}</p><p>foo(1);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在进入执行上下文后，这时候的 AO 是：</span><br></pre></td></tr></table></figure><p>AO = {<br>    arguments: {<br>        0: 1,<br>        length: 1<br>    },<br>    a: 1,<br>    b: undefined,<br>    c: reference to function c(){},<br>    d: undefined<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代码执行</span><br><span class="line">在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</span><br><span class="line"></span><br><span class="line">还是上面的例子，当代码执行完后，这时候的 AO 是：</span><br></pre></td></tr></table></figure><p>AO = {<br>    arguments: {<br>        0: 1,<br>        length: 1<br>    },<br>    a: 1,<br>    b: 3,<br>    c: reference to function c(){},<br>    d: reference to FunctionExpression “d”<br>}</p><pre><code>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：全局上下文的变量对象初始化是全局对象函数上下文的变量对象初始化只包括 Arguments 对象在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值在代码执行阶段，会再次修改变量对象的属性值### 作用域链#### 概念当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。&gt; 本文参考网站：* [JavaScript深入系列15篇](https://juejin.cn/post/6844903479429824526)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h3 id=&quot;词法作用域和动态作用域&quot;&gt;&lt;a href=&quot;#词法作用域和动态作用域&quot; class=&quot;headerlink&quot; title=&quot;词法作用域和动态作用域&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之闭包篇</title>
    <link href="http://github.com/2021/01/15/JS%E4%B9%8B%E9%97%AD%E5%8C%85%E7%AF%87/"/>
    <id>http://github.com/2021/01/15/JS%E4%B9%8B%E9%97%AD%E5%8C%85%E7%AF%87/</id>
    <published>2021-01-14T16:00:00.000Z</published>
    <updated>2021-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结(copy)，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h3 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h3><h4 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h4><blockquote><p>红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，</p></blockquote><blockquote><p>MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。<br>（其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）</p></blockquote><h4 id="闭包产生的原因"><a href="#闭包产生的原因" class="headerlink" title="闭包产生的原因?"></a>闭包产生的原因?</h4><ul><li>首先要明白作用域链的概念，其实很简单，在ES5中只存在两种作用域————全局作用域和函数作用域，</li><li>当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，</li><li>值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。</li></ul><p>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">function f1() &#123;</span><br><span class="line">  var a &#x3D; 2</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    var a &#x3D; 3;</span><br><span class="line">    console.log(a);&#x2F;&#x2F;3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，f1的作用域指向有全局作用域(window)和它本身，而f2的作用域指向全局作用域(window)、f1和它本身。而且作用域是从最底层向上找，直到找到全局作用域window为止，如果全局还没有的话就会报错。</p><h4 id="闭包产生的本质"><a href="#闭包产生的本质" class="headerlink" title="闭包产生的本质"></a>闭包产生的本质</h4><p>闭包产生的本质就是，当前环境中存在指向父级作用域的引用。</p><p>还是举上面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var a &#x3D; 2</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    console.log(a);&#x2F;&#x2F;2</span><br><span class="line">  &#125;</span><br><span class="line">  return f2;</span><br><span class="line">&#125;</span><br><span class="line">var x &#x3D; f1();</span><br><span class="line">x();</span><br></pre></td></tr></table></figure><p>这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。<br>那是不是只有返回函数才算是产生了闭包呢？、<br>回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f3;</span><br><span class="line">function f1() &#123;</span><br><span class="line">  var a &#x3D; 2</span><br><span class="line">  f3 &#x3D; function() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line">f3();</span><br></pre></td></tr></table></figure><p>让f1执行，给f3赋值后，等于说现在f3拥有了window、f1和f3本身这几个作用域的访问权限，还是自底向上查找，最近是在f1中找到了a,因此输出2。<br>在这里是外面的变量f3存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变。</p><h3 id="闭包有哪些表现形式"><a href="#闭包有哪些表现形式" class="headerlink" title="闭包有哪些表现形式?"></a>闭包有哪些表现形式?</h3><p>哪些地方能体现闭包的存在？</p><ul><li><p>返回一个函数。<br>刚刚已经举例。<br>作为函数参数传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">function foo()&#123;</span><br><span class="line">  var a &#x3D; 2;</span><br><span class="line">  function baz()&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(baz);</span><br><span class="line">&#125;</span><br><span class="line">function bar(fn)&#123;</span><br><span class="line">  &#x2F;&#x2F; 这就是闭包</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出2，而不是1</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></li><li><p>在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。</p><p>以下的闭包保存的仅仅是window和当前作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定时器</span><br><span class="line">setTimeout(function timeHandler()&#123;</span><br><span class="line">  console.log(&#39;111&#39;);</span><br><span class="line">&#125;，100)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 事件监听</span><br><span class="line">$(&#39;#app&#39;).click(function()&#123;</span><br><span class="line">  console.log(&#39;DOM Listener&#39;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2;</span><br><span class="line">(function IIFE()&#123;</span><br><span class="line">  &#x2F;&#x2F; 输出2</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ul><p>如何解决下面的循环输出问题？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 1; i &lt;&#x3D; 5; i ++)&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>为什么会全部输出6？如何改进，让它输出1，2，3，4，5？(方法越多越好)</p><p>因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。</p></li><li><p>解决方法：</p><p>1、利用IIFE(立即执行函数表达式)当每次for循环时，把此时的i变量传递到定时器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i &#x3D; 1;i &lt;&#x3D; 5;i++)&#123;</span><br><span class="line">  (function(j)&#123;</span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line">      console.log(j)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、给定时器传入第三个参数, 作为timer函数的第一个函数参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i&#x3D;1;i&lt;&#x3D;5;i++)&#123;</span><br><span class="line">  setTimeout(function timer(j)&#123;</span><br><span class="line">    console.log(j)</span><br><span class="line">  &#125;, 0, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用ES6中的let</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i &#x3D; 1; i &lt;&#x3D; 5; i++)&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let使JS发生革命性的变化，让JS有函数作用域变为了块级作用域，用let后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; i &#x3D; 1</span><br><span class="line">&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; i &#x3D; 2</span><br><span class="line">&#123;</span><br><span class="line">  setTimeout(function timer()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">  &#125;,0)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; i &#x3D; 3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因此能输出正确的结果。</p></li></ul><blockquote><p>本文参考(copy)网站：</p></blockquote><ul><li><a href="https://juejin.cn/post/6844903974378668039">J原生JS灵魂之问</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结(copy)，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h3 id=&quot;闭包的理解&quot;&gt;&lt;a href=&quot;#闭包的理解&quot; class=&quot;headerlink&quot; title=&quot;闭包的理解&quot;&gt;&lt;/a&gt;闭包的理解&lt;/h3
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>JS之类型篇</title>
    <link href="http://github.com/2021/01/15/JS%E4%B9%8B%E7%B1%BB%E5%9E%8B%E7%AF%87/"/>
    <id>http://github.com/2021/01/15/JS%E4%B9%8B%E7%B1%BB%E5%9E%8B%E7%AF%87/</id>
    <published>2021-01-14T16:00:00.000Z</published>
    <updated>2021-01-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="JS数据类型基础概念"><a href="#JS数据类型基础概念" class="headerlink" title="JS数据类型基础概念"></a>JS数据类型基础概念</h2><h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><p>JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：</p><h3 id="JS原始数据类型和引用数据类型"><a href="#JS原始数据类型和引用数据类型" class="headerlink" title="JS原始数据类型和引用数据类型"></a>JS原始数据类型和引用数据类型</h3><ol><li>7种JS原始数据类型</li></ol><ul><li>boolean</li><li>null</li><li>undefined</li><li>number</li><li>string</li><li>symbol</li><li>bigint</li></ul><ol start="2"><li>引用数据类型:</li></ol><ul><li>对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）</li></ul><h4 id="说出下面运行的结果，解释原因。"><a href="#说出下面运行的结果，解释原因。" class="headerlink" title="说出下面运行的结果，解释原因。"></a>说出下面运行的结果，解释原因。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function test(person) &#123;</span><br><span class="line">  person.age &#x3D; 26</span><br><span class="line">  person &#x3D; &#123;</span><br><span class="line">    name: &#39;hzj&#39;,</span><br><span class="line">    age: 18</span><br><span class="line">  &#125;</span><br><span class="line">  return person</span><br><span class="line">&#125;</span><br><span class="line">const p1 &#x3D; &#123;</span><br><span class="line">  name: &#39;fyq&#39;,</span><br><span class="line">  age: 19</span><br><span class="line">&#125;</span><br><span class="line">const p2 &#x3D; test(p1)</span><br><span class="line">console.log(p1) &#x2F;&#x2F; -&gt; ?</span><br><span class="line">console.log(p2) &#x2F;&#x2F; -&gt; ?</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结果:</span><br><span class="line">p1：&#123;name: “fyq”, age: 26&#125;</span><br><span class="line">p2：&#123;name: “hzj”, age: 18&#125;</span><br></pre></td></tr></table></figure><p>原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用person.age = 26确实改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。</p><h4 id="typeof-null-输出-object问题？"><a href="#typeof-null-输出-object问题？" class="headerlink" title="typeof null 输出 object问题？"></a>typeof null 输出 object问题？</h4><p>结论: 。<br>解释: 首先null不是对象，typeof null 会输出 object，这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。</p><h4 id="‘1’-toString-为什么可以调用？"><a href="#‘1’-toString-为什么可以调用？" class="headerlink" title="‘1’.toString()为什么可以调用？"></a>‘1’.toString()为什么可以调用？</h4><p>其实在这个语句运行的过程中做了这样几件事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; new Object(&#39;1&#39;);</span><br><span class="line">s.toString();</span><br><span class="line">s &#x3D; null;</span><br></pre></td></tr></table></figure><ol><li>第一步: 创建Object类实例。注意为什么不是String ？ 由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。</li><li>第二步: 调用实例方法。</li><li>第三步: 执行完方法立即销毁这个实例。<br>整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean, Number和String。</li></ol><blockquote><p>参考:《JavaScript高级程序设计(第三版)》P118</p></blockquote><h4 id="0-1-0-2为什么不等于0-3？"><a href="#0-1-0-2为什么不等于0-3？" class="headerlink" title="0.1+0.2为什么不等于0.3？"></a>0.1+0.2为什么不等于0.3？</h4><p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p><h3 id="如何理解BigInt"><a href="#如何理解BigInt" class="headerlink" title="如何理解BigInt?"></a>如何理解BigInt?</h3><h4 id="什么是BigInt"><a href="#什么是BigInt" class="headerlink" title="什么是BigInt?"></a>什么是BigInt?</h4><p>BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。</p><h4 id="为什么需要BigInt"><a href="#为什么需要BigInt" class="headerlink" title="为什么需要BigInt?"></a>为什么需要BigInt?</h4><p>在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？</p><p>这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(999999999999999);</span><br><span class="line">&#x2F;&#x2F; 输出10000000000000000</span><br></pre></td></tr></table></figure><p>同时也会有一定的安全性问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9007199254740992 &#x3D;&#x3D;&#x3D; 9007199254740993;    &#x2F;&#x2F; → true 居然是true!</span><br></pre></td></tr></table></figure><h4 id="如何创建并使用BigInt？"><a href="#如何创建并使用BigInt？" class="headerlink" title="如何创建并使用BigInt？"></a>如何创建并使用BigInt？</h4><p>要创建BigInt，只需要在数字末尾追加n即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log( 9007199254740995n );    &#x2F;&#x2F; → 9007199254740995n    </span><br><span class="line">console.log( 9007199254740995 );     &#x2F;&#x2F; → 9007199254740996</span><br></pre></td></tr></table></figure><p>另一种创建BigInt的方法是用BigInt()构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInt(&quot;9007199254740995&quot;);    &#x2F;&#x2F; → 9007199254740995n</span><br></pre></td></tr></table></figure><p>简单使用如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">10n + 20n;    &#x2F;&#x2F; → 30n    </span><br><span class="line">10n - 20n;    &#x2F;&#x2F; → -10n    </span><br><span class="line">+10n;         &#x2F;&#x2F; → TypeError: Cannot convert a BigInt value to a number    </span><br><span class="line">-10n;         &#x2F;&#x2F; → -10n    </span><br><span class="line">10n * 20n;    &#x2F;&#x2F; → 200n    </span><br><span class="line">20n &#x2F; 10n;    &#x2F;&#x2F; → 2n    </span><br><span class="line">23n % 10n;    &#x2F;&#x2F; → 3n    </span><br><span class="line">10n ** 3n;    &#x2F;&#x2F; → 1000n    </span><br><span class="line"></span><br><span class="line">const x &#x3D; 10n;    </span><br><span class="line">++x;          &#x2F;&#x2F; → 11n    </span><br><span class="line">--x;          &#x2F;&#x2F; → 9n</span><br><span class="line">console.log(typeof x);   &#x2F;&#x2F;&quot;bigint&quot;</span><br></pre></td></tr></table></figure><p>值得警惕的点</p><ul><li>BigInt不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js代码。</li></ul><ul><li><p>因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 + 10n;    &#x2F;&#x2F; → TypeError</span><br></pre></td></tr></table></figure></li><li><p>不能将BigInt传递给Web api和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(2n, 4n, 6n);    &#x2F;&#x2F; → TypeError</span><br></pre></td></tr></table></figure></li><li><p>当 Boolean 类型与 BigInt 类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(0n)&#123;&#x2F;&#x2F;条件判断为false</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if(3n)&#123;&#x2F;&#x2F;条件为true</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>元素都为BigInt的数组可以进行sort。</p></li></ul><p>  BigInt可以正常地进行位运算，如|、&amp;、&lt;&lt;、&gt;&gt;和^</p><p>浏览器兼容性</p><ul><li>其实现在的兼容性并不怎么好，只有chrome67、firefox、Opera这些主流实现</li></ul><h3 id="JS数据类型检测"><a href="#JS数据类型检测" class="headerlink" title="JS数据类型检测"></a>JS数据类型检测</h3><ol><li><p>typeof 是否能正确判断类型？<br>对于原始类型来说，除了 null 都可以调用typeof显示正确的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 &#x2F;&#x2F; &#39;number&#39;</span><br><span class="line">typeof &#39;1&#39; &#x2F;&#x2F; &#39;string&#39;</span><br><span class="line">typeof undefined &#x2F;&#x2F; &#39;undefined&#39;</span><br><span class="line">typeof true &#x2F;&#x2F; &#39;boolean&#39;</span><br><span class="line">typeof Symbol() &#x2F;&#x2F; &#39;symbol&#39;</span><br></pre></td></tr></table></figure><p>但对于引用数据类型，除了函数之外，都会显示”object”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof [] &#x2F;&#x2F; &#39;object&#39;</span><br><span class="line">typeof &#123;&#125; &#x2F;&#x2F; &#39;object&#39;</span><br><span class="line">typeof console.log &#x2F;&#x2F; &#39;function&#39;</span><br></pre></td></tr></table></figure><p>因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const Person &#x3D; function() &#123;&#125;</span><br><span class="line">const p1 &#x3D; new Person()</span><br><span class="line">p1 instanceof Person &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">var str1 &#x3D; &#39;hello world&#39;</span><br><span class="line">str1 instanceof String &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">var str2 &#x3D; new String(&#39;hello world&#39;)</span><br><span class="line">str2 instanceof String &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li><li><p>instanceof能否判断基本数据类型？<br>能。比如下面这种方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class PrimitiveNumber &#123;</span><br><span class="line">  static [Symbol.hasInstance](x) &#123;</span><br><span class="line">    return typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(111 instanceof PrimitiveNumber) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>如果你不知道Symbol，可以看看MDN上关于hasInstance的解释。<br>其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。</p></li><li><p>能不能手动实现一下instanceof的功能？<br>核心: 原型链的向上查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">    &#x2F;&#x2F;基本数据类型直接返回false</span><br><span class="line">    if(typeof left !&#x3D;&#x3D; &#39;object&#39; || left &#x3D;&#x3D;&#x3D; null) return false;</span><br><span class="line">    &#x2F;&#x2F;getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象</span><br><span class="line">    let proto &#x3D; Object.getPrototypeOf(left);</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        &#x2F;&#x2F;查找到尽头，还没找到</span><br><span class="line">        if(proto &#x3D;&#x3D; null) return false;</span><br><span class="line">        &#x2F;&#x2F;找到相同的原型对象</span><br><span class="line">        if(proto &#x3D;&#x3D; right.prototype) return true;</span><br><span class="line">        proto &#x3D; Object.getPrototypeOf(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(myInstanceof(&quot;111&quot;, String)); &#x2F;&#x2F;false</span><br><span class="line">console.log(myInstanceof(new String(&quot;111&quot;), String));&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure></li><li><p>Object.is和===的区别？<br>Object在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。<br>源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function is(x, y) &#123;</span><br><span class="line">  if (x &#x3D;&#x3D;&#x3D; y) &#123;</span><br><span class="line">    &#x2F;&#x2F;运行到1&#x2F;x &#x3D;&#x3D;&#x3D; 1&#x2F;y的时候x和y都为0，但是1&#x2F;+0 &#x3D; +Infinity， 1&#x2F;-0 &#x3D; -Infinity, 是不一样的</span><br><span class="line">    return x !&#x3D;&#x3D; 0 || y !&#x3D;&#x3D; 0 || 1 &#x2F; x &#x3D;&#x3D;&#x3D; 1 &#x2F; y;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F;NaN&#x3D;&#x3D;&#x3D;NaN是false,这是不对的，我们在这里做一个拦截，x !&#x3D;&#x3D; x，那么一定是 NaN, y 同理</span><br><span class="line">    &#x2F;&#x2F;两个都是NaN的时候返回true</span><br><span class="line">    return x !&#x3D;&#x3D; x &amp;&amp; y !&#x3D;&#x3D; y;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="JS数据类型转换"><a href="#JS数据类型转换" class="headerlink" title="JS数据类型转换"></a>JS数据类型转换</h3></li><li><p>[] == ![]结果是什么？为什么？<br>解析:<br>== 中，左右两边都需要转换为数字然后进行比较。<br>[]转换为数字为0。<br>![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true,<br>因此![]为false，进而在转换成数字，变为0。<br>0 == 0 ， 结果为true</p></li><li><p>JS中类型转换有哪几种？<br>JS中，类型转换只有三种：</p></li></ol><p>转换成数字<br>转换成布尔值<br>转换成字符串</p><p>转换具体规则如下:</p><p>注意”Boolean 转字符串”这行结果指的是 true 转字符串的例子</p><ol start="3"><li>== 和 ===有什么区别？<br>===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如’1’===1的结果是false，因为一边是string，另一边是number。<br>复制代码<br>==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下：</li></ol><p>两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false<br>判断的是否是null和undefined，是的话就返回true<br>判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较<br>判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较<br>如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#123;a: 1&#125; &#x3D;&#x3D; true);&#x2F;&#x2F;false</span><br><span class="line">console.log(&#123;a: 1&#125; &#x3D;&#x3D; &quot;[object Object]&quot;);&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><ol start="4"><li>对象转原始类型是根据什么流程运行的？<br>对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</li></ol><p>如果Symbol.toPrimitive()方法，优先调用再返回<br>调用valueOf()，如果转换为原始类型，则返回<br>调用toString()，如果转换为原始类型，则返回<br>如果都没有返回原始类型，会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  value: 3,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return 4;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;5&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line">    return 6</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj + 1); &#x2F;&#x2F; 输出7</span><br></pre></td></tr></table></figure><ol start="5"><li>如何让if(a == 1 &amp;&amp; a == 2)条件成立？<br>13 使 a == 1 &amp;&amp; a == 2 成立</li></ol><ul><li><p>方法一</p><p>在类型转换的时候，我们知道了对象如何转换成原始数据类型。如果部署了 [Symbol.toPrimitive]，那么返回的就是 Symbol.toPrimitive 的返回值。</p><p>当然，我们也可以把此函数部署在 valueOf 或者是 toString 接口上，效果相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;利用闭包延长作用域的特性</span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">  [Symbol.toPrimitive]: (function () &#123;</span><br><span class="line">    let i &#x3D; 1;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      return i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二</p><p>利用 Object.defineProperty 在 window/global 上定义 a 属性，获取 a 属性时，会调用 get</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let val &#x3D; 1;</span><br><span class="line">Object.defineProperty(window, &#39;a&#39;, &#123;</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    return val++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>方法三</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3];</span><br><span class="line">a.join &#x3D; a.shift;</span><br></pre></td></tr></table></figure><p>数组的 toString 方法返回一个字符串，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</p><p>因此，我们可以重新 join 方法。返回第一个元素，并将其删除。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;JS数据类型基础概念&quot;&gt;&lt;a href=&quot;#JS数据类型基础概念&quot; class=&quot;headerlink&quot; title=&quot;JS数据类型基础概念&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之CSS篇</title>
    <link href="http://github.com/2020/12/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BCSS%E7%AF%87/"/>
    <id>http://github.com/2020/12/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8BCSS%E7%AF%87/</id>
    <published>2020-12-02T16:00:00.000Z</published>
    <updated>2020-12-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS高频面试题及参考答案</p><h2 id="CSS高频面试题"><a href="#CSS高频面试题" class="headerlink" title="CSS高频面试题"></a>CSS高频面试题</h2><h3 id="是否了解盒模型，介绍一下标准的-CSS-盒子模型与低版本的-IE-盒子模型有什么不同box-sizing常用的属性有哪些-分别有啥作用"><a href="#是否了解盒模型，介绍一下标准的-CSS-盒子模型与低版本的-IE-盒子模型有什么不同box-sizing常用的属性有哪些-分别有啥作用" class="headerlink" title="是否了解盒模型，介绍一下标准的 CSS 盒子模型与低版本的 IE 盒子模型有什么不同box-sizing常用的属性有哪些? 分别有啥作用?"></a>是否了解盒模型，介绍一下标准的 CSS 盒子模型与低版本的 IE 盒子模型有什么不同box-sizing常用的属性有哪些? 分别有啥作用?</h3><blockquote><p>盒子模型是CSS布局中的核心概念 一个box 等于 自身+内边距+边框+外边距</p></blockquote><ul><li>CSS3中有一个属性 box-sizing</li><li>border-box 指的是怪异盒模型 W3C规范的标准</li><li>content-box 指的是标准盒模型 IE盒子模型 IExplore制定的标准</li><li>在IExplore中，若HTML文档缺失声明则会触发怪异盒模型<ul><li>W3C盒子模型：可通过box-sizing: content-box来设置，他包含content+padding+border+margin。</li><li>IE盒子模型：可通过box-sizing: border-box来设置，content+margin。其中content包含width , border，padding。</li></ul></li></ul><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><blockquote><p>block formatting context，块级格式化上下文。</p></blockquote><ul><li>产生了BFC的，形成了独立容器，他的特性就是不会再布局中影响到外边的元素。<h4 id="介绍-Box-block-formatting-context"><a href="#介绍-Box-block-formatting-context" class="headerlink" title="介绍 Box, block formatting context"></a>介绍 Box, block formatting context</h4></li></ul><ol><li>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。</li><li>元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。</li><li>有哪些盒子：</li></ol><ul><li><p>block-level box:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line">- inline-level box:</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line">    display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line">4. Formatting context 　</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line">    Formatting context 是 W3C CSS2.1 规范中的一个概念。</span><br><span class="line">    它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</span><br><span class="line">    最常见的 Formatting context 有 Block fomatting context (简称BFC)和Inline formatting context (简称IFC)。</span><br><span class="line">    &#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">#### BFC布局规则：</span><br><span class="line">1. 内部的Box会在垂直方向，一个接一个地放置。</span><br><span class="line">2. BFC的区域不会与float box重叠。</span><br><span class="line">3. 内部的Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</span><br><span class="line">4. 计算BFC的高度时，浮动元素也参与计算。(清除浮动   haslayout)</span><br><span class="line">5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</span><br><span class="line"></span><br><span class="line">#### BFC什么时候出现(哪些元素会生成BFC?)</span><br><span class="line">1. 根元素</span><br><span class="line">2. float属性不为none</span><br><span class="line">3. position为absolute或fixed</span><br><span class="line">4. overflow不为visible</span><br><span class="line">5. display为inline-block, table-cell, table-caption, flex, inline-flex</span><br><span class="line"></span><br><span class="line">#### 除了BFC，还有IFC、GFC、FFC的概念</span><br><span class="line"></span><br><span class="line">- GFC：可简单理解为grid布局</span><br><span class="line">- FFC：可简单理解为flex布局。</span><br><span class="line">- IFC:内联格式化上下文，简单理解为：inline-block。</span><br><span class="line"></span><br><span class="line">水平方向上的 margin，border 和 padding在框之间得到保留。框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。包含那些框的长方形区域，会形成一行，叫做行框。</span><br><span class="line">inline-block的元素的内部是一个BFC，但是它本身可以和其它inline元素一起形成IFC。</span><br><span class="line"></span><br><span class="line">#### 作用与场景</span><br><span class="line"></span><br><span class="line">- 防止margin 发生重叠（相邻元素的外边距重叠问题）</span><br><span class="line"></span><br><span class="line">我们先看一般的情况下,上下元素都有margin 的情况下，会出现重叠的情况,实际只有 50px，所谓的塌陷其实是两个BFC的相邻盒或父子盒相互作用时产生的效果，两个盒子会取相邻边最大margin作为相邻边的共用margin。</span><br></pre></td></tr></table></figure><p>.box1 {<br>margin-bottom: 50px;<br>}<br>.box2 {<br>margin-top: 50px;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 防止浮动节点被覆盖</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line">.parent &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  &#x2F;* 当父元素不写高度的时候会发生高度塌陷 *&#x2F;</span><br><span class="line">  &#x2F;* height: 100px; *&#x2F;</span><br><span class="line">  border: 1px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.float &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 50px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  background-color: #eee;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">- 清除浮动</span><br></pre></td></tr></table></figure><p>overflow: auto;<br>/* 或者 */<br>display: flow-root;<br>```</p><h3 id="请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式："><a href="#请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式：" class="headerlink" title="请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式："></a>请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式：</h3><blockquote><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p></blockquote><h4 id="浮动元素引起的问题和解决办法？"><a href="#浮动元素引起的问题和解决办法？" class="headerlink" title="浮动元素引起的问题和解决办法？"></a>浮动元素引起的问题和解决办法？</h4><p>浮动元素引起的问题：</p></li><li><p>父元素的高度无法被撑开，影响与父元素同级的元素与浮动元素同级的非浮动元素（内联元素）会跟随其后若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;content: &quot;.&quot;;display: block;height: 0;clear: both;visibility: hidden;&#125;</span><br><span class="line">.clearfix&#123;display: inline-block;&#125; &#x2F;* for IE&#x2F;Mac *&#x2F;</span><br></pre></td></tr></table></figure><h4 id="清除浮动的几种方法："><a href="#清除浮动的几种方法：" class="headerlink" title="清除浮动的几种方法："></a>清除浮动的几种方法：</h4></li><li><p>额外标签法</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;clear:both;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）</span><br></pre></td></tr></table></figure></li><li><p>使用after伪类</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#parent:after&#123;</span><br><span class="line">content:&quot;.&quot;;</span><br><span class="line">height:0;</span><br><span class="line">visibility:hidden;</span><br><span class="line">display:block;</span><br><span class="line">clear:both;</span><br><span class="line">&#125;</span><br><span class="line">注意这里是给父元素加</span><br></pre></td></tr></table></figure></li><li><p>设置overflow为hidden或者auto</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1;</span><br><span class="line">&#x2F;&#x2F; zoom:1用于兼容IE6。</span><br></pre></td></tr></table></figure></li></ul><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><ul><li>flex，即弹性布局。一个由css3引入，为我们的盒子属性带来灵活性的一种布局方式。一旦父级采用了flex布局，里边的子控件将收flex布局限制，部分原本的样式（如float:left）也会失效。</li><li>基本api: <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></li><li>特别注意：<br>flex:0 0 30%的意义：等于flex-grow=0（默认不放大）+flex-shrink=0（不缩小）+flex-basis=30%（ 项目占据主轴的空间）</li></ul><h3 id="css3新特性"><a href="#css3新特性" class="headerlink" title="css3新特性"></a>css3新特性</h3><ol><li>背景，支持RGBA透明度，一次多背景图</li><li>支持媒体查询</li><li>支持阴影，渐变，</li><li>支持边框图片，border-image: url(border.png) 30 30 round</li><li>支持transform位移系列</li><li>支持过渡效果transition</li><li>支持自定义字体</li><li>引入flex/grid布局</li><li>引入多种选择器</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS高频面试题及参考答案&lt;/p&gt;
&lt;h2 id=&quot;CSS高频面试题&quot;&gt;&lt;a href=&quot;#CSS高频面试题&quot; class=&quot;headerlink&quot; title=&quot;CSS高频面试题&quot;&gt;&lt;/a&gt;CSS高频面试题&lt;/h2&gt;&lt;h3 id=&quot;是否了解盒模型，介绍一下标准的-CSS-
      
    
    </summary>
    
    
      <category term="面试" scheme="http://github.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://github.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>vue的总结</title>
    <link href="http://github.com/2020/08/27/vue%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://github.com/2020/08/27/vue%E7%9A%84%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-27T02:32:57.000Z</published>
    <updated>2020-08-27T02:32:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><h2 id="vue基础点"><a href="#vue基础点" class="headerlink" title="vue基础点"></a>vue基础点</h2><h3 id="vue的优点"><a href="#vue的优点" class="headerlink" title="vue的优点"></a>vue的优点</h3><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，压缩后大小只有几十kb；<br>简单易学：国人开发，中文文档，易于理解和学习；<br>双向数据绑定<br>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；<br>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；<br>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；<br>运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。<br>vue做SPA应用的用户体验还是不错的，性能也比较好，开发起来也比较简单，也能实现前后端分离</p><p>vue的大量封装既是优点又是缺点，对于seo不好</p><h3 id="vue-常用指令"><a href="#vue-常用指令" class="headerlink" title="vue 常用指令"></a>vue 常用指令</h3><ul><li>v-html / v-text：把值中的标签渲染出来</li><li>v-model： 放在表单元素上的，实现双向数据绑定</li><li>v-bind（缩写 :）：用于绑定行内属性</li><li>v-if / v-show 是否能显示，true 能显示，false 不能显示</li><li>v-cloak：需要配合 css 使用：解决小胡子显示问题</li><li>v-once 对应的标签只渲染一次</li><li>v-for ：循环显示元素</li><li>v-on 事件绑定</li></ul><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>Vue.js 为 v-on 提供了事件修饰符，修饰符是由点开头的指令后缀来表示的。</p><ul><li>stop：阻止事件继续传播</li><li>prevent：阻止事件默认行为</li><li>capture：添加事件监听器时使用事件捕获模式</li><li>self：当前元素触发时才触发事件处理函数</li><li>once：事件只触发一次</li><li>passive：告诉浏览器你不想阻止事件的默认行为，不能和.prevent 一起使用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop&#x3D;&quot;toDo&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;toSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent&#x3D;&quot;toDo&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture&#x3D;&quot;toDo&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;div v-on:click.self&#x3D;&quot;toDo&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="line">&lt;a v-on:click.once&#x3D;&quot;toDo&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="line">&lt;div v-on:scroll.passive&#x3D;&quot;onScroll&quot;&gt;...&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HTML知识点</title>
    <link href="http://github.com/2020/08/14/HTML%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://github.com/2020/08/14/HTML%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-08-13T16:00:00.000Z</published>
    <updated>2020-08-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是关于html的一些常见知识点，主要是方便本人查看，在这里存个记录</p><h2 id="HTML知识点"><a href="#HTML知识点" class="headerlink" title="HTML知识点"></a>HTML知识点</h2><h3 id="HTML5在标签、属性、存储、API上的新特性"><a href="#HTML5在标签、属性、存储、API上的新特性" class="headerlink" title="HTML5在标签、属性、存储、API上的新特性"></a>HTML5在标签、属性、存储、API上的新特性</h3><ol><li>标签：新增语义化标签（aside / figure / section / header / footer / nav等），增加多媒体标签video和audio，使得样式和结构更加分离</li><li>属性：增强表单，主要是增强了input的type属性；meta增加charset以设置字符集；script增加async以异步加载脚本</li><li>存储：增加localStorage、sessionStorage和indexedDB，引入了application cache对web和应用进行缓存</li><li>API：增加拖放API、地理定位、SVG绘图、canvas绘图、Web Worker、WebSocket</li></ol><h3 id="doctype的作用"><a href="#doctype的作用" class="headerlink" title="doctype的作用"></a>doctype的作用</h3><blockquote><p>声明文档类型，告知浏览器用什么文档标准解析这个文档</p></blockquote><ul><li>怪异模式：浏览器使用自己的模式解析文档，不加doctype时默认为怪异模式</li><li>标准模式：浏览器以W3C的标准解析文档</li></ul><h3 id="语义化的意义是什么"><a href="#语义化的意义是什么" class="headerlink" title="语义化的意义是什么"></a>语义化的意义是什么</h3><ul><li>开发者容易理解</li><li>机器容易理解结构(搜索、读屏软件)</li><li>有助于SEO</li><li>semantic 、microdata</li></ul><h3 id="前端储存及区别"><a href="#前端储存及区别" class="headerlink" title="前端储存及区别"></a>前端储存及区别</h3><ul><li>cookies： HTML5之前本地储存的主要方式，大小只有4k，HTTP请求头会自动带上cookie，兼容性好</li><li>localStorage：HTML5新特性，持久性存储，即使页面关闭也不会被清除，以键值对的方式存储，大小为5M</li><li>sessionStorage：HTML5新特性，操作及大小同localStorage，和- - - localStorage的区别在于sessionStorage在选项卡(页面)被关闭时即清除，且不同选项卡之间的sessionStorage不互通</li><li>IndexedDB： NoSQL型数据库，类比MongoDB，使用键值对进行储存，异步操作数据库，支持事务，储存空间可以在250MB以上，但是IndexedDB受同源策略限制</li><li>Web SQL：是在浏览器上模拟的关系型数据库，开发者可以通过SQL语句来操作Web SQL，是HTML5以外一套独立的规范，兼容性差</li></ul><h3 id="href和src有什么区别"><a href="#href和src有什么区别" class="headerlink" title="href和src有什么区别"></a>href和src有什么区别</h3><p>href（hyperReference）即超文本引用：当浏览器遇到href时，会并行的地下载资源，不会阻塞页面解析，例如我们使用<link>引入CSS，浏览器会并行地下载CSS而不阻塞页面解析. 因此我们在引入CSS时建议使用<link>而不是@import</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href&#x3D;&quot;style.css&quot; rel&#x3D;&quot;stylesheet&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>src（resource）即资源，当浏览器遇到src时，会暂停页面解析，直到该资源下载或执行完毕，这也是script标签之所以放底部的原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h3><p>iframe会阻塞主页面的Onload事件；<br>搜索引擎的检索程序无法解读这种页面，不利于SEO;<br>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p><blockquote><p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题。</p></blockquote><h3 id="meta有哪些属性，作用是什么"><a href="#meta有哪些属性，作用是什么" class="headerlink" title="meta有哪些属性，作用是什么"></a>meta有哪些属性，作用是什么</h3><p>meta标签用于描述网页的元信息，如网站作者、描述、关键词，meta通过name=xxx和content=xxx的形式来定义信息，常用设置如下：</p><ul><li>charset：定义HTML文档的字符集<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot; &gt;</span><br></pre></td></tr></table></figure></li><li>http-equiv：可用于模拟http请求头，可设置过期时间、缓存、刷新<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＜meta http-equiv&#x3D;&quot;expires&quot; content&#x3D;&quot;Wed, 20 Jun 2019 22:33:00 GMT&quot;＞</span><br></pre></td></tr></table></figure></li><li>viewport：视口，用于控制页面宽高及缩放比例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta </span><br><span class="line">    name&#x3D;&quot;viewport&quot; </span><br><span class="line">    content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="viewport有哪些参数，作用是什么"><a href="#viewport有哪些参数，作用是什么" class="headerlink" title="viewport有哪些参数，作用是什么"></a>viewport有哪些参数，作用是什么</h3><ul><li>width/height，宽高，默认宽度980px</li><li>initial-scale，初始缩放比例，1~10</li><li>maximum-scale/minimum-scale，允许用户缩放的最大/小比例</li><li>user-scalable，用户是否可以缩放 (yes/no)</li></ul><h3 id="http-equive属性的作用和参数"><a href="#http-equive属性的作用和参数" class="headerlink" title="http-equive属性的作用和参数"></a>http-equive属性的作用和参数</h3><ul><li>expires，指定过期时间</li><li>progma，设置no-cache可以禁止缓存</li><li>refresh，定时刷新</li><li>set-cookie，可以设置cookie</li><li>X-UA-Compatible，使用浏览器版本</li><li>apple-mobile-web-app-status-bar-style，针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是关于html的一些常见知识点，主要是方便本人查看，在这里存个记录&lt;/p&gt;
&lt;h2 id=&quot;HTML知识点&quot;&gt;&lt;a href=&quot;#HTML知识点&quot; class=&quot;headerlink&quot; title=&quot;HTML知识点&quot;&gt;&lt;/a&gt;HTML知识点&lt;/h2&gt;&lt;h3 id=&quot;HTM
      
    
    </summary>
    
    
      <category term="html" scheme="http://github.com/categories/html/"/>
    
    
      <category term="html" scheme="http://github.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Markdown编写指南</title>
    <link href="http://github.com/2020/08/05/Markdown%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/"/>
    <id>http://github.com/2020/08/05/Markdown%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/</id>
    <published>2020-08-05T07:56:31.000Z</published>
    <updated>2020-08-05T07:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要是怕自己记不住</p><h2 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown"></a>什么是Markdown</h2><p>Markdown是一种轻量级标记语言，通过纯文本的方式编写文档，然后再通过工具转化成HTML，PDF，图片等格式，实现Write Once，Read Everywhere的效果。下面直接开始指南</p><h2 id="Markdown基础语法"><a href="#Markdown基础语法" class="headerlink" title="Markdown基础语法"></a>Markdown基础语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*强调文本（斜体）*</span> <span class="emphasis">_强调文本（斜体）_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**加粗文本**</span> <span class="strong">__加粗文本__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*着重的强调文本（加粗和斜体）<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">==标记文本==</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">~~删除文本~~</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">&gt; 引用文本</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">下标: 把字缩放，适合用来表现公式类的</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">H~2~O is是液体。</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">2^10^ 运算结果是 1024。</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br></pre></td></tr></table></figure><p><em>强调文本（斜体）</em> <em>强调文本（斜体）</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p><strong><em>着重的强调文本（加粗和斜体）</em></strong></p><p>==标记文本==</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H<del>2</del>O is是液体。</p><p>2^10^ 运算结果是 1024。</p><h3 id="字号及颜色"><a href="#字号及颜色" class="headerlink" title="字号及颜色"></a>字号及颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;font size&#x3D;1&gt;大小为1的字体&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font size&#x3D;6&gt;大小为6的字体&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font color&#x3D;gray size&#x3D;4&gt;gray颜色的字&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;green size&#x3D;4&gt;green颜色的字&lt;&#x2F;font&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font size=1>大小为1的字体</font><br><font size=6>大小为6的字体</font></p><p><font color=gray size=4>gray颜色的字</font><br><font color=green size=5>green颜色的字</font></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><blockquote><p>Markdown中并无下划线的原生语法，可以通过HTML的u标签来实现。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;我带下划线&lt;&#x2F;u&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><u>我带下划线</u></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">无序列表</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 项目</span><br><span class="line"><span class="bullet">*</span> 项目</span><br><span class="line"><span class="bullet">+</span> 项目</span><br><span class="line"></span><br><span class="line">有序列表</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 项目1</span><br><span class="line"><span class="bullet">2.</span> 项目2</span><br><span class="line"><span class="bullet">3.</span> 项目3</span><br><span class="line"></span><br><span class="line">列表混合及嵌套</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 测试啊</span><br><span class="line"><span class="bullet">  -</span> 真的测试啊</span><br><span class="line"><span class="bullet">  -</span> 你不信啊</span><br><span class="line"><span class="bullet">    1.</span> 我是三级有序列表</span><br><span class="line"><span class="bullet">    2.</span> 呵呵哒</span><br><span class="line"><span class="bullet">  -</span> 唉</span><br><span class="line"></span><br><span class="line">可勾选列表</span><br><span class="line"><span class="bullet">-</span> [ ] 计划任务</span><br><span class="line"><span class="bullet">-</span> [x] 完成任务</span><br></pre></td></tr></table></figure><p><strong><em>无序列表</em></strong></p><ul><li>项目</li></ul><ul><li>项目</li></ul><ul><li>项目</li></ul><p><strong><em>有序列表</em></strong></p><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><p><strong><em>列表混合及嵌套</em></strong></p><ul><li>测试啊<ul><li>真的测试啊</li><li>你不信啊<ol><li>我是三级有序列表</li><li>呵呵哒</li></ol></li><li>唉</li></ul></li></ul><p><strong><em>可勾选列表</em></strong></p><ul><li><input disabled="" type="checkbox"> 计划任务</li><li><input checked="" disabled="" type="checkbox"> 完成任务</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一段引用      &#x2F;&#x2F;在&#96;&gt;&#96;后面有 1 个空格</span><br><span class="line"></span><br><span class="line">&gt; 代码块形式引用在&#96;&gt;&#96;后面有 5 个空格， </span><br><span class="line">&gt; 例子：</span><br><span class="line">&gt;</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&gt; 一级引用</span><br><span class="line">&gt; &gt; 二级引用</span><br><span class="line">&gt; &gt; &gt; 三级引用</span><br><span class="line"></span><br><span class="line">&gt; 标题加引用</span><br><span class="line">&gt; #### 标题加引用</span><br><span class="line">&gt;</span><br><span class="line">&gt; 1. 这是第一行列表项</span><br><span class="line">&gt; 2. 这是第二行列表项</span><br></pre></td></tr></table></figure><blockquote><p>普通引用在<code>&gt;</code>后面有 1 个空格</p></blockquote><blockquote><p>代码块形式引用在<code>&gt;</code>后面有 5 个空格，<br>例子：</p></blockquote><pre><code>protected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);&#125;</code></pre><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p></blockquote></blockquote></blockquote><blockquote><p>标题加引用</p><h4 id="这是一个四级标题"><a href="#这是一个四级标题" class="headerlink" title="这是一个四级标题"></a>这是一个四级标题</h4><ol><li>这是第一行列表项</li><li>这是第二行列表项</li></ol></blockquote><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">图片  ![<span class="string">图片文本(可忽略)</span>](<span class="link">图片地址</span>)</span><br><span class="line"><span class="code">      ![图片文本(可忽略)](图片地址 &quot;可选标题&quot;)</span></span><br><span class="line"><span class="code">带尺寸： &lt;img src=&quot;https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg&quot; width=10%&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">链接： [链接文本](链接地址)</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">[![百度](https://www.baidu.com/img/bd_logo1.png)](https://www.baidu.com/)</span></span><br></pre></td></tr></table></figure><blockquote><p>链接又分为行内式、参考式和 自动链接</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">这是行内式链接：[<span class="string">博客</span>](<span class="link">https://lonelyzou.github.io/</span>)。</span><br><span class="line"></span><br><span class="line">这是参考式链接：[<span class="string">博客</span>][<span class="symbol">url</span>]，其中url为链接标记，可置于文中任意位置。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">url</span>]: <span class="link">https://lonelyzou.github.io &quot;博客&quot;</span></span><br><span class="line"></span><br><span class="line">链接标记格式为：[链接标记文本]:  链接地址  链接title(可忽略)</span><br><span class="line"></span><br><span class="line">这是自动链接：直接使用<span class="code">`&lt;&gt;`</span>括起来<span class="xml"><span class="tag">&lt;<span class="name">https:</span>//<span class="attr">blog.csdn.net</span>/<span class="attr">a1056244734</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">这是图片：![][头像]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">头像</span>]: <span class="link">https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg</span></span><br><span class="line"></span><br><span class="line">带尺寸： <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg&quot;</span> <span class="attr">width</span>=<span class="string">10%</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这是行内式链接：<a href="https://lonelyzou.github.io/">博客</a>。</p><p>这是参考式链接：<a href="https://lonelyzou.github.io/" title="博客">博客</a>，其中url为链接标记，可置于文中任意位置。</p><p>链接标记格式为：[链接标记文本]:  链接地址  链接title(可忽略)</p><p>这是自动链接：直接使用<code>&lt;&gt;</code>括起来<a href="https://blog.csdn.net/a1056244734">https://blog.csdn.net/a1056244734</a></p><p>这是图片：<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg"></p><p>![logo](<a href="https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg">https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg</a> logo)</p><p>带尺寸的图片: <img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/08/04/XDQ523jViTtFp1k.jpg" width=10%></p><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><blockquote><p>在一行中用三个以上的*、-、_来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式: 空行 --- 或 <span class="strong">**<span class="emphasis">* 或 <span class="strong">__<span class="emphasis">_</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">空行</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">---</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">这是空行</span></span></span></span></span><br></pre></td></tr></table></figure><p>空行</p><hr><p>这是空行</p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><blockquote><p>在行尾添加两个空格加回车表示换行：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一行后面加<span class="code">`&lt;br&gt;`</span><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span>换行</span><br></pre></td></tr></table></figure><p>这是一行后面加<code>&lt;br&gt;</code><br>换行</p><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：反引号+内容+反引号</span><br><span class="line"></span><br><span class="line"><span class="code">`module.exports= ()=&gt;&#123;&#125;`</span></span><br></pre></td></tr></table></figure><p><code>module.exports= ()=&gt;&#123;&#125;</code></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><blockquote><p>行内代码</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：反引号+内容+反引号</span><br><span class="line"></span><br><span class="line"><span class="code">`module.exports= ()=&gt;&#123;&#125;`</span></span><br></pre></td></tr></table></figure><blockquote><p>多行代码</p></blockquote><ol><li>代码区块使用 4 个空格或 1 个制表符(Tab)</li><li>使用```包裹一段代码，并指定一种语言（也可以不指定）</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：<span class="code">```+内容+```</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文字高亮"><a href="#文字高亮" class="headerlink" title="文字高亮"></a>文字高亮</h3><blockquote><p>有的markdown展示不支持</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">===听说我要呗高亮了===</span><br><span class="line"></span><br><span class="line">==是啊==</span><br><span class="line"></span><br><span class="line">==亮瞎眼了==</span><br></pre></td></tr></table></figure><p>===听说我要呗高亮了===</p><p>==是啊==</p><p>==亮瞎眼了==</p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```javascript</span></span><br><span class="line"><span class="code">// 我是 js 高亮</span></span><br><span class="line"><span class="code">import vue from &#x27;vue&#x27;;</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我是 js 高亮</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个具有注脚的文本。[^1]</span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">注脚的解释</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个具有注脚的文本。<a href="%E6%B3%A8%E8%84%9A%E7%9A%84%E8%A7%A3%E9%87%8A">^1</a></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Markdown将文本转换为 HTML。</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*[HTML]: 超文本标记语言</span></span><br></pre></td></tr></table></figure><p>Markdown将文本转换为 HTML。</p><p>*[HTML]: 超文本标记语言</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><blockquote><p>默认的列左对齐,也支持设置居中和右对齐, 横杆大于等于3， 列的竖必须闭合才能代表一列！</p></blockquote><ul><li>默认对齐(左对齐) :  :—-</li><li>居中对齐 : :—:</li><li>右对齐: —:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 默认左对齐     |       居中对齐       |     右对齐 |</span><br><span class="line">| :--- | :------------------: | -------: |</span><br><span class="line">| 珂朵莉 | 珂朵莉 | 珂朵莉 |</span><br><span class="line">| 珂朵莉 | 珂朵莉 | 珂朵莉 |</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">默认左对齐</th><th align="center">居中对齐</th><th align="right">右对齐</th></tr></thead><tbody><tr><td align="left">珂朵莉</td><td align="center">珂朵莉</td><td align="right">珂朵莉</td></tr><tr><td align="left">珂朵莉</td><td align="center">珂朵莉</td><td align="right">珂朵莉</td></tr></tbody></table><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><blockquote><p>「Markdown 语言」不负责实现段首缩进，所以我们只能手写，添加空格转义符，<a href="https://blog.csdn.net/a1056244734/article/details/106410927">前端HTML空格转义符总结</a></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`Math.abs(x)`</span></span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;返回一个数的绝对值。<span class="code">`在这里插入代码片`</span></span><br></pre></td></tr></table></figure><p><code>Math.abs(x)</code></p><p>&emsp;&emsp;返回一个数的绝对值。<code>在这里插入代码片</code></p><h3 id="高级技巧-HTML元素"><a href="#高级技巧-HTML元素" class="headerlink" title="高级技巧 - HTML元素"></a>高级技巧 - HTML元素</h3><blockquote><p>支持HTML元素<br>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 &gt;HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等。<br><br>如这里看不到效果，说明此网站Markdown实现不支持插入HTML标签</p></blockquote><h3 id="高级技巧-转义"><a href="#高级技巧-转义" class="headerlink" title="高级技巧 - 转义"></a>高级技巧 - 转义</h3><blockquote><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Markdown支持对以下特殊符号的转义：</span><br><span class="line">\   反斜线</span><br><span class="line">&#96;   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure><h3 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h3><p>常见命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br><span class="line">缩写：</span><br><span class="line"></span><br><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br><span class="line">组合命令：</span><br><span class="line"></span><br><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><hr><blockquote><p>本文参考网站：</p></blockquote><ul><li><a href="https://juejin.im/post/6844904030389403655#heading-27">Markdown超详细使用说明</a></li><li><a href="https://blog.csdn.net/a1056244734/article/details/107381675">Markdown编辑器常用语法使用指南（CSDN通用）</a></li><li><a href="https://juejin.im/post/6844904018636963847#heading-25">Markdown上手指南）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要是怕自己记不住&lt;/p&gt;
&lt;h2 id=&quot;什么是Markdown&quot;&gt;&lt;a href=&quot;#什么是Markdown&quot; class=&quot;headerlink&quot; title=&quot;什么是Markdown&quot;&gt;&lt;/a&gt;什么是Markdown&lt;/h2&gt;&lt;p&gt;Markdown是一种轻量级标记语
      
    
    </summary>
    
    
      <category term="markdown" scheme="http://github.com/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://github.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>butterfly一些文章和页面配置</title>
    <link href="http://github.com/2020/08/05/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE/"/>
    <id>http://github.com/2020/08/05/%E6%96%87%E7%AB%A0%E9%85%8D%E7%BD%AE/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2020-08-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是butterfly的一些文章和页面配置，主要是方便本人查看，在这里存个记录</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="这个markdown文章的一些配置"><a href="#这个markdown文章的一些配置" class="headerlink" title="这个markdown文章的一些配置"></a>这个markdown文章的一些配置</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments：</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">auto<span class="emphasis">_open:</span></span><br><span class="line"><span class="emphasis">copyright:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author:</span><br><span class="line">copyright<span class="emphasis">_author_</span>href:</span><br><span class="line">copyright<span class="emphasis">_url:</span></span><br><span class="line"><span class="emphasis">copyright_</span>info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer：</span><br><span class="line">highlight<span class="emphasis">_shrink：</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">写法</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">【必需】文章标题</td></tr><tr><td align="left">date</td><td align="left">【必需】文章创建日期</td></tr><tr><td align="left">updated</td><td align="left">【可选】文章更新日期</td></tr><tr><td align="left">tags</td><td align="left">【可选】文章标籤</td></tr><tr><td align="left">categories</td><td align="left">【可选】文章分类</td></tr><tr><td align="left">keywords</td><td align="left">【可选】文章关键字</td></tr><tr><td align="left">description</td><td align="left">【可选】文章描述</td></tr><tr><td align="left">top_img</td><td align="left">【可选】文章顶部图片</td></tr><tr><td align="left">cover</td><td align="left">【可选】文章缩略图 (如果没有设置 top_img, 文章页顶部将显示缩略图，可设为 false / 图片地址 / 留空)</td></tr><tr><td align="left">comments</td><td align="left">【可选】显示文章评论模块 (默认 true)</td></tr><tr><td align="left">toc</td><td align="left">【可选】显示文章 TOC (默认为设置中 toc 的 enable 配置)</td></tr><tr><td align="left">toc_number</td><td align="left">【可选】显示 toc_number (默认为设置中 toc 的number 配置)</td></tr><tr><td align="left">auto_open</td><td align="left">【可选】是否自动打开 TOC (默认为设置中 toc 的 auto_open 配置)</td></tr><tr><td align="left">copyright</td><td align="left">【可选】显示文章版权模块 (默认为设置中 post_copyright 的 enable 配置)</td></tr><tr><td align="left">copyright_author</td><td align="left">【可选】文章版权模块的文章作者</td></tr><tr><td align="left">copyright_author_href</td><td align="left">【可选】文章版权模块的文章作者链接</td></tr><tr><td align="left">copyright_url</td><td align="left">【可选】文章版权模块的文章连结链接</td></tr><tr><td align="left">copyright_info</td><td align="left">【可选】文章版权模块的版权声明文字</td></tr><tr><td align="left">mathjax</td><td align="left">【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">katex</td><td align="left">【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">aplayer</td><td align="left">【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td></tr><tr><td align="left">highlight_shrink</td><td align="left">【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</td></tr></tbody></table><h3 id="页面的一些配置"><a href="#页面的一些配置" class="headerlink" title="页面的一些配置"></a>页面的一些配置</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer：</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink：</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">写法</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">【必需】页面标题</td></tr><tr><td align="left">date</td><td align="left">【必需】页面创建日期</td></tr><tr><td align="left">type</td><td align="left">【必需】标籤、分类和友情链接三个页面需要配置</td></tr><tr><td align="left">updated</td><td align="left">【可选】页面更新日期</td></tr><tr><td align="left">description</td><td align="left">【可选】页面描述</td></tr><tr><td align="left">keywords</td><td align="left">【可选】页面关键字</td></tr><tr><td align="left">comments</td><td align="left">【可选】显示页面评论模块 (默认 true)</td></tr><tr><td align="left">top_img</td><td align="left">【可选】页面顶部图片</td></tr><tr><td align="left">mathjax</td><td align="left">【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">katex</td><td align="left">【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td align="left">aside</td><td align="left">【可选】显示侧边栏 (默认 true)</td></tr><tr><td align="left">aplayer</td><td align="left">【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td></tr><tr><td align="left">highlight_shrink</td><td align="left">【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</td></tr></tbody></table><p><a href="https://demo.jerryc.me/posts/4aa8abbe/#Tabs">文章Markdown更多技巧</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是butterfly的一些文章和页面配置，主要是方便本人查看，在这里存个记录&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;h3 id=&quot;这个markdown文章的一些配置&quot;
      
    
    </summary>
    
    
      <category term="butterfly" scheme="http://github.com/categories/butterfly/"/>
    
    
      <category term="butterfly" scheme="http://github.com/tags/butterfly/"/>
    
  </entry>
  
</feed>
