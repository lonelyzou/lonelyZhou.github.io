<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>覆水行舟的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2021-03-21T16:00:00.000Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>覆水行舟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试宝典之小程序</title>
    <link href="http://github.com/2021/03/22/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://github.com/2021/03/22/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F/</id>
    <published>2021-03-21T16:00:00.000Z</published>
    <updated>2021-03-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对小程序的面试题做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="1-简单描述下微信小程序的相关文件类型"><a href="#1-简单描述下微信小程序的相关文件类型" class="headerlink" title="1. 简单描述下微信小程序的相关文件类型"></a>1. 简单描述下微信小程序的相关文件类型</h2><p>微信小程序项目结构主要有四个文件类型</p><ol><li>WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件</li><li>WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式</li><li>js 逻辑处理，网络请求</li><li>json 小程序设置，如页面注册，页面标题及tabBar</li></ol><p>主要文件</p><ol><li>app.json 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的 window 背景色，配置导航条样式，配置默认标题</li><li>app.js 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量</li><li>app.wxss 可选</li></ol><h2 id="、你使用过哪些方法，来提高微信小程序的应用速度？"><a href="#、你使用过哪些方法，来提高微信小程序的应用速度？" class="headerlink" title="、你使用过哪些方法，来提高微信小程序的应用速度？"></a>、你使用过哪些方法，来提高微信小程序的应用速度？</h2><ul><li>提高页面加载速度</li><li>用户行为预测</li><li>减少默认data的大小</li><li>组件化方案</li></ul><h2 id="简述微信小程序原理"><a href="#简述微信小程序原理" class="headerlink" title="简述微信小程序原理"></a>简述微信小程序原理</h2><p>微信小程序采用 JavaScript、WXML、WXSS 三种技术进行开发,本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口微信的架构，是数据驱动的架构模式，它的 UI 和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现<br>小程序分为两个部分 webview 和 appService 。其中 webview 主要用来展现 UI ，appService 有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层 JSBridge 实现通信，实现 UI 的渲染、事件的处理</p><h2 id="分析下微信小程序的优劣势？"><a href="#分析下微信小程序的优劣势？" class="headerlink" title="分析下微信小程序的优劣势？"></a>分析下微信小程序的优劣势？</h2><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ol><li>无需下载，通过搜索和扫一扫就可以打开。</li><li>良好的用户体验：打开速度快。</li><li>开发成本要比App要低。</li><li>安卓上可以添加到桌面，与原生App差不多。</li><li>为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程， 不能通过审查的小程序是无法发布到线上的。<h3 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h3></li><li>限制较多。页面大小不能超过1M。不能打开超过5个层级的页面。</li><li>样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航。</li><li>推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。</li><li>依托于微信，无法开发后台管理功能。</li></ol><h2 id="小程序与原生App哪个好？"><a href="#小程序与原生App哪个好？" class="headerlink" title="小程序与原生App哪个好？"></a>小程序与原生App哪个好？</h2><p>小程序除了拥有公众号的低开发成本、低获客成本低以及无需下载等优势，在服务请求延时与用户使用体验是都得到了较大幅度 的提升，使得其能够承载跟复杂的服务功能以及使用户获得更好的用户体验。</p><h2 id="微信小程序与H5的区别？"><a href="#微信小程序与H5的区别？" class="headerlink" title="微信小程序与H5的区别？"></a>微信小程序与H5的区别？</h2><p>运行环境不同（小程序在微信运行，h5在浏览器运行）；<br>开发成本不同（h5需要兼容不同的浏览器）；<br>获取系统权限不同（系统级权限可以和小程序无缝衔接）；<br>应用在生产环境的运行流畅度（h5需不断对项目优化来提高用户体验）；</p><h2 id="小程序的双向绑定和vue的区别"><a href="#小程序的双向绑定和vue的区别" class="headerlink" title="小程序的双向绑定和vue的区别"></a>小程序的双向绑定和vue的区别</h2><p>小程序直接 this.data 的属性是不可以同步到视图的，必须调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setData(&#123;</span><br><span class="line">    <span class="comment">// 这里设置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="小程序和Vue写法的区别？"><a href="#小程序和Vue写法的区别？" class="headerlink" title="小程序和Vue写法的区别？"></a>小程序和Vue写法的区别？</h2><ol><li><p>遍历的时候：</p><ul><li>小程序 <code>wx:for = &quot;lists&quot;</code><br></li><li>Vue是 v-for = “item in lists”<br></li></ul></li><li><p>调用data模型（赋值）的时候：</p><ul><li>小程序：<code>this.data.item</code> //调用 <code>this.setData(&#123;item:1&#125;)</code> //赋值</li><li>vue: <code>this.item</code> //调用 <code>this.item =1</code> //赋值</li></ul></li></ol><h2 id="请谈谈原生开发小程序、wepy、mpvue-的对比？"><a href="#请谈谈原生开发小程序、wepy、mpvue-的对比？" class="headerlink" title="请谈谈原生开发小程序、wepy、mpvue 的对比？"></a>请谈谈原生开发小程序、wepy、mpvue 的对比？</h2><p>个人认为，如果是新项目，且没有旧的 h5 项目迁移，则考虑用小程序原生开发，好处是相比于第三方框架，坑少。<br>而如果有 老的 h5 项目是 vue 开发 或者 也有 h5 项目也需要小程序开发，则比较适合 wepy 或者 mpvue 来做迁移或者开发，近期看wepy几乎不更新了，所以推荐美团的mpvue。<br>而如果如果团队前端强大，自己做一套框架也没问题。</p><h2 id="请谈谈WXSS和CSS的异同？"><a href="#请谈谈WXSS和CSS的异同？" class="headerlink" title="请谈谈WXSS和CSS的异同？"></a>请谈谈WXSS和CSS的异同？</h2><p>相同：<br>都是用来描述页面的样子；<br><br>不同：</p><ol><li>WXSS 具有 CSS 大部分的特性，也做了一些扩充和修改；</li><li>WXSS新增了尺寸单位，WXSS 在底层支持新的尺寸单位 rpx；</li><li>WXSS 仅支持部分 CSS 选择器；</li><li>WXSS 提供全局样式与局部样式</li></ol><blockquote><p>rpx 是响应式像素,可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素</p></blockquote><h2 id="如何实现下拉刷新"><a href="#如何实现下拉刷新" class="headerlink" title="如何实现下拉刷新"></a>如何实现下拉刷新</h2><p>首先在全局 config 中的 window 配置 enablePullDownRefresh<br>在 Page 中定义 onPullDownRefresh 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法<br>请求返回后，调用 wx.stopPullDownRefresh 停止下拉刷新</p><h2 id="bindtap和catchtap的区别是什么"><a href="#bindtap和catchtap的区别是什么" class="headerlink" title="bindtap和catchtap的区别是什么"></a>bindtap和catchtap的区别是什么</h2><p>相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分</p><p>不同点：bindtap是不会阻止冒泡事件的，catchtap是阻值冒泡的</p><h2 id="简述下-wx-navigateTo-wx-redirectTo-wx-switchTab-wx-navigateBack-wx-reLaunch-的区别"><a href="#简述下-wx-navigateTo-wx-redirectTo-wx-switchTab-wx-navigateBack-wx-reLaunch-的区别" class="headerlink" title="简述下 wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别"></a>简述下 wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别</h2><ul><li>wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面</li><li>wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面</li><li>wx.switchTab()：跳转到 abBar 页面，并关闭其他所有非 tabBar 页面</li><li>wx.navigateBack()关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层</li><li>wx.reLaunch()：关闭所有页面，打开到应用内的某个页面</li></ul><h2 id="有哪些参数传值的方法？"><a href="#有哪些参数传值的方法？" class="headerlink" title="有哪些参数传值的方法？"></a>有哪些参数传值的方法？</h2><p>一、给HTML元素添加data-*属性来传递我们需要的值，然后通过e.currentTarget.dataset或onload的param参数获取。但data-名称不能有大写字母和不可以存放对象</p><p>二、设置id 的方法标识来传值通过e.currentTarget.id获取设置的id的值,然后通过设置全局对象的方式来传递数值</p><p>三、在navigator中添加参数传值</p><h2 id="小程序页面间有哪些传递数据的方法"><a href="#小程序页面间有哪些传递数据的方法" class="headerlink" title="小程序页面间有哪些传递数据的方法"></a>小程序页面间有哪些传递数据的方法</h2><ol><li><p>使用全局变量实现数据传递<br>在 app.js 文件中定义全局变量 globalData， 将需要存储的信息存放在里面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"></span><br><span class="line">App(&#123;</span><br><span class="line">     <span class="comment">// 全局变量</span></span><br><span class="line">  globalData: &#123;</span><br><span class="line">    userInfo: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用的时候，直接使用 getApp() 拿到存储的信息</p></li><li><p>使用 wx.navigateTo 与 wx.redirectTo 的时候，可以将部分数据放在 url 里面，并在新页面 onLoad 的时候初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pageA.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Navigate</span></span><br><span class="line">wx.navigateTo(&#123;</span><br><span class="line">  url: <span class="string">&#x27;../pageD/pageD?name=raymond&amp;gender=male&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redirect</span></span><br><span class="line">wx.redirectTo(&#123;</span><br><span class="line">  url: <span class="string">&#x27;../pageD/pageD?name=raymond&amp;gender=male&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// pageB.js</span></span><br><span class="line">...</span><br><span class="line">Page(&#123;</span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(option.name + <span class="string">&#x27;is&#x27;</span> + option.gender)</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      option: option</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的问题：</p></li></ol><p>wx.navigateTo 和 wx.redirectTo 不允许跳转到 tab 所包含的页面</p><p>onLoad 只执行一次</p><ol start="3"><li>使用本地缓存 Storage 相关<h2 id="小程序生命周期"><a href="#小程序生命周期" class="headerlink" title="小程序生命周期"></a>小程序生命周期</h2>先小程序的生命周期函数是在app.js里面调用的，App(Object)函数用来注册一个小程序。接受一个 Object 参数，指定其小程序的生命周期回调；一般有onLaunch监听小程序初始化、onShow监听小程序显示、onHide监听小程序隐藏等生命周期回调函数。</li></ol><ul><li>onLaunch() 监听小程序初始化</li><li>onShow() 监听小程序显示</li><li>onHide() 监听小程序隐藏</li><li>onError() 错误监听函数</li><li>onPageNotFound() 页面不存在监听函数</li></ul><h2 id="请谈谈小程序页面的生命周期函数？"><a href="#请谈谈小程序页面的生命周期函数？" class="headerlink" title="请谈谈小程序页面的生命周期函数？"></a>请谈谈小程序页面的生命周期函数？</h2><p>页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数。Page(Object) 函数用来注册一个页面。接受一个Object类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。</p><ul><li>onLoad() 页面加载时触发，只会调用一次，可获取当前页面路径中的参数。</li><li>onShow() 页面显示/切入前台时触发，一般用来发送数据请求；</li><li>onReady() 页面初次渲染完成时触发, 只会调用一次，代表页面已可和视图层进行交互。</li><li>onHide() 页面隐藏/切入后台时触发, 如底部 tab 切换到其他页面或小程序切入后台等。</li><li>onUnload() 页面卸载时触发，如redirectTo或navigateBack到其他页面时。</li><li>onPullDownRefresh() 下拉刷新的钩子函数 用户下拉刷新时会自动走到这个函数中</li><li>onReachBottom() 上翻到底的钩子函数</li><li>onShareAppMessage() 用户点击右上角转发</li><li>onPageScroll() 页面滚动事件的处理函数</li><li>onTabItemTap 当前是tab页时，点击tab时触发</li></ul><h2 id="怎么封装微信小程序的数据请求？"><a href="#怎么封装微信小程序的数据请求？" class="headerlink" title="怎么封装微信小程序的数据请求？"></a>怎么封装微信小程序的数据请求？</h2><p>将所有的接口放在统一的js文件中并导出<br><br>在app.js中创建封装请求数据的方法<br><br>在子页面中调用封装的请求数据<br></p><p>或</p><p>在根目录下创建utils目录及api.js文件和apiConfig.js文件；<br><br>在appConfig.js封装基础的get\post\put\upload等请求方法，设置请求体，带上token和异常处理等；<br><br>在api.js中引入apiConfig.js封装好的请求方法，根据页面数据请求的urls，设置对应的方法并导出；<br><br>在具体页面导入；<br></p><h2 id="怎么解决微信小程序的异步请求问题？"><a href="#怎么解决微信小程序的异步请求问题？" class="headerlink" title="怎么解决微信小程序的异步请求问题？"></a>怎么解决微信小程序的异步请求问题？</h2><p>在回调函数中调用下一个组件的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **app.js**</span></span><br><span class="line"></span><br><span class="line">success:<span class="function"><span class="keyword">function</span>(<span class="params">info</span>)</span>&#123;</span><br><span class="line">    that.apirtnCallback(info)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **index.js**</span></span><br><span class="line">onLoad:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    app.apirtnCallback = <span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小程序关联微信公众号如何确定用户的唯一性？"><a href="#小程序关联微信公众号如何确定用户的唯一性？" class="headerlink" title="小程序关联微信公众号如何确定用户的唯一性？"></a>小程序关联微信公众号如何确定用户的唯一性？</h2><p>使用wx.getUserInfo方法 withCredentials为true时，可获取encryptedData，里面有union_id.后端需要进行对称解密。</p><h2 id="使用webview直接加载要注意哪些事项？"><a href="#使用webview直接加载要注意哪些事项？" class="headerlink" title="使用webview直接加载要注意哪些事项？"></a>使用webview直接加载要注意哪些事项？</h2><p>必须要在小程序后台使用管理员添加业务域名；<br><br>h5页面跳转至小程序的脚步必须是1.3.1以上；<br><br>微信分享只可以是小程序的主名称，如要自定义分享内容，需小程序版本在1.7.1以上；<br><br>h5的支付不可以是微信公众号的appid，必须是小程序的appid，而且用户的openid也必须是用户和小程序的<br></p><h2 id="小程序调用后台接口遇到哪些问题？"><a href="#小程序调用后台接口遇到哪些问题？" class="headerlink" title="小程序调用后台接口遇到哪些问题？"></a>小程序调用后台接口遇到哪些问题？</h2><p>数据的大小限制，超过范围会直接导致整个小程序崩溃，除非重启小程序；<br>小程序不可以直接渲染文章内容这类型的html文本，显示需借助插件<br>注：插件渲染会导致页面加载变慢，建议在后台对文章内容的html进行过滤，后台直接处理批量替换p标签div标签为view标签。然后其他的标签让插件来做。</p><h2 id="微信小程序如何实现下拉刷新？"><a href="#微信小程序如何实现下拉刷新？" class="headerlink" title="微信小程序如何实现下拉刷新？"></a>微信小程序如何实现下拉刷新？</h2><p>用view代替scroll-view，设置onPullDownRefresh函数实现</p><h2 id="webview中的页面怎么跳转回小程序？"><a href="#webview中的页面怎么跳转回小程序？" class="headerlink" title="webview中的页面怎么跳转回小程序？"></a>webview中的页面怎么跳转回小程序？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wx.miniProgram.navigateTo(&#123;</span><br><span class="line">    url:’pages/login/login’+’$params’</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//** 跳转到小程序导航页面 **</span></span><br><span class="line"></span><br><span class="line">wx.miniProgram.switchTab(&#123;</span><br><span class="line">    url:’/pages/index/index’</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>rpx:小程序的尺寸单位，规定屏幕为750rpx，可适配不同分辨率的屏幕。</li><li>本地资源无法通过wxss获取<br>RE：</li></ol><ul><li>background-image：可以使用网络图片，或者base64，或者使用标签</li></ul><ol start="3"><li>wx.navigateTo无法打开页面<br>RE：<br>一个应用同时只能打开5个页面，请避免多层级的交互方式，或使用wx.redirectTo</li><li>tabBar设置不显示<br>RE：<br>tabBar的数量少于2项或超过5项都不会显示；<br>tabBar写法错误导致不显示；<br>tabBar没有写pagePath字段（程序启动后显示的第一个页面）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对小程序的面试题做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;1-简单描述下微信小程序的相关文件类型&quot;&gt;&lt;a href=&quot;#1-简单描述下微信小程序的相关文件类型&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="小程序" scheme="http://github.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://github.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之网络安全</title>
    <link href="http://github.com/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://github.com/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2021-03-20T16:00:00.000Z</published>
    <updated>2021-03-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><p>浏览器安全可以分为三大块：</p><ul><li>Web 页面安全</li><li>浏览器网络安全</li><li>浏览器系统安全</li></ul><p>在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。</p><p>这就引出了页面中最基础、最核心的安全策略：同源策略（Same-origin policy）。</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>所谓的同源，是指 协议、域名、端口 一致的情况下，才属于同源。</p><p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</p><h3 id="为什么需要同源策略"><a href="#为什么需要同源策略" class="headerlink" title="为什么需要同源策略"></a>为什么需要同源策略</h3><p>同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p><ol><li><p>第一个，DOM 层面</p><p> 同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p><p> 当你在 A 页面，通过 <code>&lt;a href=&quot;xxx&quot; target=&quot;_blank&quot;&gt;</code> 的形式打开 B 页面，经过下面 2 行代码可以将 A 页面的内容给隐藏掉：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pdom = opener.document;</span><br><span class="line">pdom.body.style.display = <span class="string">&quot;none&quot;</span>;</span><br></pre></td></tr></table></figure><p> 这就是同源情况下 DOM 的一个操作。</p><p> 而不同源的是无法操作的。</p></li><li><p>第二个，数据层面</p></li></ol><p>同源策略限制了不同源的站点读取当前站点的 <code>Cookie</code>、<code>IndexDB</code>、<code>LocalStorage</code> 等数据。</p><p>由于同源策略，我们依然无法通过 B 页面的 <code>opener</code> 来访问 A 页面中的 <code>Cookie</code>、<code>IndexDB</code> 或者 <code>LocalStorage</code> 等内容。</p><ol start="3"><li>第三个，网络层面<br>同源策略限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送给不同源的站点。</li></ol><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><ul><li>XSS 攻击类型</li></ul><ol><li>存储型</li><li>反射型</li><li>文档型</li></ol><ul><li>XSS 防范措施</li></ul><ol><li>输入检查</li><li>利用 CSP</li><li>利用 HttpOnly</li></ol><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击，攻击者在目标网站上注入恶意代码，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ol><li>可以窃取 Cookie 信息。恶意 JavaScript 可以通过 document.cookie 获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器。恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li><li>可以监听用户行为。恶意 JavaScript 可以使用 addEventListener 接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li><li>可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li><li>可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。</li></ol><h3 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h3><h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4><p>攻击者将脚本混在 URL 里，服务端接收到 URL 将恶意代码当做参数取出并拼接在 HTML 里返回，浏览器解析此 HTML 后即执行恶意代码。例如 Q 群或者邮件中发送恶意链接，用户点击恶意链接，然后解析 URL 执行恶意代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Select your language:</span><br><span class="line">&lt;select&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        document.write(&#39;&#39;</span><br><span class="line">            + &#39;&lt;option value&#x3D;1&gt;&#39;</span><br><span class="line">            +     location.href.substring(location.href.indexOf(&#39;default&#x3D;&#39;) + 8)</span><br><span class="line">            + &#39;&lt;&#x2F;option&gt;&#39;</span><br><span class="line">        );</span><br><span class="line">        document.write(&#39;&lt;option value&#x3D;2&gt;English&lt;&#x2F;option&gt;&#39;);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;xx.com&#x2F;xx?default&#x3D;&lt;script&gt;alert(document.cookie)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h5 id="反射型-XSS-的攻击步骤："><a href="#反射型-XSS-的攻击步骤：" class="headerlink" title="反射型 XSS 的攻击步骤："></a>反射型 XSS 的攻击步骤：</h5><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><h5 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h5><ol><li>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。</li><li>攻击者需要诱骗点击</li><li>反馈率低，所以较难发现和响应修复</li><li>盗取用户敏感保密信息</li></ol><h5 id="防止出现非持久型-XSS-漏洞"><a href="#防止出现非持久型-XSS-漏洞" class="headerlink" title="防止出现非持久型 XSS 漏洞"></a>防止出现非持久型 XSS 漏洞</h5><ol><li>Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。</li><li>尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。</li><li>尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.creteElement() 等可执行字符串的方法。</li><li>如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。</li><li>前端渲染的时候对任何的字段都需要做 escape 转义编码。</li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>DOM 渲染的方法传入的字符串参数做 escape 转义，对url的查询参数进行转义后再输出到页面。</p><blockquote><p>escape 转义的目的是将一些构成 HTML 标签的元素转义，比如 &lt;，&gt;，空格 等，转义成 &lt;，&gt;，&nbsp; 等显示转义字符。有很多开源的工具可以协助我们做 escape 转义。</p></blockquote><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><p>持久型 XSS 漏洞，也被称为存储型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。即攻击被存储在服务端，常见的是在评论区插入攻击脚本</p><h5 id="存储型XSS攻击的原因"><a href="#存储型XSS攻击的原因" class="headerlink" title="存储型XSS攻击的原因"></a>存储型XSS攻击的原因</h5><p>没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。</p><h5 id="存储型-XSS-的攻击步骤："><a href="#存储型-XSS-的攻击步骤：" class="headerlink" title="存储型 XSS 的攻击步骤："></a>存储型 XSS 的攻击步骤：</h5><ol><li>攻击者将恶意代码提交到目标网站的数据库中。</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ol><li>持久性，植入在数据库中</li><li>危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡。</li><li>盗取用户敏感私密信息</li></ol><h5 id="防止持久型-XSS-漏洞"><a href="#防止持久型-XSS-漏洞" class="headerlink" title="防止持久型 XSS 漏洞"></a>防止持久型 XSS 漏洞</h5><ol><li>前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)</li><li>服务器接收到数据，在存储到数据库之前，进行转义/过滤</li><li>前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤</li></ol><h4 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h4><p>DOM 型 XSS 攻击，实际上就是前端 <code>JavaScript</code> 代码不够严谨，把不可信的内容插入到了页面。在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>.appendChild</code>、<code>document.write()</code>等API时要特别小心，不要把不可信的数据作为 <code>HTML</code> 插到页面上，尽量使用 <code>.innerText</code>、<code>.textContent</code>、<code>.setAttribute()</code> 等。</p><h5 id="DOM-型-XSS-的攻击步骤："><a href="#DOM-型-XSS-的攻击步骤：" class="headerlink" title="DOM 型 XSS 的攻击步骤："></a>DOM 型 XSS 的攻击步骤：</h5><ol><li>攻击者构造出特殊数据，其中包含恶意代码。</li><li>用户浏览器执行了恶意代码。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><h5 id="如何防范-DOM-型-XSS-攻击"><a href="#如何防范-DOM-型-XSS-攻击" class="headerlink" title="如何防范 DOM 型 XSS 攻击"></a>如何防范 DOM 型 XSS 攻击</h5><p>对输入内容进行转义(DOM 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)。</p><ol><li>对于url链接(例如图片的src属性)，那么直接使用 encodeURIComponent 来转义。</li><li>非url，我们可以这样进行编码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeHtml</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quot;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&amp;apos;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&amp;gt;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="基于字符集的-XSS"><a href="#基于字符集的-XSS" class="headerlink" title="基于字符集的 XSS"></a>基于字符集的 XSS</h4><p>其实现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。</p><p>以基于<code>utf-7</code>的 <code>XSS</code> 为例<br><code>utf-7 </code>是可以将所有的 <code>unicode </code>通过<code>7bit</code>来表示的一种字符集 (但现在已经从 Unicode 规格中移除)。</p><p>这个字符集为了通过 <code>7bit</code> 来表示所有的文字, 除去数字和一部分的符号,其它的部分将都以 base64 编码为基础的方式呈现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="string">&quot;xss&quot;</span>)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">可以被解释为：</span><br><span class="line">+ADw-script+AD4-alert(+ACI-xss+ACI-)+ADw-/script+AD4-</span><br></pre></td></tr></table></figure><p>可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。</p><p>避免这种XSS</p><p>记住指定 <meta charset="utf-8"><br>XML 中不仅要指定字符集为 utf-8，而且标签要闭合</p><h3 id="其他防范措施"><a href="#其他防范措施" class="headerlink" title="其他防范措施"></a>其他防范措施</h3><h4 id="1-Content-Security-Policy"><a href="#1-Content-Security-Policy" class="headerlink" title="1.Content Security Policy"></a>1.<code>Content Security Policy</code></h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>在服务端使用 HTTP的 Content-Security-Policy 头部来指定策略，或者在前端设置 meta 标签。<br>例如下面的配置只允许加载同域下的资源：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Security-Policy&quot;</span> content=<span class="string">&quot;form-action &#x27;self&#x27;;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>前端和服务端设置 CSP 的效果相同，但是meta无法使用report</p><h5 id="严格的-CSP-在-XSS-的防范中可以起到以下的作用："><a href="#严格的-CSP-在-XSS-的防范中可以起到以下的作用：" class="headerlink" title="严格的 CSP 在 XSS 的防范中可以起到以下的作用："></a>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</h5><ol><li>禁止加载外域代码，防止复杂的攻击逻辑。</li><li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li><li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li><li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li><li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li></ol><h4 id="2-输入内容长度控制"><a href="#2-输入内容长度控制" class="headerlink" title="2.输入内容长度控制"></a>2.输入内容长度控制</h4><p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p><h4 id="3-输入内容限制"><a href="#3-输入内容限制" class="headerlink" title="3.输入内容限制"></a>3.输入内容限制</h4><p>对于部分输入，可以限定不能包含特殊字符或者仅能输入数字等。</p><h4 id="4-其他安全措施"><a href="#4-其他安全措施" class="headerlink" title="4.其他安全措施"></a>4.其他安全措施</h4><ul><li><code>HTTP-only Cookie</code>: 禁止 <code>JavaScript</code> 读取某些敏感 <code>Cookie</code>，攻击者完成 <code>XSS</code> 注入后也无法窃取此 <code>Cookie</code>。</li><li>验证码：防止脚本冒充用户提交危险操作。</li></ul><h4 id="XSS-检测"><a href="#XSS-检测" class="headerlink" title="XSS 检测"></a>XSS 检测</h4><p>1.使用通用 XSS 攻击字串手动检测 XSS 漏洞</p><p>如:</p><p><code>jaVasCript:/*-/*`/*\`/*&#39;/*&quot;/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e</code></p><p>能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write() 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="number">1</span> onerror=alert(<span class="number">1</span>)&gt;</span><br></pre></td></tr></table></figure><p>2.使用第三方工具进行扫描</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><h3 id="攻击流程："><a href="#攻击流程：" class="headerlink" title="攻击流程："></a>攻击流程：</h3><ol><li>受害者登录A站点，并保留了登录凭证（Cookie）。</li><li>攻击者诱导受害者访问了站点B。</li><li>站点B向站点A发送了一个请求，浏览器会默认携带站点A的Cookie信息。</li><li>站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。</li><li>站点A以受害者的名义执行了站点B的请求。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。</li></ol><h3 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h3><ol><li>攻击通常在第三方网站发起，如图上的站点B，站点A无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；并不会去获取cookie信息(cookie有同源策略)</li><li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等(来源不明的链接，不要点击)</li></ol><h3 id="常见方式"><a href="#常见方式" class="headerlink" title="常见方式"></a>常见方式</h3><h4 id="方法一：自动发起-Get-请求"><a href="#方法一：自动发起-Get-请求" class="headerlink" title="方法一：自动发起 Get 请求"></a>方法一：自动发起 Get 请求</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>黑客的站点：CSRF 攻击演示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://jsliang.top/index.html?user=hacker&amp;number=100&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。</p><p>当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的 100 块就被转移到黑客的账户上去了。</p><h3 id="方法二：自动发起-POST-请求"><a href="#方法二：自动发起-POST-请求" class="headerlink" title="方法二：自动发起 POST 请求"></a>方法二：自动发起 POST 请求</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>黑客的站点：CSRF 攻击演示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&#x27;hacker-form&#x27;</span> <span class="attr">action</span>=<span class="string">&quot;https://jsliang.top&quot;</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;hacker-form&#x27;</span>).submit();</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口。</p><p>当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。</p><p>因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。</p><h3 id="方法三：引诱用户点击链接"><a href="#方法三：引诱用户点击链接" class="headerlink" title="方法三：引诱用户点击链接"></a>方法三：引诱用户点击链接</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">150</span> <span class="attr">src</span>=<span class="string">http://images.xuejuzi.cn/1612/1_161230185104_1.jpg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://jsliang.top?user=hacker&amp;number=100&quot;</span> <span class="attr">taget</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">    点击下载美女照片</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>传说中的色诱，或者 “点击即送 100w 元” 之类的。</p><h3 id="CSRF-攻击防御"><a href="#CSRF-攻击防御" class="headerlink" title="CSRF 攻击防御"></a>CSRF 攻击防御</h3><ol><li>添加验证码(体验不好)</li></ol><p>验证码能够防御CSRF攻击，但是我们不可能每一次交互都需要验证码，否则用户的体验会非常差，但是我们可以在转账，交易等操作时，增加验证码，确保我们的账户安全。</p><ol start="2"><li>判断请求的来源：检测Referer(并不安全，Referer可以被更改)</li></ol><p><code>Referer</code> 可以作为一种辅助手段，来判断请求的来源是否是安全的，但是鉴于 <code>Referer</code> 本身是可以被修改的，因为不能仅依赖于  <code>Referer</code></p><ol start="3"><li><p>使用Token(主流)</p><p> CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。</p><ul><li>服务端给用户生成一个token，加密后传递给用户</li><li>用户在提交请求时，需要携带这个token</li><li>服务端验证token是否正确</li></ul></li><li><p>Samesite Cookie属性</p></li></ol><p>为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax。<br>部署简单，并能有效防御CSRF攻击，但是存在兼容性问题。<br><br><code>Samesite=Strict</code><br><br><code>Samesite=Strict</code> 被称为是严格模式,表明这个 Cookie 在任何情况都不可能作为第三方的 Cookie，有能力阻止所有CSRF攻击。此时，我们在B站点下发起对A站点的任何请求，A站点的 Cookie 都不会包含在cookie请求头中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**Samesite&#x3D;Lax**</span><br></pre></td></tr></table></figure><p><code>Samesite=Lax</code> 被称为是宽松模式，与 Strict 相比，放宽了限制，允许发送安全 HTTP 方法带上 Cookie，如 <code>Get</code> / <code>OPTIONS</code> 、<code>HEAD</code> 请求.</p><p>但是不安全 HTTP 方法，如： <code>POST</code>, <code>PUT</code>, <code>DELETE</code> 请求时，不能作为第三方链接的 Cookie</p><p>为了更好的防御CSRF攻击，我们可以组合使用以上防御手段。</p><h3 id="CSRF-攻击防御总结"><a href="#CSRF-攻击防御总结" class="headerlink" title="CSRF 攻击防御总结"></a>CSRF 攻击防御总结</h3><ol><li>添加验证码(体验不好)我们不可能每一次交互都需要验证码，我们可以在转账，交易等操作时，增加验证码，确保我们的账户安全。</li><li>验证 Token：浏览器请求服务器时，服务器返回一个 token，之后每个请求都需要同时带上 token 和 Cookie 才会被认为是合法请求</li><li>验证 Referer：通过验证请求头的 Referer 来验证来源站点，但请求头很容易伪造</li><li>设置 SameSite：设置 Cookie 的 SameSite，可以让 Cookie 不随跨站请求发出，但浏览器兼容不一</li></ol><h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>点击劫持是指在一个Web页面中隐藏了一个透明的iframe，用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作。</p><h3 id="典型点击劫持攻击流程"><a href="#典型点击劫持攻击流程" class="headerlink" title="典型点击劫持攻击流程"></a>典型点击劫持攻击流程</h3><ol><li>攻击者构建了一个非常有吸引力的网页【不知道哪些内容对你们来说有吸引力，我就不写页面了，偷个懒】</li><li>将被攻击的页面放置在当前页面的 iframe 中</li><li>使用样式将 iframe 叠加到非常有吸引力内容的上方</li><li>将iframe设置为100%透明</li><li>你被诱导点击了网页内容，你以为你点击的是***，而实际上，你成功被攻击了。</li></ol><h3 id="点击劫持防御"><a href="#点击劫持防御" class="headerlink" title="点击劫持防御"></a>点击劫持防御</h3><ol><li><p><code>frame busting</code></p><p> <code>Frame busting</code></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( top.location != <span class="built_in">window</span>.location )&#123;</span><br><span class="line">    top.location = <span class="built_in">window</span>.location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 需要注意的是: <code>HTML5</code>中<code>iframe</code>的 <code>sandbox</code> 属性、<code>IE</code>中<code>iframe</code>的<code>security</code> 属性等，都可以限制<code>iframe</code>页面中的<code>JavaScript</code>脚本执行，从而可以使得 <code>frame busting</code> 失效。</p></li><li><p><code>X-Frame-Options</code></p><p> <code>X-FRAME-OPTIONS</code>是微软提出的一个<code>http</code>头，专门用来防御利用<code>iframe</code>嵌套的点击劫持攻击。并且在<code>IE8</code>、<code>Firefox3.6</code>、<code>Chrome4</code>以上的版本均能很好的支持。<br><br> 可以设置为以下值:</p><ul><li>DENY: 拒绝任何域加载</li><li>SAMEORIGIN: 允许同源域下加载</li><li>ALLOW-FROM: 可以定义允许frame加载的页面地址</li></ul></li></ol><h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><p>已有代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/login&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;Username: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span>&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Password: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span>&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登陆&quot;</span> /&gt;</span></span>&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>后端的登录语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> querySQL = <span class="string">`</span></span><br><span class="line"><span class="string">  SELECT *</span></span><br><span class="line"><span class="string">  FROM user</span></span><br><span class="line"><span class="string">  WHERE username=&#x27;<span class="subst">$&#123;username&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">  AND psw=&#x27;<span class="subst">$&#123;password&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="comment">// 接下来就是执行 sql 语句...</span></span><br></pre></td></tr></table></figure><p>攻击者输入的信息是：</p><p>用户名：jsliang’ OR 1 = 1 –<br><br>密码：随意，例如 123456<br><br>预想输入和现在输入变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE username&#x3D;&#39;jsliang&#39; AND psw&#x3D;&#39;123456&#39;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user WHERE username&#x3D;&#39;jsliang&#39; OR 1 &#x3D; 1 --&#39; AND psw&#x3D;&#39;xxxx&#39;</span><br></pre></td></tr></table></figure><p>我们先拆解这条 SQL 语句，避免有些小伙伴看不懂：</p><p>SELECT：查找</p><p>*：所有信息</p><p>FROM：来源于某个表（From xxx）</p><p>user：用户表</p><p>username=’xxx’：用户名是 xxx</p><p>AND：和</p><p>OR：或</p><p>–：注释，跟我们 JS 的 // 一样</p><p>所以上面代码的意思是：</p><p>第一条：查找 user 表，其中 username 为 jsliang，并且密码是 123456</p><p>第二条：查找 user 表，其中 username 为 jsliang，或者 1 = 1</p><p>这样，第二条的 SQL 查询条件就必定是真的啦，我们就可以登录这个账号了。</p><p>这就是 SQL 注入。</p><p>怎么预防？这里我们不理会，属于后端需要注意的范畴。</p><p>当然后端可能要求前端帮忙防范，比如用户名不能包含 -、_ 等~</p><h2 id="流量劫持"><a href="#流量劫持" class="headerlink" title="流量劫持"></a>流量劫持</h2><p>流量劫持基本分两种：DNS 劫持 和 HTTP 劫持，目的都是一样的，就是当用户访问 github.com 的时候，给你展示的并不是或者不完全是 github.com 提供的 “内容”。</p><h3 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h3><p>DNS 劫持，也叫做域名劫持。</p><p>当用户通过某一个域名访问一个站点的时候，被篡改的 DNS 服务器返回的是一个恶意的钓鱼站点的 IP，用户就被劫持到了恶意钓鱼站点，然后继而会被钓鱼输入各种账号密码信息，泄漏隐私。</p><p>这类劫持：</p><ul><li>要不就是网络运营商搞的鬼，一般小的网络运营商与黑产勾结会劫持 DNS</li><li>要不就是电脑中毒，被恶意篡改了路由器的 DNS 配置，基本上做为开发者或站长却是很难察觉的，除非有用户反馈。<h3 id="HTTP-劫持"><a href="#HTTP-劫持" class="headerlink" title="HTTP 劫持"></a>HTTP 劫持</h3></li></ul><p>HTTP 劫持主要是当用户访问某个站点的时候会经过运营商网络，而不法运营商和黑产勾结能够截获 HTTP 请求返回内容，并且能够篡改内容，然后再返回给用户，从而实现劫持页面。</p><p>轻则插入小广告，重则直接篡改成钓鱼网站页面骗用户隐私，就好比 jsliang 访问某 XXDN 网站，会出现 Google 广告，实际上问了其他人的是不会有这个的。</p><p>能够实施流量劫持的根本原因，是 HTTP 协议没有办法对通信对方的身份进行校验以及对数据完整性进行校验。如果能解决这个问题，则流量劫持将无法轻易发生。</p><p>所以防止 HTTP 劫持的方法只有将内容加密，让劫持者无法破解篡改，这样就可以防止 HTTP 劫持了。</p><p>HTTPS 是基于 SSL 协议的安全加密网络应用层协议，相当于 HTTP + SSL，可以很好地防止 HTTP 劫持。</p><h2 id="浏览器网络安全"><a href="#浏览器网络安全" class="headerlink" title="浏览器网络安全"></a>浏览器网络安全</h2><p>HTTP 在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，在通信过程中的一切内容都在中间人的掌握中。</p><p>使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为中间人攻击。</p><p>具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。</p><p>比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。</p><p>或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。</p><h2 id="浏览器系统安全"><a href="#浏览器系统安全" class="headerlink" title="浏览器系统安全"></a>浏览器系统安全</h2><p>浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序。</p><p>其中最常见的攻击方式是利用缓冲区溢出，不过需要注意这种类型的攻击和 XSS 注入的脚本是不一样的。</p><p>XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。<br><br>通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。<br><br>渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限。</p><p>基于此，在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。</p><p>将渲染进程和操作系统隔离的这道墙就是安全沙箱。</p><h2 id="安全扫描工具"><a href="#安全扫描工具" class="headerlink" title="安全扫描工具"></a>安全扫描工具</h2><ol><li><p>Arachni</p><p>Arachni是基于Ruby的开源，功能全面，高性能的漏洞扫描框架，Arachni提供简单快捷的扫描方式，只需要输入目标网站的网址即可开始扫描。它可以通过分析在扫描过程中获得的信息，来评估漏洞识别的准确性和避免误判。<br><br>Arachni默认集成大量的检测工具，可以实施 代码注入、CSRF、文件包含检测、SQL注入、命令行注入、路径遍历等各种攻击。<br><br>同时，它还提供了各种插件，可以实现表单爆破、HTTP爆破、防火墙探测等功能。<br>针对大型网站，该工具支持会话保持、浏览器集群、快照等功能，帮助用户更好实施渗透测试。</p></li><li><p>Mozilla HTTP Observatory</p><p> <code>Mozilla HTTP Observatory</code>，是<code>Mozilla</code>最近发布的一款名为<code>Observatory</code>的网站安全分析工具，意在鼓励开发者和系统管理员增强自己网站的安全配置。用法非常简单：输入网站URL，即可访问并分析网站HTTP标头，随后可针对网站安全性提供数字形式的分数和字母代表的安全级别。</p><p> 检查的主要范围包括：</p><ul><li>Cookie</li><li>跨源资源共享（CORS）</li><li>内容安全策略（CSP）</li><li>HTTP公钥固定（Public Key Pinning）</li><li>HTTP严格安全传输（HSTS）状态</li><li>是否存在HTTP到HTTPs的自动重定向</li><li>子资源完整性（Subresource Integrity）</li><li>X-Frame-Options</li><li>X-XSS-Protection</li></ul></li><li><p>w3af</p></li></ol><p>W3af是一个基于<code>Python</code>的<code>Web</code>应用安全扫描器。可帮助开发人员，有助于开发人员和测试人员识别<code>Web</code>应用程序中的漏洞。<br><br>扫描器能够识别<code>200</code>多个漏洞，包括跨站点脚本、<code>SQL</code>注入和操作系统命令。</p><ul><li><p><a href="https://juejin.cn/post/6844903842635579405">【面试篇】寒冬求职之你必须要懂的Web安全</a></p></li><li><p><a href="https://zoumiaojiang.com/article/common-web-security/#xss">常见 Web 安全攻防总结</a></p></li><li><p><a href="https://github.com/LiangJunrong/document-library/blob/master/%E7%B3%BB%E5%88%97-%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8.md">网络安全</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;浏览器安全&quot;&gt;&lt;a href=&quot;#浏览器安全&quot; class=&quot;headerlink&quot; title=&quot;浏览器安全&quot;&gt;&lt;/a&gt;浏览器安全&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://github.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://github.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>面试宝典之React篇</title>
    <link href="http://github.com/2021/03/08/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BReact%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://github.com/2021/03/08/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BReact%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2021-03-07T16:00:00.000Z</published>
    <updated>2021-03-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对React面试 的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="1-React-中-keys-的作用是什么？"><a href="#1-React-中-keys-的作用是什么？" class="headerlink" title="1. React 中 keys 的作用是什么？"></a>1. React 中 keys 的作用是什么？</h2><p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">this</span>.state.todoItems.map(<span class="function">(<span class="params">&#123;item, key&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;item&#125;</span><br><span class="line">    &#125;)&#125;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><p>react利用key来识别组件，它是一种身份标识标识，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建<br><br>有了key属性后，就可以与组件建立了一种对应关系，react根据key来决定是销毁重新创建组件还是更新组件。<br><br>key相同，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新。<br>key值不同，则react先销毁该组件(有状态组件的componentWillUnmount会执行)，然后重新创建该组件（有状态组件的constructor和componentWillUnmount都会执行）</p><h2 id="2-调用-setState-之后发生了什么？"><a href="#2-调用-setState-之后发生了什么？" class="headerlink" title="2.调用 setState 之后发生了什么？"></a>2.调用 setState 之后发生了什么？</h2><p>在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程。<br>经过调和过程，React会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个 UI 界面。<br>在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。<br>在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p><h2 id="3-触发多次setstate，那么render会执行几次？"><a href="#3-触发多次setstate，那么render会执行几次？" class="headerlink" title="3.触发多次setstate，那么render会执行几次？"></a>3.触发多次setstate，那么render会执行几次？</h2><p>多次setState会合并为一次render，因为setState并不会立即改变state的值，而是将其放到一个任务队列里，最终将多个setState合并，一次性更新页面。<br>所以我们可以在代码里多次调用setState，每次只需要关注当前修改的字段即可。</p><h2 id="react中如何对state中的数据进行修改？setState为什么是一个异步的？"><a href="#react中如何对state中的数据进行修改？setState为什么是一个异步的？" class="headerlink" title="react中如何对state中的数据进行修改？setState为什么是一个异步的？"></a>react中如何对state中的数据进行修改？setState为什么是一个异步的？</h2><p>修改数据通过this.setState(参数1,参数2)<br>this.setState是一个异步函数</p><p>参数1 : 是需要修改的数据是一个对象<br>参数2 : 是一个回调函数，可以用来验证数据是否修改成功，同时可以获取到数据更新后的DOM结构等同于componentDidMount</p><p>this.setState中的第一个参数除了可以写成一个对象以外，还可以写成一个函数 ！，函数中第一个值为prevState 第二个值为prePprops this.setState((prevState,prop)=&gt;({}))</p><p>为什么建议传递给 setState的参数是一个callback而不是一个对象？</p><p>因为this.props 和this.state的更新可能是异步的，不能依赖它们的值去计算下一个state</p><p>为什么setState是一个异步的？（请看3）</p><p>当批量执行state的时候可以让DOM渲染的更快,也就是说多个setstate在执行的过程中还需要被合并</p><h2 id="4-this-setState之后react做了哪些操作？"><a href="#4-this-setState之后react做了哪些操作？" class="headerlink" title="4.this.setState之后react做了哪些操作？"></a>4.this.setState之后react做了哪些操作？</h2><p><code>shouldComponentUpdate</code><br><br><code>componentWillUpdate</code><br><br><code>render</code><br><br><code>componentDidUpdate</code><br></p><h2 id="5-简述一下virtual-DOM-（虚拟dom）如何工作？（4-amp-5-取一回答）"><a href="#5-简述一下virtual-DOM-（虚拟dom）如何工作？（4-amp-5-取一回答）" class="headerlink" title="5.简述一下virtual DOM （虚拟dom）如何工作？（4 &amp; 5 取一回答）"></a>5.简述一下virtual DOM （虚拟dom）如何工作？（4 &amp; 5 取一回答）</h2><p>当数据发生变化，比如setState时，会引起组件重新渲染，整个UI都会以virtual dom的形式重新渲染<br>然后收集差异也就是diff新的virtual dom和老的virtual dom的差异<br>最后把差异队列里的差异，比如增加节点、删除节点、移动节点更新到真实的DOM上</p><h2 id="5-为什么虚拟-dom-会提高性能"><a href="#5-为什么虚拟-dom-会提高性能" class="headerlink" title="5.为什么虚拟 dom 会提高性能?"></a>5.为什么虚拟 dom 会提高性能?</h2><p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。<br>用 JavaScript 对象结构表示 DOM 树的结构<br>然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。<br>然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p><h2 id="6-react-diff-原理"><a href="#6-react-diff-原理" class="headerlink" title="6.react diff 原理"></a>6.react diff 原理</h2><p>把树形结构按照层级分解，只比较同级元素。<br>给列表结构的每个单元添加唯一的 key 属性，方便比较。<br>React 只会匹配相同class的component（这里面的class指的是组件的名字）<br>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React检查所有标记 dirty 的 component 重新绘制.<br>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p><h2 id="7-React-中-refs-的作用是什么？（详细版本）"><a href="#7-React-中-refs-的作用是什么？（详细版本）" class="headerlink" title="7.React 中 refs 的作用是什么？（详细版本）"></a>7.React 中 refs 的作用是什么？（详细版本）</h2><p>Refs 是 React 提供给我们的安全访问DOM元素或者某个组件实例的句柄。<br>是父组件用来获取子组件的dom元素的<br>我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">handleSubmit = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Input Value: &quot;</span>, <span class="built_in">this</span>.input.value)</span><br><span class="line">&#125;</span><br><span class="line">render () &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">&lt;input</span><br><span class="line">type=<span class="string">&#x27;text&#x27;</span></span><br><span class="line">ref=&#123;<span class="function">(<span class="params">input</span>) =&gt;</span> <span class="built_in">this</span>.input = input&#125; /&gt;</span><br><span class="line">Submit</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。</p><p>另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomForm</span> (<span class="params">&#123;handleSubmit&#125;</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> inputElement</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;form onSubmit=&#123;<span class="function">() =&gt;</span> handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">&lt;input</span><br><span class="line">type=<span class="string">&#x27;text&#x27;</span></span><br><span class="line">ref=&#123;<span class="function">(<span class="params">input</span>) =&gt;</span> inputElement = input&#125; /&gt;</span><br><span class="line">Submit</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[详细易懂版本(推荐)]</p><ol><li><p>ref设置为普通字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button ref=<span class="string">&quot;myBtn&quot;</span>&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>给元素定义ref属性，后续可以通过 this.refs.myBtn 来获取这个真实DOM对象<br>给组件定义ref属性，后续可以通过 this.refs.myBtn 来获取这个组件的实例对象</p></li><li><p>ref设置为箭头函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button ref=<span class="string">&quot;&#123; (sl) =&gt; &#123; this.myBtn = sl &#125; &#125;&quot;</span>&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>给元素定义ref属性，后续可以通过 this.myBtn 来获取这个真实DOM对象<br>给组件定义ref属性，后续可以通过 this.myBtn 来获取这个组件的实例对象</p><h2 id="8-React-中有哪些构建组件的方式？"><a href="#8-React-中有哪些构建组件的方式？" class="headerlink" title="8.React 中有哪些构建组件的方式？"></a>8.React 中有哪些构建组件的方式？</h2></li></ol><p>有什么区别？</p><p>函数组件看似只是一个返回值是DOM结构的函数，其实它的背后是无状态组件的思想。<br>函数组件中，你无法使用State，也无法使用组件的生命周期方法，这就决定了函数组件都是展示性组件，接收Props，渲染DOM，而不关注其他逻辑<br>函数组件中没有this<br>函数组件更容易理解。当你看到一个函数组件时，你就知道它的功能只是接收属性，渲染页面，它不执行与UI无关的逻辑处理，它只是一个纯函数。而不用在意它返回的DOM结构有多复杂。</p><h2 id="什么是虚拟DOM？"><a href="#什么是虚拟DOM？" class="headerlink" title="什么是虚拟DOM？"></a>什么是虚拟DOM？</h2><p>难度：:star:</p><p>虚拟DOM（VDOM）它是真实DOM的内存表示,一种编程概念，一种模式。它会和真实的DOM同步，比如通过ReactDOM这种库，这个同步的过程叫做调和(reconcilation)。</p><p>虚拟DOM更多是一种模式，不是一种特定的技术。</p><h2 id="Q2-：类组件和函数组件之间有什么区别？"><a href="#Q2-：类组件和函数组件之间有什么区别？" class="headerlink" title="Q2 ：类组件和函数组件之间有什么区别？"></a>Q2 ：类组件和函数组件之间有什么区别？</h2><p>类组件（ Class components ）<br>无论是使用函数或是类来声明一个组件，它决不能修改它自己的 props 。<br>所有 React 组件都必须是纯函数，并禁止修改其自身 props 。</p><p>React是单项数据流，父组件改变了属性，那么子组件视图会更新。<br>属性 props 是外界传递过来的，状态 state 是组件本身的，状态可以在组件中任意修改<br>组件的属性和状态改变都会更新视图。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;Welcome &#123; <span class="built_in">this</span>.props.name &#125;&lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&#x27;react&#x27;</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure><p>函数组件（functional component）<br>函数组件接收一个单一的 props 对象并返回了一个React元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Welcome (props) &#123;</span><br><span class="line">  return &lt;h1&gt;Welcome &#123;props.name&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Welcome name&#x3D;&#39;react&#39; &#x2F;&gt;, document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure><p>区别<br>函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。</p><p>区别函数组件类组件是否有this没有有是否有生命周期没有有是否有状态state没有有</p><h2 id="Q3-：React中的refs作用是什么？"><a href="#Q3-：React中的refs作用是什么？" class="headerlink" title="Q3 ：React中的refs作用是什么？"></a>Q3 ：React中的refs作用是什么？</h2><p>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。</p><p>我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnControlledForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleSubmit = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Input Value: &quot;</span>, <span class="built_in">this</span>.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="built_in">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">&#x27;text&#x27;</span></span><br><span class="line">          ref=&#123;<span class="function">(<span class="params">input</span>) =&gt;</span> <span class="built_in">this</span>.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=<span class="string">&#x27;submit&#x27;</span>&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。</p><p>另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomForm</span> (<span class="params">&#123;handleSubmit&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> inputElement</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;<span class="function">() =&gt;</span> handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">&#x27;text&#x27;</span></span><br><span class="line">        ref=&#123;<span class="function">(<span class="params">input</span>) =&gt;</span> inputElement = input&#125; /&gt;</span><br><span class="line">      &lt;button type=<span class="string">&#x27;submit&#x27;</span>&gt;Submit&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="描述React事件处理。"><a href="#描述React事件处理。" class="headerlink" title="描述React事件处理。"></a>描述React事件处理。</h2><p>为了解决跨浏览器兼容性问题，React中的事件处理程序将传递SyntheticEvent实例，该实例是React跨浏览器本机事件的跨浏览器包装器。这些综合事件具有与您惯用的本机事件相同的界面，除了它们在所有浏览器中的工作方式相同。</p><p>有点有趣的是，React实际上并未将事件附加到子节点本身。React将使用单个事件侦听器在顶层侦听所有事件。这对性能有好处，也意味着React在更新DOM时无需担心跟踪事件监听器。</p><h2 id="state-和-props有什么区别？"><a href="#state-和-props有什么区别？" class="headerlink" title="state 和 props有什么区别？"></a>state 和 props有什么区别？</h2><p>state 和 props都是普通的JavaScript对象。尽管它们两者都具有影响渲染输出的信息，但它们在组件方面的功能不同。即</p><p>props 是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的 props 来重新渲染子组件，否则子组件的 props 以及展现形式不会改变。<br>state 的主要作用是用于组件保存、控制以及修改自己的状态，它只能在 constructor 中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的 this.setState 来修改，修改 state 属性会导致组件的重新渲染。</p><h2 id="如何创建refs？"><a href="#如何创建refs？" class="headerlink" title="如何创建refs？"></a>如何创建refs？</h2><p>Refs 是使用 React.createRef() 方法创建的，并通过 ref 属性添加到 React 元素上。为了在整个组件中使用 refs ，只需将 ref 分配给构造函数中的实例属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleSubmit = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Input Value is: &quot;</span>, <span class="built_in">this</span>.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="built_in">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">&#x27;text&#x27;</span></span><br><span class="line">          ref=&#123;<span class="function">(<span class="params">input</span>) =&gt;</span> <span class="built_in">this</span>.input = input&#125; /&gt; <span class="comment">// Access DOM input in handle submit</span></span><br><span class="line">        &lt;button type=<span class="string">&#x27;submit&#x27;</span>&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以借助闭包在功能组件中使用它。</p><h2 id="什么是高阶组件？"><a href="#什么是高阶组件？" class="headerlink" title="什么是高阶组件？"></a>什么是高阶组件？</h2><p>高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。基本上，这是从React的组成性质派生的一种模式，我们称它们为 “纯”组件， 因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件的任何行为。</p><p><code>const EnhancedComponent = higherOrderComponent(WrappedComponent);</code><br>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧<br>高阶组件的参数为一个组件返回一个新的组件<br>组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件</p><h2 id="nstructor中super与props参数一起使用的目的是什么？"><a href="#nstructor中super与props参数一起使用的目的是什么？" class="headerlink" title="nstructor中super与props参数一起使用的目的是什么？"></a>nstructor中super与props参数一起使用的目的是什么？</h2><p>在调用方法之前，子类构造函数无法使用 this 引用 super() 。</p><p>在ES6中，在子类的 constructor 中必须先调用 super 才能引用 this 。</p><p>在 constructor 中可以使用 this.props</p><p>使用props：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.props);  <span class="comment">// Prints &#123; name: &#x27;sudheer&#x27;,age: 30 &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不使用props：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.props); <span class="comment">// Prints undefined</span></span><br><span class="line">        <span class="comment">// But Props parameter is still available</span></span><br><span class="line">        <span class="built_in">console</span>.log(props); <span class="comment">// Prints &#123; name: &#x27;sudheer&#x27;,age: 30 &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// No difference outside constructor</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.props) <span class="comment">// Prints &#123; name: &#x27;sudheer&#x27;,age: 30 &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码片段揭示了this.props行为仅在构造函数中有所不同。外部构造函数相同。</p><h2 id="什么是受控组件？"><a href="#什么是受控组件？" class="headerlink" title="什么是受控组件？"></a>什么是受控组件？</h2><p>在HTML当中，像 <code>&lt;input&gt;</code> , <code>&lt;textarea&gt;</code> , 和 <code>&lt;select&gt;</code> 这类表单元素会维持自身状态，并根据用户输入进行更新。但在<code>React</code>中，可变的状态通常保存在组件的状态属性中，并且只能用 <code>setState()</code> 方法进行更新。</p><p>非受控组件<br>非受控组件，即组件的状态不受React控制的组件，例如下边这个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;input /&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo1</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>))</span><br></pre></td></tr></table></figure><p>在这个最简单的输入框组件里,我们并没有干涉input中的value展示,即用户输入的内容都会展示在上面。如果我们通过props给组件设置一个初始默认值,defaultValue属性是React内部实现的一个属性,目的类似于input的placeholder属性。</p><p>受控组件<br>同样的，受控组件就是组件的状态受React控制。上面提到过，既然通过设置input的value属性, 无法改变输入框值,那么我们把它和state结合在一起,再绑定onChange事件,实时更新value值就行了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            value: props.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange(e) &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            value: e.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;input value=&#123;<span class="built_in">this</span>.state.value&#125; onChange=&#123;<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">this</span>.handleChange(e)&#125;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="以下使用React-createElement的等价项是什么？"><a href="#以下使用React-createElement的等价项是什么？" class="headerlink" title="以下使用React.createElement的等价项是什么？"></a>以下使用React.createElement的等价项是什么？</h2><p>问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">&quot;greeting&quot;</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>以下等同于什么使用 React.createElement ？</p><p>答：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>&#125;,</span><br><span class="line">  <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h2><p>JSX即JavaScript XML。一种在React组件内部构建标签的类XML语法。JSX为react.js开发的一套语法糖，也是react.js的使用基础。React在不使用JSX的情况下一样可以工作，然而使用JSX可以提高组件的可读性，因此推荐使用JSX。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> props = <span class="built_in">this</span>.props;  </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;my-component&quot;</span>&gt;</span><br><span class="line">      &lt;a href=&#123;props.url&#125;&gt;&#123;props.name&#125;&lt;/a&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li><p>允许使用熟悉的语法来定义 HTML 元素树；</p></li><li><p>提供更加语义化且移动的标签；</p></li><li><p>程序结构更容易被直观化；</p></li><li><p>抽象了 React Element 的创建过程；</p></li><li><p>可以随时掌控 HTML 标签以及生成这些标签的代码；</p></li><li><p>是原生的 JavaScript。</p></li></ol><h2 id="为什么不直接更新state状态？"><a href="#为什么不直接更新state状态？" class="headerlink" title="为什么不直接更新state状态？"></a>为什么不直接更新state状态？</h2><p>如果进行如下方式更新状态，那么它将不会重新渲染组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Wrong</span></span><br><span class="line">    This.state.message =”Hello world”;</span><br><span class="line">而是使用 setState() 方法。它计划对组件状态对象的更新。状态改变时，组件通过重新渲染做出响应</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Correct</span></span><br><span class="line"> This.setState(&#123;<span class="attr">message</span>: ‘Hello World’&#125;);</span><br></pre></td></tr></table></figure><p>注意：可以分配状态的唯一位置是构造函数。</p><h2 id="ReactJS生命周期有哪些不同阶段？"><a href="#ReactJS生命周期有哪些不同阶段？" class="headerlink" title="ReactJS生命周期有哪些不同阶段？"></a>ReactJS生命周期有哪些不同阶段？</h2><p>React组件的生命周期分为四个不同阶段：</p><ul><li>初始化： 在此阶段，react组件准备设置初始状态和默认道具。</li><li>挂载： react组件已准备好挂载在浏览器DOM中。此阶段涵盖 componentWillMount 和 componentDidMount 生命周期方法。</li><li>更新： 在此阶段，组件以两种方式进行更新，即发送新道具和更新状态。此阶段涵盖了 shouldComponentUpdate，componentWillUpdate和componentDidUpdate 生命周期方法。</li><li>卸载： 在最后一个阶段，不需要该组件，并且可以从浏览器DOM上卸载该组件。此阶段包括 componentWillUnmount 生命周期方法。</li></ul><h2 id="ReactJS的生命周期方法是什么？"><a href="#ReactJS的生命周期方法是什么？" class="headerlink" title="ReactJS的生命周期方法是什么？"></a>ReactJS的生命周期方法是什么？</h2><ul><li>componentWillMount： 在渲染之前执行，用于根组件中的应用程序级别配置。</li><li>componentDidMount： 仅在客户端的第一次渲染之后执行。 这是AJAX请求和DOM或状态更新应该发生的地方。此方法也用于与其他JavaScript框架以及任何延迟执行的函数(如 setTimeout 或 setInterval )进行集成，在这里使用它来更新状态，以便我们可以触发其他生命周期方法。</li><li>componentWillReceiveProps： 只要在另一个渲染被调用之前更新 props 就被调用。 当我们更新状态时，从 setNewNumber 触发它。</li><li>shouldComponentUpdate： 确定是否将更新组件。默认情况下，它返回true。如果您确定组件在状态或道具更新后不需要渲染，则可以返回false值。这是提高性能的好地方，因为如果组件收到新的道具，它可以防止重新渲染。</li><li>componentWillUpdate： 在由shouldComponentUpdate确认返回正值的优点和状态更改时，在重新渲染组件之前执行。</li><li>componentDidUpdate： 通常用于更新DOM以响应属性或状态更改。</li><li>componentWillUnmount： 它将用于取消任何传出的网络请求，或删除与该组件关联的所有事件侦听器。</li></ul><h2 id="React中的这三个点（…）是做什么的？"><a href="#React中的这三个点（…）是做什么的？" class="headerlink" title="React中的这三个点（…）是做什么的？"></a>React中的这三个点（…）是做什么的？</h2><p>…在此React（使用JSX）代码中做什么？它叫什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Modal &#123;...this.props&#125; title=<span class="string">&#x27;Modal heading&#x27;</span> animation=&#123;<span class="literal">false</span>&#125;&gt;</span><br></pre></td></tr></table></figure><p>扩展传值符号。它是在ES2018中添加的（数组/可迭代对象的传播较早，ES2015）。</p><p>例如，如果this.props包含a：1和b：2，则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Modal &#123;...this.props&#125; title=<span class="string">&#x27;Modal heading&#x27;</span> animation=&#123;<span class="literal">false</span>&#125;&gt;</span><br></pre></td></tr></table></figure><p>与以下内容相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Modal a=&#123;<span class="built_in">this</span>.props.a&#125; b=&#123;<span class="built_in">this</span>.props.b&#125; title=<span class="string">&#x27;Modal heading&#x27;</span> animation=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line">扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便-在更新状态时会遇到很多问题，因为您无法修改状态直：</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">  this.setState(prevState =&gt; &#123;</span></span><br><span class="line"><span class="string">      return &#123;foo: &#123;...prevState.foo, a: &quot;updated&quot;&#125;&#125;;</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对React面试 的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;1-React-中-keys-的作用是什么？&quot;&gt;&lt;a href=&quot;#1-React-中-keys-的作用是什么？&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="面试  React" scheme="http://github.com/categories/%E9%9D%A2%E8%AF%95-React/"/>
    
    
      <category term="面试  React" scheme="http://github.com/tags/%E9%9D%A2%E8%AF%95-React/"/>
    
  </entry>
  
  <entry>
    <title>面试宝典之ReactHooks篇</title>
    <link href="http://github.com/2021/03/08/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BReactHooks%E7%AF%87/"/>
    <id>http://github.com/2021/03/08/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BReactHooks%E7%AF%87/</id>
    <published>2021-03-07T16:00:00.000Z</published>
    <updated>2021-03-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对React面试 的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="使用React-Hooks有什么优势？"><a href="#使用React-Hooks有什么优势？" class="headerlink" title="使用React Hooks有什么优势？"></a>使用React Hooks有什么优势？</h2><p>hooks 是react 16.8 引入的特性，他允许你在不写class的情况下操作state 和react的其他特性。</p><p>hooks 只是多了一种写组件的方法，使编写一个组件更简单更方便，同时可以自定义hook把公共的逻辑提取出来，让逻辑在多个组件之间共享。</p><h2 id="Hook-是什么"><a href="#Hook-是什么" class="headerlink" title="Hook 是什么"></a>Hook 是什么</h2><p>Hook 是什么？ Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。稍后我们将学习其他 Hook。</p><p>什么时候我会用 Hook？ 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。</p><h2 id="使用-React-Hooks-好处是啥？"><a href="#使用-React-Hooks-好处是啥？" class="headerlink" title="使用 React Hooks 好处是啥？"></a>使用 React Hooks 好处是啥？</h2><p>首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。</p><p>Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。</p><h2 id="什么是-React-Hooks？"><a href="#什么是-React-Hooks？" class="headerlink" title="什么是 React Hooks？"></a>什么是 React Hooks？</h2><p>Hooks是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用state和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。</p><h2 id="ReactHooks的优点"><a href="#ReactHooks的优点" class="headerlink" title="ReactHooks的优点"></a>ReactHooks的优点</h2><p>无需复杂的DOM结构<br>简洁易懂</p><h2 id="React中的useState？"><a href="#React中的useState？" class="headerlink" title="React中的useState？"></a>React中的useState？</h2><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function useState&lt;S&gt;(initialState: S | (() =&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];</span><br></pre></td></tr></table></figure><p>其中 state 是他的值, setState 是用来设置值的函数, initialState 是初始值</p><p>useState-initialState</p><p>该初始值可以接受任何参数,但是记得当他接受为一个函数时,就变成了 Lazy initialization (延迟初始化)</p><p>该函数返回值即为initialState</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="function">()=&gt;</span><span class="number">0</span>);</span><br><span class="line"><span class="comment">// 这两种初始化方式 是相等的,但是在函数为初始值时会被执行一次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;这里只会在初始化的时候执行&#x27;</span>)</span><br><span class="line">    <span class="comment">// class 中的 constructor 的操作都可以移植到这里</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 当第一次执行完毕后 就和另一句的代码是相同的效果了</span></span><br></pre></td></tr></table></figure><p>useState-setState</p><p>也许很多人 在使用 class 的 setState 时候,会经常使用他的回调函数,</p><p>但是这里很遗憾,他只接受新的值,如果想要对应的回调,可以使用useEffect,这个问题等会会提供一个跳转链接</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>useState 是一个内置的 React Hook。useState(0) 返回一个元组，其中第一个参数count是计数器的当前状态，setCounter 提供更新计数器状态的方法。</p><p>咱们可以在任何地方使用setCounter方法更新计数状态-在这种情况下，咱们在setCount函数内部使用它可以做更多的事情，使用 Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。</p><h2 id="React中的StrictMode是什么？"><a href="#React中的StrictMode是什么？" class="headerlink" title="React中的StrictMode是什么？"></a>React中的StrictMode是什么？</h2><p>React的<code>StrictMode</code>是一种帮助程序组件，可以帮助您编写更好的react组件，您可以使用包装一些组件， <code>&lt;StrictMode /&gt; </code>并且基本上可以：</p><ul><li>验证内部组件是否遵循某些推荐做法，如果不在控制台中，则会发出警告。</li><li>验证不赞成使用的方法，如果使用了严格模式，则会在控制台中警告您。</li><li>通过识别潜在风险来帮助您预防某些副作用。</li></ul><h2 id="为什么类方法需要绑定？"><a href="#为什么类方法需要绑定？" class="headerlink" title="为什么类方法需要绑定？"></a>为什么类方法需要绑定？</h2><p>在<code>JavaScript</code>中，<code>this</code>的值取决于当前上下文。在<code>React</code>类的组件方法中，开发人员通常希望它引用组件的当前实例，因此有必要 将 这些方法 绑定 到该实例。通常，这是在构造函数中完成的，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubmitButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      isFormSubmitted: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.handleSubmit = <span class="built_in">this</span>.handleSubmit.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit() &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      isFormSubmitted: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleSubmit&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="描述Flux与MVC？"><a href="#描述Flux与MVC？" class="headerlink" title="描述Flux与MVC？"></a>描述Flux与MVC？</h2><p>传统的MVC模式在分离数据（模型），UI（视图）和逻辑（控制器）的关注方面效果很好，但是MVC架构经常遇到两个主要问题：</p><p>数据流定义不佳： 跨视图进行的级联更新通常会导致纠结的事件网，难以调试。<br>缺乏数据完整性： 可以从任何地方对模型数据进行突变，从而在整个UI上产生不可预测的结果。<br>使用Flux模式，复杂的UI不再受到级联更新的困扰。任何给定的React组件都将能够根据商店提供的数据重建其状态。Flux模式还通过限制对共享数据的直接访问来增强数据完整性。</p><h2 id="React-context是什么？"><a href="#React-context是什么？" class="headerlink" title="React context是什么？"></a>React context是什么？</h2><p>React文档官网并未对 Context 给出“是什么”的定义，更多是描述使用的 Context 的场景，以及如何使用 Context 。</p><p>官网对于使用 Context 的场景是这样描述的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In Some Cases, you want to pass data through the component tree without having to pass the props down manuallys at every level. you can do this directly in React with the powerful &quot;context&quot; API.</span><br></pre></td></tr></table></figure><p>简单说就是，当你不想在组件树中通过逐层传递 props 或者 state 的方式来传递数据时，可以使用 Context 来实现 跨层级 的组件数据传递。<br>使用props或者state传递数据，数据自顶下流。</p><p>Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。</p><h2 id="什么是-prop-drilling，如何避免？"><a href="#什么是-prop-drilling，如何避免？" class="headerlink" title="什么是 prop drilling，如何避免？"></a>什么是 prop drilling，如何避免？</h2><p>在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 prop 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做prop drilling。</p><p>prop drilling的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。</p><p>为了避免prop drilling，一种常用的方法是使用React Context。通过定义提供数据的Provider组件，并允许嵌套的组件通过Consumer组件或useContext Hook 使用上下文数据。</p><p>使用 Context ，可以跨越组件进行数据传递。</p><p>:link: 资料来源： github.com/WebPredict</p><p>Q22 ：React Fiber是什么？<br>难度：:star::star::star::star:</p><p>React Fiber 并不是所谓的纤程（微线程、协程），而是一种基于浏览器的单线程调度算法，背后的支持 API 是大名鼎鼎的：requestIdleCallback。</p><p>Fiberl是一种将 recocilation （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。</p><h2 id="这段代码有什么问题吗？"><a href="#这段代码有什么问题吗？" class="headerlink" title="这段代码有什么问题吗？"></a>这段代码有什么问题吗？</h2><p>这段代码有什么问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.setState((prevState, props) &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    streak: prevState.streak + props.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>答案：</p><p>没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给setState，该函数接收上一个 state的值和当前的props，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式。</p><h2 id="如何有条件地向-React-组件添加属性？"><a href="#如何有条件地向-React-组件添加属性？" class="headerlink" title="如何有条件地向 React 组件添加属性？"></a>如何有条件地向 React 组件添加属性？</h2><p>主题: React<br>难度: ⭐⭐⭐⭐<br>对于某些属性，React 非常聪明，如果传递给它的值是虚值，可以省略该属性。例如：</p><p>var InputComponent = React.createClass({<br>    render: function() {<br>      var required = true;<br>      var disabled = false;</p><pre><code>  return (    &lt;input type=&quot;text&quot; disabled=&#123;disabled&#125; required=&#123;required&#125; /&gt;  );&#125;</code></pre><p>});<br>渲染结果：</p><input type="text" required>另一种可能的方法是：<p>var condition = true;</p><p>var component = (<br>  &lt;div<br>    value=”foo”<br>    { …( condition &amp;&amp; { disabled: true } ) } /&gt;<br>);<br>问题 Hooks会取代 render props 和高阶组件吗？</p><p>通常，render props和高阶组件仅渲染一个子组件。React团队认为，Hooks 是服务此用例的更简单方法。</p><p>这两种模式仍然有一席之地(例如，一个虚拟的 scroller 组件可能有一个 renderItem prop，或者一个可视化的容器组件可能有它自己的 DOM 结构)。但在大多数情况下，Hooks 就足够了，可以帮助减少树中的嵌套。</p><h2 id="如何避免组件的重新渲染？"><a href="#如何避免组件的重新渲染？" class="headerlink" title="如何避免组件的重新渲染？"></a>如何避免组件的重新渲染？</h2><p>React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：</p><p>React.memo():这可以防止不必要地重新渲染函数组件<br>PureComponent:这可以防止不必要地重新渲染类组件<br>这两种方法都依赖于对传递给组件的props的浅比较，如果 props 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。</p><p>通过使用 React Profiler，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。</p><h2 id="什么是纯函数？"><a href="#什么是纯函数？" class="headerlink" title="什么是纯函数？"></a>什么是纯函数？</h2><p>纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。</p><h2 id="当调用setState时，React-render-是如何工作的？"><a href="#当调用setState时，React-render-是如何工作的？" class="headerlink" title="当调用setState时，React render 是如何工作的？"></a>当调用setState时，React render 是如何工作的？</h2><p>咱们可以将”render”分为两个步骤：</p><p>虚拟 DOM 渲染:当render方法被调用时，它返回一个新的组件的虚拟 DOM 结构。当调用setState()时，render会被再次调用，因为默认情况下shouldComponentUpdate总是返回true，所以默认情况下 React 是没有优化的。<br>原生 DOM 渲染:React 只会在虚拟DOM中修改真实DOM节点，而且修改的次数非常少——这是很棒的React特性，它优化了真实DOM的变化，使React变得更快。</p><h2 id="如何避免在React重新绑定实例？"><a href="#如何避免在React重新绑定实例？" class="headerlink" title="如何避免在React重新绑定实例？"></a>如何避免在React重新绑定实例？</h2><p>有几种常用方法可以避免在 React 中绑定方法：</p><p>1.将事件处理程序定义为内联箭头函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubmitButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      isFormSubmitted: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123; <span class="attr">isFormSubmitted</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">      &#125;&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用箭头函数来定义方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubmitButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    isFormSubmitted: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      isFormSubmitted: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handleSubmit&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.使用带有 Hooks 的函数组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SubmitButton = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [isFormSubmitted, setIsFormSubmitted] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setIsFormSubmitted(<span class="literal">true</span>);</span><br><span class="line">    &#125;&#125;&gt;Submit&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>五.前端框架（复习指引）<br>该章节，本计划列出所有知识点。后续发现有很多好文，再加上笔者时间不足，<br>避免本文没了下文，笔者做一个简单的指引。（该章节后续有时间，会单独出文章，时间暂不确定，有兴趣就期待吧）<br>1）Vue</p><p>前端森林：juejin.im/post/684490…<br>童欧巴：juejin.im/post/684490…<br>Coderfei：juejin.im/post/684490…<br>卞卞村长：juejin.im/post/684490…</p><p>2）React</p><p>骑着蜗牛逛妓院：juejin.im/post/684490…<br>RNG牛逼 ：segmentfault.com/a/119000001…<br>JAVA进阶之路：zhuanlan.zhihu.com/p/91725031</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对React面试 的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;使用React-Hooks有什么优势？&quot;&gt;&lt;a href=&quot;#使用React-Hooks有什么优势？&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="面试  React" scheme="http://github.com/categories/%E9%9D%A2%E8%AF%95-React/"/>
    
    
      <category term="面试  React" scheme="http://github.com/tags/%E9%9D%A2%E8%AF%95-React/"/>
    
  </entry>
  
  <entry>
    <title>面试宝典之VueAPI面试篇</title>
    <link href="http://github.com/2021/03/05/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVueAPI%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    <id>http://github.com/2021/03/05/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVueAPI%E9%9D%A2%E8%AF%95%E7%AF%87/</id>
    <published>2021-03-04T16:00:00.000Z</published>
    <updated>2021-03-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="v-show-和-v-if指令的共同点和不同点"><a href="#v-show-和-v-if指令的共同点和不同点" class="headerlink" title="v-show 和 v-if指令的共同点和不同点"></a>v-show 和 v-if指令的共同点和不同点</h2><p>共同点： 都能控制元素的显示和隐藏；</p><p>不同点：</p><ol><li><p>实现本质方法不同</p><ul><li>v-show： 本质就是通过控制 css 中的 display 设置为 none，控制隐藏，只会编译一次；</li><li>v-if： 是动态的向 DOM 树内添加或者删除 DOM 元素，若初始值为 false ，就不会编译了。而且 v-if 不停的销毁和创建比较消耗性能。</li></ul></li><li><p>总结<br>如果要频繁切换某节点，使用 v-show (切换开销比较小，初始开销较大)。如果不需要频繁切换某节点使用 v-if（初始渲染开销较小，切换开销比较大）。</p></li></ol><h2 id="为什么使用key-Key-的作用是什么？可以用数组的-index（下标）代替么？（美团）"><a href="#为什么使用key-Key-的作用是什么？可以用数组的-index（下标）代替么？（美团）" class="headerlink" title="为什么使用key? Key 的作用是什么？可以用数组的 index（下标）代替么？（美团）"></a>为什么使用key? Key 的作用是什么？可以用数组的 index（下标）代替么？（美团）</h2><p>使用 key 来给每个节点做一个唯一标识， Diff 算法就可以正确的识别此节点</p><ol><li>key 的作用主要是为了高效的更新虚拟 DOM。另外 vue 中在使用相同标签<br>名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以<br>区分它们。否则 vue 只会替换其内部属性而不会触发过渡效果</li><li>key 不能用 index 代替，index 在同一个页面会有重复的情况，违背了高效<br>渲染的初衷。</li></ol><h2 id="v-model中的实现原理及如何自定义v-model"><a href="#v-model中的实现原理及如何自定义v-model" class="headerlink" title="v-model中的实现原理及如何自定义v-model"></a>v-model中的实现原理及如何自定义<code>v-model</code></h2><ol><li><code>v-model</code> 可以看成是 <code>value</code>+<code>input</code> 方法的语法糖（组件）。</li><li>原生的 v-model ，会根据标签的不同生成不同的事件与属性。解析一个指令来。</li><li>自定义：自己写 <code>model</code> 属性，里面放上 <code>prop</code> 和 <code>event</code></li></ol><h2 id="如何让CSS只在当前组件中起作用"><a href="#如何让CSS只在当前组件中起作用" class="headerlink" title="如何让CSS只在当前组件中起作用?"></a>如何让CSS只在当前组件中起作用?</h2><p>在组件中的 style 前面加上 scoped</p><h2 id="请说出vue-cli项目中src目录每个文件夹和文件的用法"><a href="#请说出vue-cli项目中src目录每个文件夹和文件的用法" class="headerlink" title="请说出vue.cli项目中src目录每个文件夹和文件的用法"></a>请说出vue.cli项目中src目录每个文件夹和文件的用法</h2><ul><li>assets 文件夹是放静态资源；</li><li>components 是放组件；</li><li>router 是定义路由相关的配置;</li><li>app.vue 是一个应用主组件；</li><li>main.js 是入口文件。</li></ul><h2 id="vue组件中data为什么必须是一个函数"><a href="#vue组件中data为什么必须是一个函数" class="headerlink" title="vue组件中data为什么必须是一个函数"></a>vue组件中data为什么必须是一个函数</h2><p>避免组件中的数据互相影响。<br><br>因为组件是用来复用的，并且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离性，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p><h2 id="为什么要使用异步组件？"><a href="#为什么要使用异步组件？" class="headerlink" title="为什么要使用异步组件？"></a>为什么要使用异步组件？</h2><ol><li>节省打包出的结果，异步组件分开打包，采用 jsonp 的方式进行加载，有效解决文件过大的问题。</li><li>核心就是包组件定义变成一个函数，依赖 import（） 语法，可以实现文件的分割加载。</li></ol><h2 id="谈谈对-keep-alive-的了解"><a href="#谈谈对-keep-alive-的了解" class="headerlink" title="谈谈对 keep-alive 的了解"></a>谈谈对 keep-alive 的了解</h2><ol><li>keep-alive 是 Vue 内置的一个组件，可以实现组件的缓存，当组件切换时不会对当前组件进行卸载。</li><li>常用的 2 个属性 include/exclude，允许组件有条件的进行缓存 3. 2 个生命周期 activated ， deactivated，用来得知当前组件是否处于活跃状态。</li><li>keep-alive 的中还运用了 LRU(Least Recently Used)算法。</li></ol><h2 id="Computed-watch-和-method-简述computed和watch的使用场景"><a href="#Computed-watch-和-method-简述computed和watch的使用场景" class="headerlink" title="Computed watch 和 method, 简述computed和watch的使用场景"></a>Computed watch 和 method, 简述computed和watch的使用场景</h2><ul><li>computed：本质是一个具备缓存的 watcher，只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。适用于计算比较消耗性能的计算场景</li><li>watch:  没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用 watch。<br>深度监听&gt; deep：true,会带来性能问题, 优化的话可以使用字符串形式监听</li><li>method：只要把方法用到模板上了,每次一变化就会重新渲染视图，性能开销大</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>computed : 当一个属性受多个属性影响的时候就需要用到 computed <br>最典型的栗子：购物车商品结算的时候</li><li>watch : 当一条数据影响多条数据的时候就需要用 watch <br>栗子：搜索数据</li></ol><h2 id="v-if和v-for的优先级"><a href="#v-if和v-for的优先级" class="headerlink" title="v-if和v-for的优先级"></a>v-if和v-for的优先级</h2><p>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。所以，不推荐 v-if 和 v-for 同时使用。<br><br>如果 v-if 和 v-for 一起用的话，vue中的的会自动提示 v-if 应该放到外层去。</p><h2 id="assets和static的区别"><a href="#assets和static的区别" class="headerlink" title="assets和static的区别"></a>assets和static的区别</h2><ol><li><p>相同点<br>assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下</p></li><li><p>不相同点</p><ul><li>assets<br>assets中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。</li><li>static<br>static中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</li></ul></li><li><p>建议<br>将项目中 template需要的样式文件js文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css </code>等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传。</p></li></ol><h2 id="说出几种vue当中的指令和它的用法？"><a href="#说出几种vue当中的指令和它的用法？" class="headerlink" title="说出几种vue当中的指令和它的用法？"></a>说出几种vue当中的指令和它的用法？</h2><ul><li>v-model 双向数据绑定；</li><li>v-for 循环；</li><li>v-if v-show 显示与隐藏；</li><li>v-on 事件；v-once : 只绑定一次。</li></ul><h2 id="vue-loader是什么？使用它的用途有哪些？"><a href="#vue-loader是什么？使用它的用途有哪些？" class="headerlink" title="vue-loader是什么？使用它的用途有哪些？"></a>vue-loader是什么？使用它的用途有哪些？</h2><p>vue 文件的一个加载器，将 template/js/style 转换成 js 模块。</p><p>用途：js 可以写 es6 、 style样式可以 scss 或 less 、 template 可以加 jade等</p><h2 id="v-on可以监听多个方法"><a href="#v-on可以监听多个方法" class="headerlink" title="v-on可以监听多个方法"></a>v-on可以监听多个方法</h2><p>栗子：<code>&lt;input type=&quot;text&quot; v-on=&quot;&#123; input:onInput,focus:onFocus,blur:onBlur, &#125;&quot;&gt;</code></p><h2 id="了解-nextTick-吗？"><a href="#了解-nextTick-吗？" class="headerlink" title="了解 nextTick 吗？"></a>了解 nextTick 吗？</h2><p>在下次 DOM 更新循环结束之后执行延迟回调</p><p>Vue的nextTick其本质上是对JS执行原理EventLoop的一种应用</p><p>nextTick的核心应用：Promise、MutationObserver、setImmediate、setTimeout的原生JS的方法来模拟对应的微/宏任务的实现，本质时是为了利用JS的这些异步回调任务队列来实现Vue框架中自己的异步回调队列</p><p>nextTick不仅是Vue内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对DOM更新数据时的后续逻辑处理</p><p>nextTick是典型的将底层JS执行原理应用到具体案例中的示例</p><h2 id="nextTick的使用"><a href="#nextTick的使用" class="headerlink" title="$nextTick的使用"></a>$nextTick的使用</h2><p>当你修改了data 的值然后马上获取这个 dom 元素的值，是不能获取到更新后的值， 你需要使用 $nextTick 这个回调，让修改后的 data 值渲染更新到 dom 元素之后在获取，才能成功。</p><h2 id="v-html-会导致哪些问题"><a href="#v-html-会导致哪些问题" class="headerlink" title="v-html 会导致哪些问题"></a>v-html 会导致哪些问题</h2><ol><li>XSS 攻击</li><li>v-html 会替换标签内部的元素</li></ol><h2 id="vue常用的修饰符"><a href="#vue常用的修饰符" class="headerlink" title="vue常用的修饰符"></a>vue常用的修饰符</h2><ol><li><p>.stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；</p></li><li><p>.prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</p></li><li><p>.capture ：与事件冒泡的方向相反，事件捕获由外到内；</p></li><li><p>.self ：只会触发自己范围内的事件，不包含子元素；</p></li><li><p>.once ：只会触发一次</p></li></ol><h2 id="引进组件的步骤"><a href="#引进组件的步骤" class="headerlink" title="引进组件的步骤"></a>引进组件的步骤</h2><ol><li>在template中引入组件；</li><li>在script的第一行用import引入路径；</li><li>用component中写上组件名称。</li></ol><h2 id="delete和Vue-delete删除数组的区别"><a href="#delete和Vue-delete删除数组的区别" class="headerlink" title="delete和Vue.delete删除数组的区别"></a>delete和Vue.delete删除数组的区别</h2><p>delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。<br><br>Vue.delete 直接删除了数组 改变了数组的键值。</p><h2 id="vue-slot"><a href="#vue-slot" class="headerlink" title="vue slot"></a>vue slot</h2><p>简单来说，假如父组件需要在子组件内放一些DOM，那么这些DOM是显示、不显示、在哪个地方显示、如何显示，就是slot分发负责的活。</p><h2 id="插槽与作用域插槽的区别"><a href="#插槽与作用域插槽的区别" class="headerlink" title="插槽与作用域插槽的区别"></a>插槽与作用域插槽的区别</h2><ol><li><p>插槽</p><ul><li><p>创建组件虚拟节点时，会将组件儿子的虚拟节点保存起来。当初始化组件时，通过插槽属性将儿子进行分类 <code>&#123;a:[vnode],b[vnode]&#125;</code></p></li><li><p>渲染组件时会拿对应的 slot 属性的节点进行替换操作。（插槽的作用域为父组件）</p></li></ul></li><li><p>作用域插槽</p><ul><li><p>作用域插槽在解析的时候不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。</p></li><li><p>普通插槽渲染的作用域是父组件，作用域插槽的渲染作用域是当前子组件。</p></li></ul></li></ol><h2 id="slot是什么？有什么作用？原理是什么？"><a href="#slot是什么？有什么作用？原理是什么？" class="headerlink" title="slot是什么？有什么作用？原理是什么？"></a>slot是什么？有什么作用？原理是什么？</h2><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。<br>slot又分三类，默认插槽，具名插槽和作用域插槽。</p><p>默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。<br>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。<br>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</p><p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h2 id="请说下封装-vue-组件的过程？"><a href="#请说下封装-vue-组件的过程？" class="headerlink" title="请说下封装 vue 组件的过程？"></a>请说下封装 vue 组件的过程？</h2><ol><li><p>建立组件的模板，先把架子搭起来，写写样式，考虑好组件的基本逻辑。(os：思考1小时，码码10分钟，程序猿的准则。) 　　</p></li><li><p>准备好组件的数据输入。即分析好逻辑，定好 props 里面的数据、类型。　　</p></li><li><p>准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法。　　</p></li><li><p>封装完毕了，直接调用即可</p></li></ol><h2 id="vue-中相同逻辑如何抽离"><a href="#vue-中相同逻辑如何抽离" class="headerlink" title="vue 中相同逻辑如何抽离"></a>vue 中相同逻辑如何抽离</h2><p>考察 vue.mixin 用法，给组件每个生命周期，函数都混入一些公共逻辑</p><h2 id="vue修改打包后静态资源路径的修改"><a href="#vue修改打包后静态资源路径的修改" class="headerlink" title="vue修改打包后静态资源路径的修改"></a>vue修改打包后静态资源路径的修改</h2><p>cli2 版本：将 config/index.js 里的 assetsPublicPath 的值改为  ./  。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build: &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  assetsPublicPath:  .&#x2F; ,</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cli3版本：在根目录下新建vue.config.js 文件，然后加上以下内容：（如果已经有此文件就直接修改）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  publicPath: , &#x2F;&#x2F; 相对于 HTML 页面（目录相同）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="那template和jsx的有什么分别？"><a href="#那template和jsx的有什么分别？" class="headerlink" title="那template和jsx的有什么分别？"></a>那template和jsx的有什么分别？</h2><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。<br>在 webpack 中，我们使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。<br>与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。<br>所以，template和jsx的都是render的一种表现形式，不同的是：<br>JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p><h2 id="什么是-vue-生命周期？有什么作用？"><a href="#什么是-vue-生命周期？有什么作用？" class="headerlink" title="什么是 vue 生命周期？有什么作用？"></a>什么是 vue 生命周期？有什么作用？</h2><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会。（ps：生命周期钩子就是生命周期函数）例如，如果要通过某些插件操作DOM节点，如想在页面渲染完后弹出广告窗， 那我们最早可在mounted 中进行。</p><h2 id="第一次页面加载会触发哪几个钩子？"><a href="#第一次页面加载会触发哪几个钩子？" class="headerlink" title="第一次页面加载会触发哪几个钩子？"></a>第一次页面加载会触发哪几个钩子？</h2><p>答：beforeCreate， created， beforeMount， mounted</p><h2 id="介绍一下Vue的生命周期"><a href="#介绍一下Vue的生命周期" class="headerlink" title="介绍一下Vue的生命周期"></a>介绍一下Vue的生命周期</h2><ol><li>beforeCreate：是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。</li><li>created：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</li><li>beforeMount：发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。</li><li>mounted：在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。</li><li>beforeUpdate：发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</li><li>updated：发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</li><li>beforeDestroy：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</li><li>destroyed：发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</li></ol><h2 id="组件之间是怎么通信的"><a href="#组件之间是怎么通信的" class="headerlink" title="组件之间是怎么通信的"></a>组件之间是怎么通信的</h2><ol><li>父子组件通信</li></ol><p>父组件 -&gt; 子组件：prop<br>子组件 -&gt; 父组件：$on/$emit<br>获取组件实例：使用$parent/$children，$refs.xxx，获取到实例后直接获取属性数据或调用组件方法</p><ol start="2"><li>兄弟组件通信</li></ol><p>Event Bus：每一个Vue实例都是一个Event Bus，都支持$on/$emit，可以为兄弟组件的实例之间new一个Vue实例，作为Event Bus进行通信。<br>Vuex：将状态和方法提取到Vuex，完成共享</p><ol start="3"><li>跨级组件通信</li></ol><p>使用provide/inject<br>provide / inject 适用于 隔代组件通信 祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。<br>。</p><ol start="4"><li>attrs/listeners 适用于 隔代组件通信</li></ol><p>attrs: 包含了父作用域中不被prop所识别(且获取)的特性绑定(class和style除外)。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定(class和style除外)，并且可以通过v−bind=”attrs:包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过v-bind=”attrs:包含了父作用域中不被prop所识别(且获取)的特性绑定(class和style除外)。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定(class和style除外)，并且可以通过v−bind=”attrs”传入内部组件。通常配合inheritAttrs选项一起使用。</p><p>listeners: 包含了父作用域中的(不含.native修饰器的)v−on事件监听器。它可以通过v−on=”listeners:包含了父作用域中的 (不含 .native 修饰器的) v-on事件监听器。它可以通过v-on=”listeners:包含了父作用域中的(不含.native修饰器的)v−on事件监听器。它可以通过v−on=”listeners”传入内部组件</p><p>Vuex 适用于 父子、隔代、兄弟组件通信。Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p><h2 id="说一下Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#说一下Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="说一下Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>说一下Vue 的父组件和子组件生命周期钩子函数执行顺序？</h2><p>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。<br>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p><ol><li><p>加载渲染过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</span><br></pre></td></tr></table></figure></li><li><p>子组件更新过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</span><br></pre></td></tr></table></figure></li><li><p>父组件更新过程<br><code>父 beforeUpdate -&gt; 父 updated</code></p></li><li><p>销毁过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</span><br></pre></td></tr></table></figure><h2 id="子组件可以直接改变父组件的数据么？说说你的理由？"><a href="#子组件可以直接改变父组件的数据么？说说你的理由？" class="headerlink" title="子组件可以直接改变父组件的数据么？说说你的理由？"></a>子组件可以直接改变父组件的数据么？说说你的理由？</h2></li></ol><p>主要是为了维护父子组件的单向数据流</p><p>每次父组件发生更新时，子组件中所有的prop都将会刷新为最新的值<br>如果这样做的话，Vue会在浏览器控制台中发出警告<br>Vue提倡单向数据流，即父级props的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件的状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破环了单向数据流，当应用复杂情况时，debug的成本会非常高<br>只有通过$emit派发一个自定义事件，父组件接收后，由父组件修改.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;v-show-和-v-if指令的共同点和不同点&quot;&gt;&lt;a href=&quot;#v-show-和-v-if指令的共同点和不同点&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="面试 Vue" scheme="http://github.com/categories/%E9%9D%A2%E8%AF%95-Vue/"/>
    
    
      <category term="面试 Vue" scheme="http://github.com/tags/%E9%9D%A2%E8%AF%95-Vue/"/>
    
  </entry>
  
  <entry>
    <title>面试宝典之Vue路由&amp;vuex面试篇</title>
    <link href="http://github.com/2021/03/04/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVue%E8%B7%AF%E7%94%B1&amp;vuex%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    <id>http://github.com/2021/03/04/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVue%E8%B7%AF%E7%94%B1&amp;vuex%E9%9D%A2%E8%AF%95%E7%AF%87/</id>
    <published>2021-03-03T16:00:00.000Z</published>
    <updated>2021-03-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h2><h3 id="vue-router的原理"><a href="#vue-router的原理" class="headerlink" title="vue-router的原理"></a>vue-router的原理</h3><p>实现原理：vue-router的原理就是更新视图而不重新请求页面</p><h3 id="vue-router-是什么-它有哪些组件"><a href="#vue-router-是什么-它有哪些组件" class="headerlink" title="vue-router 是什么?它有哪些组件"></a>vue-router 是什么?它有哪些组件</h3><p>vue用来写路由一个插件。router-link、router-view</p><h3 id="active-class-是哪个组件的属性？"><a href="#active-class-是哪个组件的属性？" class="headerlink" title="active-class 是哪个组件的属性？"></a>active-class 是哪个组件的属性？</h3><p>vue-router模块的router-link组件。children数组来定义子路由</p><h3 id="怎么定义-vue-router-的动态路由-怎么获取传过来的值？"><a href="#怎么定义-vue-router-的动态路由-怎么获取传过来的值？" class="headerlink" title="怎么定义 vue-router 的动态路由? 怎么获取传过来的值？"></a>怎么定义 vue-router 的动态路由? 怎么获取传过来的值？</h3><p>在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id。</p><h3 id="vue-router-有哪几种导航钩子"><a href="#vue-router-有哪几种导航钩子" class="headerlink" title="vue-router 有哪几种导航钩子?"></a>vue-router 有哪几种导航钩子?</h3><ol><li><p>全局的钩子函数 beforeEach 和 afterEach</p><p> beforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数</p></li><li><p>单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的</p></li><li><p>组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组件内部直接进行定义的</p></li></ol><h3 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和 $router 的区别"></a><code>$route</code> 和 <code>$router</code> 的区别</h3><ol><li><p>$router 是VueRouter的实例，在script标签中想要导航到不同的URL,使用 $router.push 方法。返回上一个历史history用 $router.to(-1)</p></li><li><p>$route 为当前router跳转对象。里面可以获取当前路由的name,path,query,parmas等。</p></li></ol><h3 id="vue-router的两种模式"><a href="#vue-router的两种模式" class="headerlink" title="vue-router的两种模式"></a>vue-router的两种模式</h3><ol><li><p>hash模式： 即地址栏 URL 中的 # 符号；</p></li><li><p>history模式： window.history对象打印出来可以看到里边提供的方法和记录长度。利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）。</p></li></ol><h3 id="能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h3><h3 id="hash模式的实现原理"><a href="#hash模式的实现原理" class="headerlink" title="hash模式的实现原理"></a>hash模式的实现原理</h3><ol><li><p>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；</p></li><li><p>使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值。我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）</p><h3 id="history-模式的实现原理"><a href="#history-模式的实现原理" class="headerlink" title="history 模式的实现原理"></a>history 模式的实现原理</h3><p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.replaceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录.<br>使用 popstate 事件来监听 url 的变化，从而对页面进行跳转(渲染)<br>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）</p></li></ol><h3 id="vue-router实现路由懒加载（-动态加载路由-）"><a href="#vue-router实现路由懒加载（-动态加载路由-）" class="headerlink" title="vue-router实现路由懒加载（ 动态加载路由 ）"></a>vue-router实现路由懒加载（ 动态加载路由 ）</h3><p>答:三种方式</p><p>第一种： vue异步组件技术 ==== 异步加载，vue-router配置路由 , 使用vue的异步组件技术 , 可以实现按需加载 .但是,这种情况下一个组件生成一个js文件。</p><p>第二种： 路由懒加载(使用import)。</p><p>第三种： webpack提供的require.ensure()，vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p><h3 id="params和query的区别"><a href="#params和query的区别" class="headerlink" title=".params和query的区别"></a>.params和query的区别</h3><p>答：用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 this.$route.query.name 和 this.$route.params.name 。url地址显示：query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p><p>注意点：query刷新不会丢失query里面的数据 params刷新 会 丢失 params里面的数据。</p><h2 id="RouterLink在IE和Firefox中不起作用（路由不跳转）的问题"><a href="#RouterLink在IE和Firefox中不起作用（路由不跳转）的问题" class="headerlink" title="RouterLink在IE和Firefox中不起作用（路由不跳转）的问题"></a>RouterLink在IE和Firefox中不起作用（路由不跳转）的问题</h2><p>方法一：只用a标签，不适用button标签；方法二：使用button标签和Router.navigate方法</p><h2 id="Vue2中注册在router-link上事件无效解决方法"><a href="#Vue2中注册在router-link上事件无效解决方法" class="headerlink" title="Vue2中注册在router-link上事件无效解决方法"></a>Vue2中注册在router-link上事件无效解决方法</h2><p>使用 @click.native 。原因：router-link会阻止click事件，.native指直接监听一个原生事件。</p><h2 id="Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？"><a href="#Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？" class="headerlink" title="Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？"></a>Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？</h2><p>Vue路由在Android机上有问题，babel问题，安装babel polypill插件解决。</p><h2 id="Vue-router跳转和location-href有什么区别"><a href="#Vue-router跳转和location-href有什么区别" class="headerlink" title="Vue-router跳转和location.href有什么区别"></a>Vue-router跳转和location.href有什么区别</h2><p>使用 location.href= /url 来跳转，简单方便，但是刷新了页面；使用 history.pushState( /url ) ，无刷新页面，静态跳转；引进 router ，然后使用 router.push( /url ) 来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 history.pushState() 没什么差别的，因为vue-router就是用了 history.pushState() ，尤其是在history模式下。</p><h2 id="vuex常见面试题篇"><a href="#vuex常见面试题篇" class="headerlink" title="vuex常见面试题篇"></a>vuex常见面试题篇</h2><h3 id="vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex是什么？怎么使用？哪种功能场景使用它？"></a>vuex是什么？怎么使用？哪种功能场景使用它？</h3><p>vue框架中状态管理。在main.js引入store，注入。</p><p>新建了一个目录<code>store.js</code>，<code>….. export</code> 。</p><p>场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p><h3 id="vuex有哪几种属性？"><a href="#vuex有哪几种属性？" class="headerlink" title="vuex有哪几种属性？"></a>vuex有哪几种属性？</h3><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p><p>state =&gt; 基本数据(数据源存放地)</p><p>getters =&gt; 从基本数据派生出来的数据</p><p>mutations =&gt; (同步)提交更改数据的方法，修改state的,并且修改state的唯一途径就是提交mutation mutation中定义一系列方法，对state进行修改</p><p>actions =&gt; 像一个装饰器，包裹mutations，使之可以异步。</p><p>modules =&gt; 模块化Vuex</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>Vuex 中说白了，任何的操作都是围绕 state 来进行的，Vuex 是状态管理器，作用就是管理 state 中的状态，其他提供的所有功能 Getter、Mutation、Action 都是为了能够更好的管理 state，而之所以设计成期望通过 Mutation 改变状态，是因为我们期望所有状态的变化都是有迹可循的！</p><h3 id="Vue-js中ajax请求代码应该写在组件的methods中还是vuex的actions中？"><a href="#Vue-js中ajax请求代码应该写在组件的methods中还是vuex的actions中？" class="headerlink" title="Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？"></a>Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？</h3><p>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</p><p>如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;vue路由&quot;&gt;&lt;a href=&quot;#vue路由&quot; class=&quot;headerlink&quot; title=&quot;vue路由&quot;&gt;&lt;/a&gt;vue路由&lt;/h2&gt;&lt;h
      
    
    </summary>
    
    
      <category term="面试 Vue" scheme="http://github.com/categories/%E9%9D%A2%E8%AF%95-Vue/"/>
    
    
      <category term="面试 Vue" scheme="http://github.com/tags/%E9%9D%A2%E8%AF%95-Vue/"/>
    
  </entry>
  
  <entry>
    <title>面试宝典之Vue原理面试篇</title>
    <link href="http://github.com/2021/03/02/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVue%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    <id>http://github.com/2021/03/02/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E4%B9%8BVue%E5%8E%9F%E7%90%86%E9%9D%A2%E8%AF%95%E7%AF%87/</id>
    <published>2021-03-01T16:00:00.000Z</published>
    <updated>2021-03-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><blockquote><p>Vue 借鉴了 angular 的模板和数据绑定技术，又借鉴了 react 的组件化和虚拟 DOM 技术</p></blockquote><h2 id="首先谈谈你对-Vue-的理解"><a href="#首先谈谈你对-Vue-的理解" class="headerlink" title="首先谈谈你对 Vue 的理解"></a>首先谈谈你对 Vue 的理解</h2><ul><li><p>渐进式 JavaScript 框架、核心库加插件、动态创建用户界面（异步获取后台数据，数据展示在界面）</p></li><li><p>特点： MVVM 模式；代码简洁体积小，运行效率高，适合移动 PC 端开发；本身只关注 UI （和 react 相似），可以轻松引入 Vue 插件或其他的第三方库进行开发。</p></li></ul><h2 id="渐进式框架的理解"><a href="#渐进式框架的理解" class="headerlink" title="渐进式框架的理解"></a>渐进式框架的理解</h2><ul><li>主张最少；</li><li>可以根据不同的需求选择不同的层级；</li></ul><h2 id="vue优点"><a href="#vue优点" class="headerlink" title="vue优点"></a>vue优点</h2><ul><li><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；</p></li><li><p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p></li><li><p>双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；</p></li><li><p>组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；</p></li><li><p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p></li><li><p>虚拟DOM：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；</p></li><li><p>运行速度更快：相比较于 react 而言，同样是操作虚拟 dom ，就性能而言， vue 存在很大的优势</p></li></ul><h2 id="说下MVVM"><a href="#说下MVVM" class="headerlink" title="说下MVVM"></a>说下MVVM</h2><p>全称：Model-View-ViewModel ，<br>Model 表示数据模型层。view 表示视图层， ViewModel 是 View 和 Model 层的桥梁，数据绑定到 viewModel 层并自动渲染到页面中，视图变化通知 viewModel 层更新数据。</p><h2 id="vue和jQuery的区别"><a href="#vue和jQuery的区别" class="headerlink" title="vue和jQuery的区别"></a>vue和jQuery的区别</h2><p>jQuery是使用选择器（ $ ）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。<br>比如需要获取label标签的内容：$(“lable”).val(); ,它还是依赖DOM元素的值。Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。</p><h2 id="介绍一下Vue的响应式系统"><a href="#介绍一下Vue的响应式系统" class="headerlink" title="介绍一下Vue的响应式系统"></a>介绍一下Vue的响应式系统</h2><p>vue为MVVM框架，当数据模型data变化时，页面视图会得到响应更新，其原理对data的getter/setter方法进行拦截（Object.defineProperty或者Proxy），利用发布订阅的设计模式，在getter方法中进行订阅，在setter方法中发布通知，让所有订阅者完成响应。</p><h2 id="vue的两个核心点"><a href="#vue的两个核心点" class="headerlink" title="vue的两个核心点"></a>vue的两个核心点</h2><p>数据驱动、组件系统</p><p>数据驱动： ViewModel，保证数据和视图的一致性。<br><br>组件系统： 应用类UI可以看作全部是由组件树构成的。</p><h2 id="vue-的双向绑定的原理"><a href="#vue-的双向绑定的原理" class="headerlink" title="vue 的双向绑定的原理"></a>vue 的双向绑定的原理</h2><p>数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。<br><br>通过ES5提供的Object.defineProperty()方法来劫持(监视)各个属性的setter,getter，在数据变动的时发布消息给订阅者，触发相应的监听回调。并且，由于是在不同的数据上触发同步，可以精确的将变更发送发送给绑定的视图，而不是对所有的数据都执行一次检测。</p><h3 id="具体实现流程："><a href="#具体实现流程：" class="headerlink" title="具体实现流程："></a>具体实现流程：</h3><ol><li>实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者</li><li>实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图</li><li>接着，我们还需要实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</li></ol><h2 id="vue-是如何实现响应式数据"><a href="#vue-是如何实现响应式数据" class="headerlink" title="vue 是如何实现响应式数据"></a>vue 是如何实现响应式数据</h2><p>Vue2：Object.definProperty 重新定义 data 中所有的属性， Object.definProperty 可以使数据的获取与设置增加一个拦截的功能，拦截属性的获取，进行依赖收集。拦截属性的更新操作，进行通知。具体的过程：首先 Vue 使用 initData 初始化用户传入的参数，然后使用 new Observer 对数据进行观测，如果数据是一个对象类型就会调用 this.walk（value） 对对象进行处理，内部使用 defineReactive 循环对象属性定义响应式变化，核心就是使用 Object.definProperty 重新定义数据。</p><p>vue3: Proxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。</p><p>d) Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><h2 id="vue-中是如何检测数组变化"><a href="#vue-中是如何检测数组变化" class="headerlink" title="vue 中是如何检测数组变化"></a>vue 中是如何检测数组变化</h2><p>数组就是使用 object.defineProperty 重新定义数组的每一项，那能引起数组变化的方法我们都是知道的， pop 、 push 、 shift 、 unshift 、 splice 、 sort 、 reverse 这七种，只要这些方法执行改了数组内容，我就更新内容就好了，是不是很好理解。</p><p>使用了函数劫持的方式，重写了数组的方法，Vue 将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法。</p><p>这样当调用数组 api 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p><h2 id="监测数组的时候可能触发多次-get-set，那么如何防止触发多次呢？"><a href="#监测数组的时候可能触发多次-get-set，那么如何防止触发多次呢？" class="headerlink" title="监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？"></a>监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？</h2><p>我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。</p><h2 id="Vue事件绑定原理说一下"><a href="#Vue事件绑定原理说一下" class="headerlink" title="Vue事件绑定原理说一下"></a>Vue事件绑定原理说一下</h2><p>每一个Vue实例都是一个Event Bus，当子组件被创建的时候，父组件将事件传递给子组件，子组件初始化的时候是有$on方法将事件注册到内部，在需要的时候使用$emit触发函数，而对于原生native事件，使用addEventListener绑定到真实的DOM元素上。</p><h2 id="你说说-Vue-的事件绑定原理吧"><a href="#你说说-Vue-的事件绑定原理吧" class="headerlink" title="你说说 Vue 的事件绑定原理吧"></a>你说说 Vue 的事件绑定原理吧</h2><p>原生 DOM 的绑定：Vue 在创建真实 DOM 时会调用 createElm ，默认会调用 invokeCreateHooks 。会遍历当前平台下相对的属性处理代码，其中就有 updateDOMLListeners 方法，内部会传入 add（） 方法。</p><p>原生事件绑定是通过 addEventListener 绑定给真实元素的,组件事件绑定是通过 Vue 自定义的$on 实现的。</p><h2 id="vue-采用异步渲染呢？"><a href="#vue-采用异步渲染呢？" class="headerlink" title="vue 采用异步渲染呢？"></a>vue 采用异步渲染呢？</h2><p>Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 nextTick 。dep.notify（） 通知 watcher 进行更新， subs[i].update 依次调用 watcher 的 update ， queueWatcher 将 watcher 去重放入队列， nextTick（ flushSchedulerQueue ）在下一 tick 中刷新 watcher 队列（异步）。</p><h2 id="为什么要使用异步组件？"><a href="#为什么要使用异步组件？" class="headerlink" title="为什么要使用异步组件？"></a>为什么要使用异步组件？</h2><ol><li>节省打包出的结果，异步组件分开打包，采用 jsonp 的方式进行加载，有效解决文件过大的问题。</li><li>核心就是包组件定义变成一个函数，依赖 import（） 语法，可以实现文件的分割加载。</li></ol><h2 id="如何从真实-DOM-到虚拟-DOM"><a href="#如何从真实-DOM-到虚拟-DOM" class="headerlink" title="如何从真实 DOM 到虚拟 DOM"></a>如何从真实 DOM 到虚拟 DOM</h2><p>涉及到 Vue 中的模板编译原理，主要过程：</p><ol><li><p>将模板转换成 ast 树， ast 用对象来描述真实的 JS 语法（将真实 DOM 转换成虚拟 DOM）</p></li><li><p>优化树</p></li><li><p>将 ast 树生成代码</p></li></ol><h2 id="用-VNode-来描述一个-DOM-结构"><a href="#用-VNode-来描述一个-DOM-结构" class="headerlink" title="用 VNode 来描述一个 DOM 结构"></a>用 VNode 来描述一个 DOM 结构</h2><p>虚拟节点就是用一个对象来描述一个真实的 DOM 元素。首先将 template （真实 DOM）先转成 ast ， ast 树通过 codegen 生成 render 函数， render 函数里的 _c 方法将它转为虚拟 dom</p><h2 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h2><p>时间复杂度： 个树的完全 diff 算法是一个时间复杂度为 O(n*3） ，vue 进行优化转化成 O(n) 。理解：</p><p>最小量更新， key 很重要。这个可以是这个节点的唯一标识，告诉 diff 算法，在更改前后它们是同一个 DOM 节点</p><p>扩展 v-for 为什么要有 key ，没有 key 会暴力复用，举例子的话随便说一个比如移动节点或者增加节点（修改 DOM），加 key 只会移动减少操作 DOM。<br>只有是同一个虚拟节点才会进行精细化比较，否则就是暴力删除旧的，插入新的。</p><p>只进行同层比较，不会进行跨层比较。</p><p>diff 算法的优化策略：四种命中查找，四个指针</p><p>旧前与新前（先比开头，后插入和删除节点的这种情况）</p><p>旧后与新后（比结尾，前插入或删除的情况）</p><p>旧前与新后（头与尾比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧后之后）</p><p>旧后与新前（尾与头比，此种发生了，涉及移动节点，那么新前指向的节点，移动到旧前之前）</p><h2 id="Vue模板渲染的原理是什么？"><a href="#Vue模板渲染的原理是什么？" class="headerlink" title="Vue模板渲染的原理是什么？"></a>Vue模板渲染的原理是什么？</h2><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。<br>模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p><p>parse阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。<br>optimize阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。<br>generate阶段：将最终的AST转化为render函数字符串。</p><h2 id="template预编译是什么？"><a href="#template预编译是什么？" class="headerlink" title="template预编译是什么？"></a>template预编译是什么？</h2><p>对于 Vue 组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后在也不会进行编译。因此，编译对组件的 runtime 是一种性能损耗。<br>而模板编译的目的仅仅是将template转化为render function，这个过程，正好可以在项目构建的过程中完成，这样可以让实际组件在 runtime 时直接跳过模板渲染，进而提升性能，这个在项目构建的编译template的过程，就是预编译。<br>那template和jsx的有什么分别？<br>对于 runtime 来说，只需要保证组件存在 render 函数即可，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。<br>在 webpack 中，我们使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。<br>与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。<br>所以，template和jsx的都是render的一种表现形式，不同的是：<br>JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。<br>说一下什么是Virtual DOM<br>Virtual DOM 是 DOM 节点在 JavaScript 中的一种抽象数据结构，之所以需要虚拟DOM，是因为浏览器中操作DOM的代价比较昂贵，频繁操作DOM会产生性能问题。虚拟DOM的作用是在每一次响应式数据发生变化引起页面重渲染时，Vue对比更新前后的虚拟DOM，匹配找出尽可能少的需要更新的真实DOM，从而达到提升性能的目的。</p><h2 id="介绍一下Vue中的Diff算法"><a href="#介绍一下Vue中的Diff算法" class="headerlink" title="介绍一下Vue中的Diff算法"></a>介绍一下Vue中的Diff算法</h2><p>在新老虚拟DOM对比时</p><p>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换<br>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)<br>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。<br>匹配时，找到相同的子节点，递归比较子节点</p><p>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n^3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p><h2 id="说说Vue2-0和Vue3-0有什么区别"><a href="#说说Vue2-0和Vue3-0有什么区别" class="headerlink" title="说说Vue2.0和Vue3.0有什么区别"></a>说说Vue2.0和Vue3.0有什么区别</h2><p>重构响应式系统，使用Proxy替换Object.defineProperty，使用Proxy优势：</p><p>可直接监听数组类型的数据变化<br>监听的目标为对象本身，不需要像Object.defineProperty一样遍历每个属性，有一定的性能提升<br>可拦截apply、ownKeys、has等13种方法，而Object.defineProperty不行<br>直接实现对象属性的新增/删除</p><p>新增Composition API，更好的逻辑复用和代码组织<br>重构 Virtual DOM</p><p>模板编译时的优化，将一些静态节点编译成常量<br>slot优化，将slot编译为lazy函数，将slot的渲染的决定权交给子组件<br>模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）</p><p>代码结构调整，更便于Tree shaking，使得体积更小<br>使用Typescript替换Flow</p><h2 id="为什么要新增Composition-API，它能解决什么问题"><a href="#为什么要新增Composition-API，它能解决什么问题" class="headerlink" title="为什么要新增Composition API，它能解决什么问题"></a>为什么要新增Composition API，它能解决什么问题</h2><p>Vue2.0中，随着功能的增加，组件变得越来越复杂，越来越难维护，而难以维护的根本原因是Vue的API设计迫使开发者使用watch，computed，methods选项组织代码，而不是实际的业务逻辑。<br>另外Vue2.0缺少一种较为简洁的低成本的机制来完成逻辑复用，虽然可以minxis完成逻辑复用，但是当mixin变多的时候，会使得难以找到对应的data、computed或者method来源于哪个mixin，使得类型推断难以进行。<br>所以Composition API的出现，主要是也是为了解决Option API带来的问题，第一个是代码组织问题，Compostion API可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性，也就是说当下一个开发者接触这一段不是他自己写的代码时，他可以更好的利用代码的组织反推出实际的业务逻辑，或者根据业务逻辑更好的理解代码。<br>第二个是实现代码的逻辑提取与复用，当然mixin也可以实现逻辑提取与复用，但是像前面所说的，多个mixin作用在同一个组件时，很难看出property是来源于哪个mixin，来源不清楚，另外，多个mixin的property存在变量命名冲突的风险。而Composition API刚好解决了这两个问题。</p><h2 id="都说Composition-API与React-Hook很像，说说区别"><a href="#都说Composition-API与React-Hook很像，说说区别" class="headerlink" title="都说Composition API与React Hook很像，说说区别"></a>都说Composition API与React Hook很像，说说区别</h2><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p><p>不能在循环、条件、嵌套函数中调用Hook<br>必须确保总是在你的React函数的顶层调用Hook<br>useEffect、useMemo等函数必须手动确定依赖关系</p><p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p><p>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢<br>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用<br>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</p><p>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p><h2 id="SSR有了解吗？原理是什么？"><a href="#SSR有了解吗？原理是什么？" class="headerlink" title="SSR有了解吗？原理是什么？"></a>SSR有了解吗？原理是什么？</h2><p>在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且在服务器内部将Vue组件渲染成HTML，并且将数据、HTML一并返回给客户端，这个在服务器将数据和组件转化为HTML的过程，叫做服务端渲染SSR。<br>而当客户端拿到服务器渲染的HTML和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者Vuex内部即可。除了数据意外，HTML也结构已经有了，客户端在渲染组件的时候，也只需要将HTML的DOM节点映射到Virtual DOM即可，不需要重新创建DOM节点，这个将数据和HTML同步的过程，又叫做客户端激活。<br>使用SSR的好处：</p><p>有利于SEO：其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行JavaScript的，这种不支持执行JavaScript的爬虫抓取到的非SSR的页面会是一个空的HTML页面，而有了SSR以后，这些爬虫就可以获取到完整的HTML结构的数据，进而收录到搜索引擎中。</p><p>白屏时间更短：相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。而客户端渲染，需要先得到一个空的HTML页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 JavaScript 脚本，越是复杂的应用，需要加载的 JavaScript 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。</p><h2 id="为什么要用-Proxy-API-替代-defineProperty-API？"><a href="#为什么要用-Proxy-API-替代-defineProperty-API？" class="headerlink" title="为什么要用 Proxy API 替代 defineProperty API？"></a>为什么要用 Proxy API 替代 defineProperty API？</h2><p>a) defineProperty 的局限性的最大原因是它只能针对单例属性做监听，Vue2.x中对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。<br>这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因。<br>b) 在Vue 中使用下标的方式直接修改属性的值或者添加一个预先不存在的对<br>象属性是无法做到 setter 监听的，这是 defineProperty 的局限性。<br>c) Proxy 的监听是针对一个对象的，那么对这个对象的所有操作会进入监听<br>操作，这就完全可以代理所有属性，将会带来很大的性能提升和更优的代<br>码。<br>d) Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访<br>问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进<br>行过滤和改写。</p><ol start="2"><li>响应式是惰性的<br>a) 在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的<br>变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对<br>象数据都变成响应式的，这无疑会有很大的性能消耗。<br>b) 在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变<br>化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正<br>访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减<br>少性能消耗。</li></ol><h2 id="Vue3-0-编译做了哪些优化？"><a href="#Vue3-0-编译做了哪些优化？" class="headerlink" title="Vue3.0 编译做了哪些优化？"></a>Vue3.0 编译做了哪些优化？</h2><p>a) 生成 block tree<br>i. Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部<br>需要遍历该组件的整个 vnode 树。<br>ii. Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了 Block<br>tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个<br>区块内部的节点结构是固定的。每个区块只需要追踪自身包含的动态节<br>点。</p><h2 id="slot-编译优化"><a href="#slot-编译优化" class="headerlink" title="slot 编译优化"></a>slot 编译优化</h2><p>i. Vue.js 2.x 中，如果有一个组件传入了 slot，那么每次父组件更新的时候，<br>会强制使子组件 update，造成性能的浪费。<br>ii. Vue.js 3.0 优化了 slot 的生成，使得非动态 slot 中属性的更新只会触发子<br>组件的更新。动态 slot 指的是在 slot 上面使用 v-if，v-for，动态 slot 名字<br>等会导致 slot 产生运行时动态变化但是又无法被子组件 track 的操作。</p><h2 id="Vue-性能优化"><a href="#Vue-性能优化" class="headerlink" title="Vue 性能优化"></a>Vue 性能优化</h2><h3 id="代码层面的优化"><a href="#代码层面的优化" class="headerlink" title="代码层面的优化"></a>代码层面的优化</h3><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch 区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li></ul><h3 id="Webpack-层面的优化"><a href="#Webpack-层面的优化" class="headerlink" title="Webpack 层面的优化"></a>Webpack 层面的优化</h3><ul><li>Webpack 对图片进行压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li></ul><h3 id="基础的-Web-技术的优化"><a href="#基础的-Web-技术的优化" class="headerlink" title="基础的 Web 技术的优化"></a>基础的 Web 技术的优化</h3><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul><h2 id="单页面应用和多页面应用区别及优缺点"><a href="#单页面应用和多页面应用区别及优缺点" class="headerlink" title="单页面应用和多页面应用区别及优缺点"></a>单页面应用和多页面应用区别及优缺点</h2><p>答：单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。</p><p>多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新</p><p>单页面的优点：用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。</p><p>单页面缺点：不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。</p><h2 id="SPA首屏加载慢如何解决"><a href="#SPA首屏加载慢如何解决" class="headerlink" title="SPA首屏加载慢如何解决"></a>SPA首屏加载慢如何解决</h2><p>答：安装动态懒加载所需插件；使用CDN资源。</p><h2 id="Proxy-只会代理对象的第一层，那么-Vue3-又是怎样处理这个问题的呢？"><a href="#Proxy-只会代理对象的第一层，那么-Vue3-又是怎样处理这个问题的呢？" class="headerlink" title="Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？"></a>Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？</h2><p>判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测。</p><h2 id="Vue-模版编译原理知道吗，能简单说一下吗？"><a href="#Vue-模版编译原理知道吗，能简单说一下吗？" class="headerlink" title="Vue 模版编译原理知道吗，能简单说一下吗？"></a>Vue 模版编译原理知道吗，能简单说一下吗？</h2><p>简单说，Vue 的编译过程就是将 template 转化为 render 函数的过程。会经历以下阶段：</p><p>生成 AST 树</p><p>优化</p><p>codegen</p><p>首先解析模版，生成 AST 语法树(一种用 JavaScript 对象的形式来描述整个模板)。使用大量的正则表达式对模板进行解析，</p><p>遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p><p>Vue 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 DOM 也不会变化。</p><p>那么优化过程就是深度遍历 AST 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p><p>编译的最后一步是将优化后的 AST 树转换为可执行的代码。</p><h2 id="Vue2-x-和-Vue3-x-渲染器的-diff-算法分别说一下"><a href="#Vue2-x-和-Vue3-x-渲染器的-diff-算法分别说一下" class="headerlink" title="Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下"></a>Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下</h2><p>简单来说，diff 算法有以下过程</p><p>同级比较，再比较子节点</p><p>先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)</p><p>比较都有子节点的情况(核心 diff)</p><p>递归比较子节点</p><p>正常 Diff 两个树的时间复杂度是 O(n^3)，但实际情况下我们很少会进行跨层级的移动 DOM，所以 Vue 将 Diff 进行了优化，从 O(n^3) -&gt; O(n)，</p><p>只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。</p><p>Vue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。</p><p>相比 React 的 Diff 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p><p>Vue3.x 借鉴了 ivi 算法和 inferno 算法</p><p>在创建 VNode 时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，</p><p>使得性能上较 Vue2.x 有了提升。</p><p>该算法中还运用了动态规划的思想求解最长递归子序列。</p><h2 id="再说一下虚拟-Dom-以及-key-属性的作用"><a href="#再说一下虚拟-Dom-以及-key-属性的作用" class="headerlink" title="再说一下虚拟 Dom 以及 key 属性的作用"></a>再说一下虚拟 Dom 以及 key 属性的作用</h2><p>由于在浏览器中操作 DOM 是很昂贵的。频繁的操作 DOM，会产生一定的性能问题。这就是虚拟 Dom 的产生原因。</p><p>Vue2 的 Virtual DOM 借鉴了开源库 snabbdom 的实现。</p><p>Virtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点。是对真实 DOM 的一层抽象。(也就是源码中的 VNode 类，它定义在 src/core/vdom/vnode.js 中。)</p><p>VirtualDOM 映射到真实 DOM 要经历 VNode 的 create、diff、patch 等阶段。</p><p>「key 的作用是尽可能的复用 DOM 元素。」</p><p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。</p><p>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key 也就是 children 中节点的唯一标识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对vue面试的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vue 借鉴了 angular 的模板和数据绑定技术，又借鉴了 react 的组件化和虚拟 DOM 技术&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
    
      <category term="面试 Vue" scheme="http://github.com/categories/%E9%9D%A2%E8%AF%95-Vue/"/>
    
    
      <category term="面试 Vue" scheme="http://github.com/tags/%E9%9D%A2%E8%AF%95-Vue/"/>
    
  </entry>
  
  <entry>
    <title>CSS之基础篇</title>
    <link href="http://github.com/2021/02/09/CSS%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://github.com/2021/02/09/CSS%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2021-02-08T16:00:00.000Z</published>
    <updated>2021-02-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对CSS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="DIV-CSS-布局的优缺点"><a href="#DIV-CSS-布局的优缺点" class="headerlink" title="DIV + CSS 布局的优缺点"></a>DIV + CSS 布局的优缺点</h2><p>优点：</p><ul><li>代码精简，且结构与样式分离，易于维护</li><li>代码量减少了，减少了大量的带宽，页面加载的也更快，提升了用户的体验</li><li>对 SEO 搜索引擎更加友好，且 H5 又新增了许多语义化标签更是如此</li><li>允许更多炫酷的页面效果，丰富了页面</li><li>符合 W3C 标准，保证网站不会因为网络应用的升级而被淘汰</li></ul><p>缺点：</p><p>不同浏览器对 Web 标准默认值不同，所以更容易出现对浏览器的兼容性问题。</p><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>基本原理是通过媒体查询（@media）检测不同的设备屏幕尺寸做处理。</p><p>好处：对某些数据的修改就能自动更新视图，让开发者不需要操作 DOM，有更多的时间去思考完成业务逻辑。</p><h2 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h2><p>文档流：将窗体自上而下分成一行一行，并在每行中按从左至右一次排放元素，成为文档流，也就普通流。</p><p>脱离文档流：脱离文档流的元素，将不再在文档流占据空间，而是漂浮在文档流上方。</p><p><code>float: left/right</code>：使用之后会脱离，但是其他盒子会环绕该元素的周围。</p><p><code>position: absolute/fixed：absolute</code> 为绝对定位，脱离文档流之后还是会相对于该元素的父类（做了 <code>relative/absolute</code> 定位的父类）进行偏移。而 <code>fixed</code> 就是完全脱离文档流，相对于 <code>HTML</code> （整个浏览器窗口）的形式展示。</p><h2 id="块级格式化上下文（BFC）"><a href="#块级格式化上下文（BFC）" class="headerlink" title="块级格式化上下文（BFC）"></a>块级格式化上下文（BFC）</h2><p>BFC 布局规则 是指页面上一个隔离的独立容器，容器内部的子元素不会影响到外面的元素，反之外面的元素也不会影响容器里面的元素。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>在 BFC 中，盒子从顶端开始垂直地一个接一个地排列</li><li>盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠</li></ul><h3 id="外边距问题"><a href="#外边距问题" class="headerlink" title="外边距问题"></a>外边距问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;width:100px; height:100px; margin-bottom:100px;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div style=<span class="string">&quot;width:100px; height:100px; margin-top:200px;&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这段代码产生的页面中，它们的边距是 200px，需要通过 BFC 解决边距问题。</p><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h3><ol><li><p>清除元素内部浮动。<code>overflow: hidden</code></p></li><li><p>解决外边距合并问题。创建 2 个不同 <code>BFC</code>，就不会发生 <code>margin</code> 重叠</p><h3 id="产生-BFC-的条件："><a href="#产生-BFC-的条件：" class="headerlink" title="产生 BFC 的条件："></a>产生 BFC 的条件：</h3></li><li><p>根元素 <code>html</code></p></li><li><p><code>float: left/right</code></p></li><li><p><code>position: absolute/fixed</code></p></li><li><p><code>display: inline-block/flex/grid</code></p></li><li><p><code>overflow: hidden</code></p></li></ol><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><ul><li><code>box-sizing: content-box</code>。标准盒子，总宽度等于：<code>width + padding + border + margin</code>。</li><li><code>box-sizing: border-box</code>。<code>IE</code> 盒子，总宽度等于：<code>width + margin</code>。<code>IE</code> 盒子的 <code>width</code> 包含了 <code>width、padding</code> 和 <code>border</code> 属性。</li></ul><h2 id="link-和-import-区别"><a href="#link-和-import-区别" class="headerlink" title="link 和 @import 区别"></a>link 和 @import 区别</h2><p>CSS 引入方式有：</p><ul><li>内联：<code>style</code> 属性（<code>style=&quot;color: red&quot;</code>）</li><li>内嵌：<code>style</code> 标签（<code>&lt;style&gt;&lt;/style&gt;</code>）</li><li>外链：<code>link</code> 标签（<code>&lt;link href=&quot;index.css&quot;</code>&gt;</li><li>导入：<code>@import</code>（<code>@import url(&#39;index.css&#39;</code>) 或者 @import ‘index.css’）</li></ul><h3 id="link-和-import-区别："><a href="#link-和-import-区别：" class="headerlink" title="link 和 @import 区别："></a>link 和 @import 区别：</h3><ul><li><code>link</code> 是 <code>XHTML</code> 标签，除了加载 <code>CSS</code> 外，还可以定义 <code>RSS</code> 等其他事务；<code>@import</code> 属于 <code>CSS</code> 范畴，只能加载 <code>CSS</code>。</li><li><code>link</code> 引用 <code>CSS</code> 时，在页面载入时同时加载；<code>@import</code> 需要页面网页完全载入以后加载。</li><li><code>link</code> 是 <code>XHTML</code> 标签，无兼容问题；<code>@import</code> 是在 <code>CSS2.1</code> 提出的，低版本的浏览器不支持。</li><li><code>link</code> 支持使用 <code>Javascript</code> 控制 <code>DOM</code> 去改变样式；而 <code>@import</code> 不支持。</li></ul><h2 id="渐进增减和优雅降级"><a href="#渐进增减和优雅降级" class="headerlink" title="渐进增减和优雅降级"></a>渐进增减和优雅降级</h2><p>关键的区别是他们所侧重的内容，以及这种不同造成的工作流程的差异。</p><ul><li>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li><li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li></ul><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul><li>优雅降级是从复杂的现状开始，并试图减少用户体验的供给<br>渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要</li><li>降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</li></ul><h2 id="CSS-实现垂直居中"><a href="#CSS-实现垂直居中" class="headerlink" title="CSS 实现垂直居中"></a>CSS 实现垂直居中</h2><ol><li><p>方法一：Flex 布局（子元素是块级元素）</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-center&#123;</span><br><span class="line">  margin: auto;</span><br><span class="line">  background-color: greenyellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二：Flex 布局</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-center&#123;</span><br><span class="line">  background-color: greenyellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法三：绝对定位实现（定位元素定宽定高）</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-center&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">0</span>;</span><br><span class="line">  right: <span class="number">0</span>;</span><br><span class="line">  bottom: <span class="number">0</span>;</span><br><span class="line">  top: <span class="number">0</span>;</span><br><span class="line">  margin: auto;</span><br><span class="line">  width: <span class="number">50</span>px;</span><br><span class="line">  height: <span class="number">50</span>px;</span><br><span class="line">  background-color: greenyellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法四：使用 transform</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父盒子设置：display: relative</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子盒子 div 设置：</span></span><br><span class="line">div &#123;</span><br><span class="line">  transform: translate(<span class="number">-50</span>%, <span class="number">-50</span>%);</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: <span class="number">50</span>%;</span><br><span class="line">  left: <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h2><p>垂直居中分为水平居中、和垂直居中、完全居中（水平垂直都居中）</p></li></ol><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ol><li>行内元素可以通过在其父节点声明 text-align: center; 来实现,适用于内联、内联块、内联表、内联 Flex</li><li>块级元素可以通过 margin: 0 auto; + 宽度width<br>(在现代浏览器中实现水平居中，可以使用 display: flex; justify-content: center;不过，在 IE8-9 这样的不支持弹性盒布局的旧式浏览器中，上述代码并不会生效。此时要实现在父元素中居中，可使用 margin: 0 auto)<ul><li>节点不是块级元素需声明 display:block</li><li>若节点宽度已隐式声明则无需显式声明 width</li></ul></li><li>绝对定位 absolute+移动 transform 的方式</li><li>绝对定位 absolute+margin 负边距的方案</li><li>display:flex + justify-content:center</li></ol><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ol><li>子元素是单行文本的话直接 line-height 等于父节点的高度</li><li>display:flex + align-items:center</li><li>绝对定位 absolute+移动 transform 的方式</li><li>绝对定位 absolute+margin 负边距的方案</li></ol><h3 id="水平和垂直居中"><a href="#水平和垂直居中" class="headerlink" title="水平和垂直居中"></a>水平和垂直居中</h3><p>元素的宽度和高度 固定</p><p>绝对定位在 50%处，然后通过 margin 调整位置，浏览器兼容性良好</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;child&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.parent &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">50</span>%;</span><br><span class="line">  top: <span class="number">50</span>%;</span><br><span class="line">  margin: <span class="number">-50</span>px <span class="number">0</span> <span class="number">0</span> <span class="number">-50</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.child &#123;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">0</span>;</span><br><span class="line">  top: <span class="number">0</span>;</span><br><span class="line">  right: <span class="number">0</span>;</span><br><span class="line">  bottom: <span class="number">0</span>;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的宽度和高度 未知</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">50</span>%;</span><br><span class="line">  top: <span class="number">50</span>%;</span><br><span class="line">  <span class="comment">/* margin: -50px 0 0 -50px; */</span></span><br><span class="line">  transform: translate(<span class="number">-50</span>%, <span class="number">-50</span>%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强大的 flex 布局结合 margin</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  div &#123;</span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS-单位"><a href="#CSS-单位" class="headerlink" title="CSS 单位"></a>CSS 单位</h2><h3 id="1-px"><a href="#1-px" class="headerlink" title="1. px"></a>1. px</h3><p>px 是像素（pixel）的缩写，相对长度单位，是网页设计常用的基本基本单位，它是相对于显示器屏幕分辨率而言的。</p><h3 id="2-em"><a href="#2-em" class="headerlink" title="2. em"></a>2. em</h3><p>em 是相对长度单位，相对于对象内文本的字体尺寸（参考物是父元素的 font-size。</p><p>如果当前父元素的字体元素未设置，则相对于浏览器的默认字体尺寸设置。</p><h3 id="3-rem"><a href="#3-rem" class="headerlink" title="3. rem"></a>3. rem</h3><p>rem 是相对于 HTML 根元素的字体大小（font-size）来计算的长度单位。</p><p>如果你没有设置 HTML 字体大小，那么以浏览器默认为主，一般为 16px。</p><h3 id="4-vw-vh"><a href="#4-vw-vh" class="headerlink" title="4. vw/vh"></a>4. vw/vh</h3><p>vw 和 vh 是相对于 viewport - 相对视口的宽度或者高度而定的。</p><p>一般来说：1vw = npx / 100，即浏览器宽度为 200px 的时候，1vw = 200px / 100，即 1vw = 2px。</p><h2 id="CSS-设置隐藏元素"><a href="#CSS-设置隐藏元素" class="headerlink" title="CSS 设置隐藏元素"></a>CSS 设置隐藏元素</h2><ul><li><code>display: none</code>：彻底消失，会导致浏览器回流和重绘，不能再触发点击事件。</li><li><code>visibility: hidden</code>：元素隐藏，空间仍保留，会导致重绘，但是不能再触发点击事件。</li><li><code>opacity: 0</code>：设置为透明，相当于它还在那里，但是你看不到，可以触发点击事件。</li></ul><h2 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h2><p>CSS 选择器及样式优先级：</p><ul><li>在属性后面使用 !important 会覆盖页面任意位置定义的元素样式</li><li>作为 style 属性写在元素内的样式（行内样式）</li><li>id 选择器</li><li>类选择器 | 伪类选择器 | 属性选择器（后面样式覆盖前面样式）</li><li>标签选择器</li><li>通配符选择器</li><li>浏览器自定义样式</li></ul><h2 id="CSS-匹配规则"><a href="#CSS-匹配规则" class="headerlink" title="CSS 匹配规则"></a>CSS 匹配规则</h2><blockquote><p>CSS 选择器的解析是从右向左解析的。</p></blockquote><p>若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。</p><p>若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。</p><p>两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p><h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>层叠上下文（stacking context），是 HTML 中一个三维的概念。在 CSS2.1 规范中，每个盒模型的位置是三维的，分别是平面画布上的 X 轴，Y 轴以及表示层叠的 Z 轴。</p><p>一般情况下，元素在页面上沿 X 轴 Y 轴平铺，我们察觉不到它们在 Z 轴上的层叠关系。</p><p>而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。</p><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ul><li>根层叠上下文（HTML）</li><li>position</li><li>CSS3 属性<ul><li>flex</li><li>transform</li><li>opacity</li><li>filter</li><li>will-change</li><li>-webkit-overflow-scrolling</li></ul></li></ul><h3 id="层叠等级"><a href="#层叠等级" class="headerlink" title="层叠等级"></a>层叠等级</h3><p>层叠等级：层叠上下文在 Z 轴上的排序</p><p>在同一层叠上下文中，层叠等级才有意义<br>z-index 的优先级最高</p><h2 id="dispaly-和-position"><a href="#dispaly-和-position" class="headerlink" title="dispaly 和 position"></a>dispaly 和 position</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>inline</code>：（默认）内联</li><li><code>none</code>：隐藏</li><li><code>block</code>：块显示</li><li><code>table</code>：表格显示</li><li><code>inline-block</code>：内联块<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>static</code>：默认位置。不需要特别声明，不常用。</li><li><code>relative</code>：相对定位。相对于元素默认的位置进行定位，设置 <code>top/left/right/bottom</code> 后的元素仍占据空间。</li><li><code>absolute</code>：绝对定位。如果父元素设置了 <code>position: absolute/relative</code>，那么这个设置成立。它会根据上一个设置了 <code>absolute/relative</code> 的元素进行偏移。</li><li><code>fixed</code>：固定定位。相对于整个浏览器窗口进行定位，无论页面怎么滚动。</li><li><code>sticky</code>：黏性定位。屏幕范围内该元素位置不受影响，超出范围后，会变成 <code>fixed</code>，根据设置的 <code>left/top</code> 等属性成固定的效果。</li></ul><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><ul><li>RGBA 和透明度</li><li><code>background-image</code>、<code>background-origin(content-box/padding-box/border-box)</code>、<code>background-size</code>、<code>background-repeat</code></li><li><code>word-wrap</code>：对长的不可分割单词换行，例如 <code>word-wrap：break-word</code></li><li>文字阴影：<code>text-shadow: 5px 5px 5px #FF0000</code>;，对应水平阴影，垂直阴影，模糊距离，阴影颜色</li><li><code>font-face</code> 属性：定义自己的字体</li><li>圆角（边框半径）：<code>border-radius</code> 属性用于创建圆角</li><li>边框图片：<code>border-image: url(border.png) 30 30 round</code></li><li>盒阴影：<code>box-shadow: 10px 10px 5px #888888</code></li><li>媒体查询：定义两套 <code>CSS</code>，当浏览器的尺寸变化时会采用不同的属性<h3 id="Flexbox-弹性盒布局模型"><a href="#Flexbox-弹性盒布局模型" class="headerlink" title="Flexbox 弹性盒布局模型"></a>Flexbox 弹性盒布局模型</h3></li></ul><p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。</p><p>在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。</p><p>弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。</p><p>试用场景：弹性布局适合于移动前端开发，在 Android 和 IOS 上也完美支持。</p><h2 id="CSS-优化"><a href="#CSS-优化" class="headerlink" title="CSS 优化"></a>CSS 优化</h2><ul><li>避免过度约束</li><li>避免后代选择符</li><li>避免链式选择符</li><li>使用紧凑的语法</li><li>避免不必要的命名空间</li><li>避免不必要的重复</li><li>最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么</li><li>避免 !important，可以选择其他选择器</li><li>尽可能的精简规则，你可以合并不同类里的重复规则</li></ul><h2 id="CSS-的-style-标签位置"><a href="#CSS-的-style-标签位置" class="headerlink" title="CSS 的 style 标签位置"></a>CSS 的 style 标签位置</h2><p>页面加载自上而下，当然是先加载样式。</p><p>写在 body 标签后由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在 Windows 的 IE 下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对CSS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;DIV-CSS-布局的优缺点&quot;&gt;&lt;a href=&quot;#DIV-CSS-布局的优缺点&quot; class=&quot;headerlink&quot; title=&quot;DIV + C
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://github.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://github.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS之面试重点篇</title>
    <link href="http://github.com/2021/02/09/CSS%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E7%AF%87/"/>
    <id>http://github.com/2021/02/09/CSS%E4%B9%8B%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E7%AF%87/</id>
    <published>2021-02-08T16:00:00.000Z</published>
    <updated>2021-02-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对CSS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://juejin.cn/post/6844903842635579405">【面试篇】寒冬求职之你必须要懂的Web安全</a></p></li><li><p><a href="https://zoumiaojiang.com/article/common-web-security/#xss">常见 Web 安全攻防总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对CSS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h2&gt;&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="CSS 面试" scheme="http://github.com/categories/CSS-%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="CSS 面试" scheme="http://github.com/tags/CSS-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化之Webpack优化</title>
    <link href="http://github.com/2021/02/06/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8BWebpack%E4%BC%98%E5%8C%96/"/>
    <id>http://github.com/2021/02/06/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8BWebpack%E4%BC%98%E5%8C%96/</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-02-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="Webpack优化"><a href="#Webpack优化" class="headerlink" title="Webpack优化"></a>Webpack优化</h2><p>Webpack 的优化瓶颈，主要是 2 个方面：</p><p>Webpack 的构建过程太花时间<br>Webpack 打包的结果体积太大</p><h2 id="针对-Webpack-本身构建优化"><a href="#针对-Webpack-本身构建优化" class="headerlink" title="针对 Webpack 本身构建优化"></a>针对 Webpack 本身构建优化</h2><h3 id="优化-resolve-modules-配置"><a href="#优化-resolve-modules-配置" class="headerlink" title="优化 resolve.modules 配置"></a>优化 resolve.modules 配置</h3><p><code>resolve.modules</code> 用于配置<code> Webpack</code> 去哪些目录下寻找第三方模块，默认是 <code>[&#39;node_modules&#39;]</code>。</p><p>但是，它会先去当前目录的 <code>./node_modules</code> 查找，没有的话再去 <code>../node_modules</code>，最后到根目录 —— 即 <code>npm</code> 查找包的规则。</p><p>所以可以直接指定项目根目录，这样代码就不需要一层一层查找。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  modules: [path.resolve(__dirname, <span class="string">&#x27;node_modules&#x27;</span>)],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化-resolve-extensions-配置"><a href="#优化-resolve-extensions-配置" class="headerlink" title="优化 resolve.extensions 配置"></a>优化 resolve.extensions 配置</h3><p>在导入没带文件后缀的路径时，<code>Webpack</code> 会自动带上后缀去尝试询问文件是否存在，而 <code>resolve.extensions</code> 用于配置尝试后缀列表；默认为 <code>extensions:[&#39;js&#39;, &#39;json&#39;]</code>。</p><p>当遇到 <code>require(&#39;./data&#39;)</code> 时 <code>Webpack</code> 会先尝试寻找 <code>data.js</code>，没有再去找 <code>data.json</code>；如果列表越长，或者正确的后缀越往后，尝试的次数就会越多。</p><p>所以在配置时为提升构建优化需遵守：</p><ul><li>频率出现高的文件后缀优先放在前面。</li><li>列表尽可能的少，例如只有 3 个：js、jsx、json。</li><li>书写导入语句时，尽量写上后缀名。</li></ul><h3 id="优化-resolve-include-exclude-配置"><a href="#优化-resolve-include-exclude-配置" class="headerlink" title="优化 resolve.include/exclude 配置"></a>优化 resolve.include/exclude 配置</h3><p>以 <code>babel-loader</code> 为例，可以通过 <code>include</code> 和 <code>exclude</code> 帮助我们避免 <code>node_modules</code> 这类庞大文件夹。</p><p>即通过 <code>include</code> 告诉 <code>Webpack</code> 哪些我们是需要检测的，通过 <code>exclude</code> 告诉 <code>Webpack</code> 哪些我们是不需要检测的（例如已经收拾过的静态资源）</p><h2 id="通过-Loader-和-Plugin-优化"><a href="#通过-Loader-和-Plugin-优化" class="headerlink" title="通过 Loader 和 Plugin 优化"></a>通过 Loader 和 Plugin 优化</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li><p>cache-loader</p><p>在 babel-loader 开启 cache 后，将 loader 的编译结果写进硬盘缓存，再次构建如果文件没有发生变化则会直接拉取缓存。</p></li><li><p>uglifyjs-webpack-plugin</p><p>通过这个插件也可以解决缓存问题。</p></li></ul><blockquote><p>注：具体的要根据当前的 Webpack 版本，Loader 和 Plugin 表示 Webpack 每次更新都会淘汰一批没有跟进维护的 Loader 和 Plugin。就跟大佬还在持续学习，你几年没学习之后，遇到金融危机被淘汰的风险就高了。</p></blockquote><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。</p><p>文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？</p><p><code>Happypack</code> 可以将任务分解成多个子进程去并发执行，大大提升打包效率。</p><p>除此之外 <code>thread-loader</code> 和 <code>Happypack</code> 一样，但是配置比较简单。</p><blockquote><p>  <code>Happypack</code> 已经不维护了。</p></blockquote><h3 id="多进程压缩"><a href="#多进程压缩" class="headerlink" title="多进程压缩"></a>多进程压缩</h3><p>因为自带的 <code>UglifyjsWebpackPlugin</code> 压缩插件是单线程运行的，而 <code>TerserWebpackPlugin</code> 可以并发运行压缩功能（多进程）。</p><p>所以通过 <code>TerserWebpackPlugin</code> 代替自带的 <code>UglifyjsWebpackPlugin</code> 插件。</p><h3 id="静态资源分离"><a href="#静态资源分离" class="headerlink" title="静态资源分离"></a>静态资源分离</h3><p>通过 <code>DllPlugin</code> 或者 <code>Externals</code> 进行静态依赖包的分离。</p><p>由于 <code>CommonsChunkPlugin</code> 每次构建会重新构建一次 <code>vendor</code>，所以出于效率考虑，使用<code>DllPlugin</code>将第三方库单独打包到一个文件中，只有依赖自身发生版本变化时才会重新打包。</p><h3 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h3><p>在 <code>Webpack </code>中，到底什么是代码分离？代码分离允许你把代码拆分到多个文件中。如果使用得当，你的应用性能会提高很多。因为浏览器能缓存你的代码。</p><p>每当你做出一次修改，包含修改的文件需要被所有访问你网站的人重新下载。但你并不会经常修改应用的依赖库。</p><p>如果你能把那些依赖库拆分到完全分离的文件中，即使业务逻辑发生了更改，访问者也不需要再次下载依赖库，直接使用之前的缓存就可以了。</p><p>由于有了 <code>SplitChunksPlugin</code>，你可以把应用中的特定部分移至不同文件。如果一个模块在不止一个 chunk 中被使用，那么利用代码分离，该模块就可以在它们之间很好地被共享。</p><h3 id="打包资源压缩"><a href="#打包资源压缩" class="headerlink" title="打包资源压缩"></a>打包资源压缩</h3><ul><li>JS 压缩：<code>UglifyjsWebpackPlugin</code></li><li>HTML 压缩：<code>HtmlWebpackPlugin</code></li><li>CSS 压缩：<code>MiniCssExtractPlugin</code></li><li>图片压缩：<code>image-webpack-loader</code></li><li>Gzip 压缩：不包括图片</li></ul><h2 id="其他优化点"><a href="#其他优化点" class="headerlink" title="其他优化点"></a>其他优化点</h2><h3 id="1-Tree-Shaking"><a href="#1-Tree-Shaking" class="headerlink" title="1. Tree Shaking"></a>1. Tree Shaking</h3><p>通过 ES6 的<code>import/export</code>来检查未引用代码，以及 <code>sideEffects</code> 来标记无副作用代码，最后用 <code>UglifyJSPlugin</code> 来做 <code>Tree Shaking</code>，从而删除冗余代码。</p><h3 id="2-Scope-Hoisting"><a href="#2-Scope-Hoisting" class="headerlink" title="2. Scope Hoisting"></a>2. Scope Hoisting</h3><p><code>Scope Hoisting</code> 是 <code>Webpack3</code> 的新功能，直译为 「<code>作用域提升」</code>，它可以让 <code>Webpack</code> 打包出来的 <code>「代码文件更小」</code>，<code>「运行速度更快」</code>。</p><p>熟悉 <code>JavaScript </code>都应该知道 <code>「函数提升」</code> 和 <code>「变量提升」</code> ，<code>JavaScript</code> 会把函数和变量声明提升到当前作用域的顶部。</p><p><code>「作用域提升」</code> 也类似于此，<code>Webpack</code> 会把引入的 <code>js</code> 文件 <code>“提升到”</code> 它的引入者顶部。</p><p><code>Scope Hoisting</code> 的实现原理其实很简单：分析出模块之间的依赖关系，尽可能将打散的模块合并到一个函数中，前提是不能造成代码冗余。因此「只有那些被引用了一次的模块才能被合并」。</p><p>由于 <code>Scope Hoisting</code> 需要分析出模块之间的依赖关系，因此源码<code>「必须采用 ES6 模块化语句」</code>，不然它将无法生效。原因和 <code>Tree Shaking </code>中介绍的类似。</p><h3 id="3-按需加载"><a href="#3-按需加载" class="headerlink" title="3. 按需加载"></a>3. 按需加载</h3><p>什么是 代码分割（<code>code splitting</code>）？</p><p>代码分割是指：将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程。</p><p>在 <code>Webpack</code> 构建时，会避免加载已声明要异步加载的代码，异步代码会被单独分离出一个文件，当代码实际调用时被加载至页面。</p><p>代码分割技术的核心是 <code>异步加载资源</code>。</p><p>可喜的是，浏览器允许我们这么做，<code>W3C stage 3</code> 规范： <code>whatwg/loader</code> 对其进行了定义：你可以通过 <code>import()</code> 关键字让浏览器在程序执行时异步加载相关资源。</p><p>在 <code>Vue</code> 中，可以直接使用 <code>import()</code> 关键字做到这一点，而在 <code>React</code> 中，你需要使用 <code>react-loadable</code> 去完成同样的事。</p><h2 id="优化体验"><a href="#优化体验" class="headerlink" title="优化体验"></a>优化体验</h2><ul><li><p><code>progress-bar-webpack-plugin</code>：在终端底部，将会有一个构建的进度条，可以让你清晰的看见构建的执行进度。</p></li><li><p><code>webpack-build-notifier</code>：在构建完成时，能够像微信、Lark 这样的 APP 弹出消息的方式，提示构建已经完成。</p></li><li><p><code>webpack-dashboard</code>：对 <code>Webpack</code> 原始的构建输出不满意的话，也可以使用这样一款 Plugin 来优化你的输出界面。</p></li><li><p><code>speed-measure-webpack-plugin</code>：该插件可以测量各个插件和 <code>loader</code> 所花费的时间。</p></li><li><p><code>webpack-bundle-analyzer</code>：可视化分析。通过矩阵树图的方式将包内各个模块的大小和依赖关系呈现出来。</p></li><li><p><code>webpack-chart</code></p></li><li><p><code>webpack-analyse</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ul><ul><li><p><a href="https://juejin.cn/post/6844903924806189070#heading-0">Webpack优化——将你的构建效率提速翻倍</a></p></li><li><p><a href="http://louiszhai.github.io/2019/01/04/webpack4/">使用webpack4提升180%编译速度</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;Webpack优化&quot;&gt;&lt;a href=&quot;#Webpack优化&quot; class=&quot;headerlink&quot; title=&quot;Webpack优化&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://github.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="前端工程化" scheme="http://github.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化之Webpack</title>
    <link href="http://github.com/2021/02/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8BWebpack/"/>
    <id>http://github.com/2021/02/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B9%8BWebpack/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="Webpack-是什么"><a href="#Webpack-是什么" class="headerlink" title="Webpack 是什么"></a>Webpack 是什么</h2><p>Webpack 是一个现代 JavaScript 应用程序的静态模块打包器（module bundler）。</p><p>当 Webpack 处理应用程序时，它会递归地构建一个依赖关系图（dependency graph），其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p><p>所以，它的本质是一个模块打包器，其工作是将每个模块打包成相应的 bundle。</p><h2 id="Webpack-核心概念"><a href="#Webpack-核心概念" class="headerlink" title="Webpack 核心概念"></a>Webpack 核心概念</h2><ul><li>mode：模式。对应有开发模式、生产模式等</li><li>entry：入口</li><li>output：出口</li><li>loader：模块转换器，用于把模块原内容按照需求转换成新内容。Webpack 对于 .jpg、.txt 等内容无法处理，就需要 file-loader、url-loader 等进行协助处理。</li><li>plugins：扩展插件，在 Webpack 构建流程中的特定时机注入拓展逻辑来改变构建结果或者做其他你想做的事情。</li></ul><h2 id="Webpack-构建流程"><a href="#Webpack-构建流程" class="headerlink" title="Webpack 构建流程"></a>Webpack 构建流程</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li><li>确定入口：根据配置中的 entry 找出所有的入口文件</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ol><p>简单来说：</p><ol><li>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler（钩子）</li><li>编译：从 Entry 出发，针对每个 Module（模块）串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li><li>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中（Chunk 就是打包过程中，入口模块引用其他模块，模块再引用模块，这个关系链连接的 Module 就形成了 Chunk）</li></ol><p>在这个过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="1-entry"><a href="#1-entry" class="headerlink" title="1.entry"></a>1.entry</h3><blockquote><p>打包入口<br>指定打包⼊口文件，有三种不同的形式：string | object | array。</p></blockquote><p>一对一：一个入口、一个打包文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多对一：多个入口、一个打包文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [</span><br><span class="line">    <span class="string">&#x27;./src/index1.js&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;./src/index2.js&#x27;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多对多：多个入口、多打包文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">&#x27;index1&#x27;</span>: <span class="string">&quot;./src/index1.js&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;index2&#x27;</span>: <span class="string">&quot;./src/index2.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-output"><a href="#2-output" class="headerlink" title="2.output"></a>2.output</h3><blockquote><p>打包后的文件输出位置。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    filename: <span class="string">&quot;[name].js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以指定一个固定的文件名称，如果是多入口多出口（entry 为对象），则不能使用单文件出口，需要使用下面的方式<br>通过 Webpack 内置的变量占位符：[name]</p><h3 id="3-loader"><a href="#3-loader" class="headerlink" title="3.loader"></a>3.loader</h3><blockquote><p>模块转换器，用于把模块原内容按照需求转换成新内容</p></blockquote><p>loader 的执行顺序是从右向左执行的，也就是后面的 loader 先执行。</p><p>假如有配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>],</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那就是先处理 less-loader，再处理 css-loader，最后处理 style-loader。</p><h4 id="常见的-loader"><a href="#常见的-loader" class="headerlink" title="常见的 loader"></a>常见的 loader</h4><ol><li><p>关于文件处理常见的 loader</p><ul><li><code>file-loader</code>：当引入的文件是 <code>.png</code>、<code>.txt</code> 等时，可以通过<code>file-loader</code> 解析项目中的 <code>url</code> 引入。根据配置将文件拷贝到相应的路径，并修改打包后文件的引入路径，让它指向正确的文件。</li><li><code>url-loader</code>：<code>url-loader</code> 封装了 <code>file-loader</code> 且可以不依赖于 <code>file-loader</code> 单独使用，并且可以配置 <code>limit</code>。对小于 <code>limit</code> 大小的图片转换成 <code>Base64</code>，大于 <code>limit</code> 的时候使用 <code>file-loader</code> 里的方法。</li></ul></li><li><p>关于语法检查常见 loader</p></li></ol><ul><li>tslint-loader：通过 TSLint 检查 TypeScript 代码</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li></ul><ol start="3"><li>关于 HTML 代码处理常见的 loader</li></ol><ul><li>html-withimg-loader：处理 HTML 中的图片</li></ul><ol start="4"><li>关于 CSS 代码处理常见的 loader</li></ol><ul><li>style-loader：动态创建 style 标签，将 CSS 代码插入到 head 中。</li><li>css-loader：负责处理 @import、url 等语句。例如 import css from ‘file.css’、url(image.png)。</li><li>postcss-loader：负责进一步处理 CSS 文件，比如添加浏览器前缀，压缩 CSS 等。</li><li>less-loader：将 .less 文件内容转换成 CSS。</li><li>sass-loader：将 .sass 文件内容转换成 CSS。</li></ul><ol start="5"><li>关于 JS 代码处理常见的 loader</li></ol><ul><li>babel-loader：将 JS 代码向低版本转换，我们需要使用 -babel-loader。</li><li>ts-loader：将 TypeScript 转换成 JavaScript</li></ul><h3 id="4-plugin"><a href="#4-plugin" class="headerlink" title="4.plugin"></a>4.plugin</h3><blockquote><p>扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情</p></blockquote><h4 id="常见-plugin"><a href="#常见-plugin" class="headerlink" title="常见 plugin"></a>常见 plugin</h4><ul><li>clean-webpack-plugin：打包前自动清理 dist 目录，防止文件残留。</li><li>copy-webpack-plugin：将单个文件或者整个目录复制到构建目录<br>mini-css-extract-plugin：将 CSS 抽离出来单独打包并且通过配置可以设置是否压缩。</li><li>html-webpack-plugin：这个插件可以配置生成一个 HTML5 文件，其中 script 标签包含所有 Webpack 包。如果你设置多个入口点，你可以据此实现多页面应用打包。<h4 id="提高效率的-plugin"><a href="#提高效率的-plugin" class="headerlink" title="提高效率的 plugin"></a>提高效率的 plugin</h4></li><li>webpack-dashboard：可以更友好的展示相关打包信息。</li><li>webpack-merge：提取公共配置，减少重复配置代码</li><li>speed-measure-webpack-plugin：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。</li><li>size-plugin：监控资源体积变化，尽早发现问题</li><li>HotModuleReplacementPlugin：模块热替换</li></ul><h4 id="loader-和-plugin-的区别"><a href="#loader-和-plugin-的区别" class="headerlink" title="loader 和 plugin 的区别"></a>loader 和 plugin 的区别</h4><ol><li><p>Loader</p><p> Loader 本质上就是一个函数，对接收到的内容进行转换，返回转换后的结果。</p><p> 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对不同类型的资源进行处理。</p><p> 就好比 file-loader 或者 url-loader，配置之后就可以正确引用 png 等格式的图片、txt 等格式文件。</p><p> 又好比 style-loader 以及 css-loader，引用后就可以对 CSS 内容进行预编译处理。</p></li><li><p>Plugin</p><p> Plugin 就是插件，就好比 编写的 VS Code 插件一样，Plugin 拓展了 Webpack 的功能。</p><p> Plugin 就是在 Webpack 的生命周期中进行各种操作，从而达到使用者目的插件。</p><p> 就好比 html-webpack-plugin，配合多入口形式使用之后，就可以实现多页面应用的功能。</p><p> 又好比 clean-webpack-plugin 实现打包之前清空 dist 目录，copy-webpack-plugin 可以将单个文件或者整个目录复制到构建目录。</p></li></ol><h3 id="5-resolve"><a href="#5-resolve" class="headerlink" title="5.resolve"></a>5.resolve</h3><blockquote><p>resolve 配置 Webpack 如何寻找模块所对应的文件。</p></blockquote><p>Webpack 内置 JavaScript 模块化语法解析功能，默认会采用模块化标准里约定好的规则去寻找，但你可以根据自己的需要修改默认的规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    modules: [<span class="string">&#x27;./src/components&#x27;</span>, <span class="string">&#x27;node_modules&#x27;</span>] <span class="comment">// 从左到右依次查找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>resolve.modules：配置 Webpack 去哪些目录下寻找第三方模块，默认情况下，只会去 node_modules 下寻找，如果你在项目中某个文件夹下的模块经常被导入，不希望写很长的路径，那么就可以通过配置 resolve.modules 来简化。</li><li>resolve.alias：配置项通过别名把原导入路径映射成一个新的导入路径。</li><li>resolve.extensions：适配多端的项目中，可能会出现 .web.js, .wx.js，例如在转 Web 的项目中，我们希望首先找 .web.js，如果没有，再找 .js。extensions: [‘web.js’, ‘.js’]。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://juejin.cn/post/6844904094281236487#heading-0">「吐血整理」再来一打Webpack面试题</a></p></li><li><p><a href="https://juejin.cn/post/6844904079219490830#heading-0">带你深度解锁Webpack系列(基础篇)</a></p></li><li><p><a href="https://juejin.cn/post/6924258563862822919#heading-1">Webpack5 新特性业务落地实战</a></p></li><li><p><a href="https://juejin.cn/post/6902225969604460558#heading-0">Vite 原理分析</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;Webpack-是什么&quot;&gt;&lt;a href=&quot;#Webpack-是什么&quot; class=&quot;headerlink&quot; title=&quot;Webpack 是什么
      
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://github.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="前端工程化" scheme="http://github.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="http://github.com/2021/02/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>http://github.com/2021/02/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><h3 id="Babel-原理"><a href="#Babel-原理" class="headerlink" title="Babel 原理"></a>Babel 原理</h3><p>大多数 <code>JavaScript Parser</code> 遵循 <code>estree</code> 规范，<code>Babel</code> 最初基于 <code>acorn</code> 项目（轻量级现代 <code>JavaScript</code> 解析器）</p><p><code>Babel</code> 大概分为三大部分：</p><ul><li>解析：将代码转换成 <code>AST</code><ul><li>词法分析：将代码（字符串）分割为 <code>token</code> 流，即语法单元成的数组</li><li>语法分析：分析 <code>token</code> 流（上面生成的数组）并生成 <code>AST</code></li></ul></li><li>转换：访问 <code>AST</code> 的节点进行变换操作生产新的 <code>AST</code>，<br><code>Taro</code> 就是利用 <code>babel</code> 完成的小程序语法转换</li><li>生成：以新的 <code>AST</code> 为基础生成代码</li></ul><h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><blockquote><p>抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。</p></blockquote><p>它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p><p>之所以说语法是 “抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p><h3 id="面试点"><a href="#面试点" class="headerlink" title="面试点"></a>面试点</h3><ul><li>面试官：了解过 <code>Babel</code> 吗？</li><li>俺：大概知道将 <code>ES6+</code> 代码，先通过词法分析和语法分析之后解析为 <code>AST</code>，然后将这份 <code>AST</code> 转换为我们需要形式的 <code>AST</code>，最后将这个 <code>AST</code> 再转换成 <code>ES5</code> 或者期望格式的内容。</li><li>面试官：写过 <code>Babel</code> 插件吗？</li><li>俺：没有。</li></ul><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><ul><li>是什么：本质是一个模块打包器，其工作是将每个模块打包成相应的 bundle</li><li>核心概念：mode、entry、output、loader、plugin</li><li>构建流程：初始化、编译、输出，插件（Plugin）随时监听 Webpack 广播并在某些时候调用 API 改变运行结果。</li><li>entry：指定打包⼊口⽂文件。原本是 string，即一个入口对一个打包文件、object 多对一，array 多对多</li><li>output：打包后的文件位置</li><li>loader：翻译官，对不同资源进行处理，从右向左执行</li><li>plugin：插件，扩展 Webpack 的功能，监听 Webpack 的生命周期，调用 API 改变输出结果。</li><li>resolve：配置 Webpack 如何寻找模块所对应的文件。<code>resolve.modules/extensions/include/exclude</code></li></ul><h2 id="Webpack-性能优化"><a href="#Webpack-性能优化" class="headerlink" title="Webpack 性能优化"></a>Webpack 性能优化</h2><ul><li>resolve.modules：用于配置 Webpack 去哪些目录下寻找第三方模块（node_modules）</li><li>resolve.extensions：在导入没带文件后缀的路径时，Webpack 会自动带上后缀去尝试询问文件是否存在，而 <code>resolve.extensions</code> 用于配置尝试后缀列表；默认为 <code>extensions:[&#39;js&#39;, &#39;json&#39;]</code></li><li><code>resolve.include/exclude</code>：以 <code>babel-loader</code> 为例，可以通过 include 和 exclude 帮助我们避免 node_modules 这类庞大文件夹]</li><li>缓存：<code>cache-loader</code> 和 <code>uglifyjs-webpack-plugin</code>，将编译结果写进硬盘缓存，下次文件如果没有变化则直接拉取缓存</li><li>多进程：<code>Happypack</code> 和 <code>thread-loader</code>，将任务分解成多个子进程去并发执行，提高打包效率</li><li>多进程压缩：<code>Webpack</code> 自带的 <code>UglifyJSWebpackPlugin</code> 压缩插件是单线程运行的，而 <code>TerserWebpackPlugin</code> 可以并行执行（多线程）</li><li>静态资源分离：<code>CommonsChunkPlugins</code> 每次构建都会重新构建 vendor，出于效率问题使用 DllPlugin 可以将第三方库单独打包到一个文件中，只有依赖自身发生版本变化才会重新打包</li><li>打包资源压缩：</li><li>JS 压缩：<code>UglifyJSWebpackPlugin</code> 和 <code>TerserWebpackPlugin</code></li><li>HTML 压缩：<code>HtmlWebpackPlugin</code></li><li>CSS 压缩：<code>MiniCssExtractPlugin</code></li><li>图片压缩：<code>ImageWebpackPlugin</code></li><li>Gzip 压缩：不包括图片</li><li>Tree Shaking</li><li>Scope Hoisiting</li><li>按需加载<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ul><ul><li><p><a href="https://juejin.cn/post/6844903842635579405">【面试篇】寒冬求职之你必须要懂的Web安全</a></p></li><li><p><a href="https://zoumiaojiang.com/article/common-web-security/#xss">常见 Web 安全攻防总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对前端工程化的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;Babel&quot;&gt;&lt;a href=&quot;#Babel&quot; class=&quot;headerlink&quot; title=&quot;Babel&quot;&gt;&lt;/a&gt;Babel&lt;/h2&gt;&lt;h
      
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://github.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="前端工程化" scheme="http://github.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之HTTP</title>
    <link href="http://github.com/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BHTTP/"/>
    <id>http://github.com/2021/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BHTTP/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="HTTP-发展史"><a href="#HTTP-发展史" class="headerlink" title="HTTP 发展史"></a>HTTP 发展史</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>传输体积很小的文件，没有 HTTP 请求头和请求体，服务器也不返回头信息。</p><p>HTTP/0.9 并没有考虑太过复杂的内容，仅仅是用来传输体积很小的文件。</p><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>核心诉求是支持多种类型的文件下载。加入了请求头和响应头支持多种不同类型的数据。以及状态码、Cache 机制、用户代理等。</p><p>应对 HTTP/0.9 出现的问题，进行了支持多类型文件下载等内容的优化。<br><br>HTTP/1.0 定义了三种请求方法：GET，POST 和 HEAD 方法。</p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><ol><li>改进了 <code>HTTP/1.0</code> 版本每次 <code>HTTP</code> 通信都需要建立 <code>TCP</code> 连接、传输 <code>HTTP</code> 数据再断开 <code>TCP</code> 连接的尴尬局面，支持持续连接。只要浏览器或者服务器没有明确断开连接，那么该 <code>TCP</code> 连接会一直保持（默认开启 <code>keep-alive</code>）。</li><li>如果 <code>TCP</code> 通道中某个请求因为某些原因没有及时返回，会阻塞后面所有请求（队头阻塞），所以 <code>HTTP/1.1 </code>通过管线化来解决队头阻塞的问题。</li><li><code>HTTP/1.0</code> 每个域名绑定唯一 <code>IP</code> 地址，一个服务器只能支持一个域名。<code>HTTP/1.1</code> 请求头增加 <code>Host</code> 字段，表示当前域名地址，服务器可以根据不同的 <code>Host</code> 值做不同的处理。这样一台物理主机就可以绑定多个虚拟主机，每个虚拟主机都有自己单独的域名。</li><li><code>HTTP/1.0</code> 需要在响应头设置完整的数据大小来接收数据，但是随着服务器端发展，很多页面动态生成，不知道传输数据的最终大小。<code>HTTP/1.1</code> 引入 <code>Chunk transfer</code> 机制来解决这个问题，服务器将数据分割成任意大小的数据块，每个数据块发送时附带上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志，从而支持了动态内容。</li><li>客户端 <code>Cookie</code>、安全机制。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>HTTP/1.1</code> 默认开启 <code>Connection: keep-alive</code>，让一个 <code>TCP </code>连接能重复发送/接收多次 <code>HTTP </code>请求。</li><li><code>HTTP/1.1</code>新增了六种请求方法：<code>OPTIONS</code>、<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>、<code>TRACE</code> 和 <code>CONNECT</code> 方法。</li></ul><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><ol><li>一个域名只使用一个 TCP 长连接和消除队头阻塞问题</li><li>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。HTTP/2.0 实现了一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</li><li>队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>头部压缩：HTTP/2 压缩消息头，减少了传输数据的大小</li><li>多路复用：即多个请求都通过一个 TCP 连接并发地完成</li><li>设置请求优先级</li><li>服务器推送：服务端能够主动把资源推送给客户端</li></ul><h3 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP/3.0"></a>HTTP/3.0</h3><ol><li>实现了类似 TCP 的流量控制、传输可靠性的功能。</li><li>集成了 TLS 加密功能。</li><li>实现了 HTTP/2 中的多路复用功能。</li><li>实现了快速握手功能。</li></ol><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="什么是http？"><a href="#什么是http？" class="headerlink" title="什么是http？"></a>什么是http？</h3><blockquote><p>超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP）</p></blockquote><p>Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器等一系列运作流程。而协议是指规则的约定。可以说，Web 是建立在 HTTP 协议上通信的。</p><p>HTTP 最初的目的是为了让研究者共享知识信息，所以它的主要作用就是文档传输，它是一种用于传输文档的协议。用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><h3 id="HTTP的优点："><a href="#HTTP的优点：" class="headerlink" title="HTTP的优点："></a>HTTP的优点：</h3><ol><li><strong><em>灵活可扩展</em></strong>，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</li><li><strong><em>可靠传输</em></strong>。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</li><li><strong><em>请求-应答</em></strong>。也就是一发一收、有来有回，当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</li><li><strong><em>无状态</em></strong>。这里的状态是指通信过程的上下文信息，而每次 HTTP 请求都是独立、无关的，默认不需要保留状态信息。</li></ol><h3 id="HTTP的缺点："><a href="#HTTP的缺点：" class="headerlink" title="HTTP的缺点："></a>HTTP的缺点：</h3><ol><li><strong><em>无状态</em></strong>。在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 HTTP 的缺点了。</li><li><strong><em>明文传输</em></strong>。协议里的报文（主要指的是头部）不使用二进制数据，而是文本形式。</li><li><strong><em>队头阻塞问题</em></strong>。当 HTTP 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态。</li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="什么是https"><a href="#什么是https" class="headerlink" title="什么是https"></a>什么是https</h3><blockquote><p>https的SSL加密是在传输层实现的。</p></blockquote><p>以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p><p>简单来说 HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，比 HTTP 协议的安全性更高。</p><p>最后一个字母 S 指的是 SSL/TLS 协议，它位于 HTTP 协议与 TCP/IP 协议中间。</p><h3 id="https协议的工作原理"><a href="#https协议的工作原理" class="headerlink" title="https协议的工作原理"></a>https协议的工作原理</h3><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><ul><li>浏览器请求 URL，找到服务器，向服务器发送请求。服务器将自己的证书（包含服务器公钥）、对称加密算法种类以及其他相关信息返回给浏览器。</li><li>浏览器检查 CA 证书是否可依赖，确认证书有效。</li><li>如果不是，给服务器发警告，询问是否可以继续使用。</li><li>如果是，浏览器使用公钥加密一个随机对称秘钥，包含加密的 URL 一起发送给服务器。</li><li>服务器用自己的私钥解密浏览器发送的钥匙，然后用这把对称加密的钥匙给浏览器请求的 URL 连接解密。</li><li>服务器用浏览器发送的对称钥匙给请求的网页加密，浏览器使用相同的钥匙就可以解密网页。</li></ul><h3 id="https协议的优点"><a href="#https协议的优点" class="headerlink" title="https协议的优点"></a>https协议的优点</h3><ol><li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li><li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li></ol><h3 id="https协议的缺点"><a href="#https协议的缺点" class="headerlink" title="https协议的缺点"></a>https协议的缺点</h3><ol><li>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</li><li>https缓存不如http高效，会增加数据开销。</li><li>SSL证书也需要钱，功能越强大的证书费用越高。</li><li>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</li></ol><h2 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h2><p>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</p><p>主要的区别如下：</p><ol><li><strong><em>概念对比</em></strong>。HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</li><li><strong><em>费用对比</em></strong>。 HTTPS 协议需要 CA 证书，费用较高。</li><li><strong><em>连接方式和端口</em></strong>。使用不同的连接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li><li><strong><em>安全性对比</em></strong>。 HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ol><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><ul><li>GET：获取资源</li><li>HEAD：获取资源的元信息</li><li>POST：提交/上传 数据</li><li>PUT：修改数据</li><li>DELETE：删除资源（几乎用不到）</li><li>CONNECT：建立连接渠道，用于代理服务器</li><li>OPTIONS：列出可对资源实施的请求方法，用来跨域请求</li><li>TRACE：追踪请求-响应的传输路径</li></ul><h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><p>GET 和 POST 方法没有实质区别，只是报文格式不同。</p><p>GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议。</p><p>无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。</p><ul><li>GET 获取资源；POST 提交/上传 数据。</li><li>GET 请求长度在浏览器中有限制，而 POST 并没有。</li><li>GET 请求会被浏览器主动保留下来（历史记录），而 POST 默认不会。</li><li>get和post在缓存方面的区别：<ul><li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li><li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li></ul></li></ul><h3 id="【误】GET-请求传参长度有限制"><a href="#【误】GET-请求传参长度有限制" class="headerlink" title="【误】GET 请求传参长度有限制"></a>【误】GET 请求传参长度有限制</h3><p>【误】我们经常说 GET 请求参数的大小存在限制，而 POST 请求的参数大小是无限制的。</p><p>其实这是有问题的，实际上 HTTP 协议从来没规定 GET/POST 的请求长度限制是多少。</p><p>对 GET 请求参数的限制来源于浏览器或者 Web 服务器，是它们限制了这个长度。</p><p>不同的浏览器和 Web 服务器，限制的最大长度不一样。</p><h3 id="【误】POST-方法比-GET-方法安全"><a href="#【误】POST-方法比-GET-方法安全" class="headerlink" title="【误】POST 方法比 GET 方法安全"></a>【误】POST 方法比 GET 方法安全</h3><p>返回目录</p><p>【误】POST 比 GET 安全，是因为数据在地址栏 URL 看不见。</p><p>从传输角度来说，都是 HTTP 在网络上的明文传输，可以通过抓包工具完整获取的。</p><p>如果想安全，那就用 HTTPS 吧。</p><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p><code>HTTP</code> 的 <code>keep-alive</code> 也称为 <code>HTTP</code> 长连接。</p><p>它通过重用一个 TCP 连接来发送/接收多个 HTTP 请求，来减少创建/关闭多个 TCP 连接的开销。</p><p>在 HTTP/1.0 协议中，如果请求头中包含：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>则代表开启 keep-alive，而服务端的返回报文头中，也会包含相同的内容。</p><p>在 HTTP/1.1 协议中，默认开启 keep-alive，除非显式地关闭它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>当然，除此之外我们也可以设置断开的时间等：</p><p>Keep-Alive: timeout=5, max=100<br>这个就表示这个 TCP 通道可以保持 5 秒，max=100 表示这个长连接最多接收 100 次请求就断开。</p><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><h3 id="HTTP-状态码为-3-位数，被归为-5-类："><a href="#HTTP-状态码为-3-位数，被归为-5-类：" class="headerlink" title="HTTP 状态码为 3 位数，被归为 5 类："></a>HTTP 状态码为 3 位数，被归为 5 类：</h3><p>1XX：表示目前是协议处理的中间状态，还需要后续操作。<br>2XX：表示成功状态。<br>3XX：重定向状态，资源位置发生变动，需要重新请求。<br>4XX：请求报文有误。<br>5XX：服务器端发生错误。</p><h3 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h3><ul><li>101 Switching Protocols：在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码为 101。<h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3></li><li>200 OK：请求成功状态码，响应体中含有数据。</li><li>204 No Content：含义同 200，但是响应报文不含实体的主体部分。</li><li>206 Partial Content：表示部分内容请求成功。使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段 Content-Range。<h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3></li><li>301 Move Permanently：永久重定向。HTTP 升级 HTTPS，之前站点再也不用，那就是 301。</li><li>302 Found：临时重定向。当前站点暂时不可用，那就是 302，后续可能换回来。</li><li>304 Not Modified：当命中协商缓存时会返回这个状态码。<h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3></li><li>400 Bad Request：请求无效。通常为前后端数据格式不一致或者其他原因。</li><li>403 Forbidden：服务器已经得到请求，但是拒绝执行，比如没权限、法律禁止等。</li><li>404 Not Found：资源未找到，服务器不存在对应的资源。<h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h3></li><li>500 Internal Server Error：服务器报错，有些时候可以在 Response 看到后端 PHP 等技术的报错信息等。</li><li>502 Bad Gateway：服务器正常，但是访问出错。</li><li>503 Service Unavailable：服务器繁忙或者停机维护，暂时无法处理请求。</li></ul><h2 id="解决通讯安全问题"><a href="#解决通讯安全问题" class="headerlink" title="解决通讯安全问题"></a>解决通讯安全问题</h2><ol><li>对称加密： 可以理解为对原始数据的可逆变换</li><li>非对称加密: 有两个秘钥：一个公钥、一个私钥，客户端和服务器使用的是两个不同的秘钥</li><li>对称加密 + 非对称加密： HTTPS 就是采用这种对称加密和非对称加密两者并用的混合加密机制</li><li>第三方认证： 在 HTTPS 中，为了解决无法验证公钥正确性的问题，使用数字证书认证机构（CA）及其颁发的数字证书来解决这个问题。</li><li>第三方认证安全性</li></ol><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS（Domain Name System，域名系统），最初，由于 IP 地址长且难记，通过 IP 访问网站不方便。</p><p>所以后来通过发明了 DNS 服务器，这个时候我们访问网站输入网站域名，DNS 服务器就解析我们的域名为 IP。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>查询 <a href="http://www.baidu.com/">www.baidu.com</a></li><li>访问客户端 DNS 缓存：浏览器缓存 -&gt; 系统缓存（host） -&gt; 路由器缓存</li><li>访问 ISP DNS 服务器（ISP，互联网服务提供商，有联通电信移动等。如果你是电信网络，则进入电信的 DNS 缓存服务器，以下简称本地），如果本地服务器有，则直接返回；如果没有，让本地 DNS 服务器去逐个咨询查找。</li><li>本地去咨询 DNS 根服务器，DNS 根服务器发现是 .com 区域 管理的，告诉本地去咨询它。</li><li>本地去咨询 .com 顶级域服务器，.com 域服务器告诉本地去咨询 baidu.com 主区域 的服务器。</li><li>本地去咨询 baidu.com 主域名服务器，baidu.com 域服务器查找到对应的 IP 地址，返回给本地。</li><li>本地 DNS 云服务器通知用户对方 IP 地址，同时缓存这个 IP 地址，下次就直接访问了。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对计算机网络的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;HTTP-发展史&quot;&gt;&lt;a href=&quot;#HTTP-发展史&quot; class=&quot;headerlink&quot; title=&quot;HTTP 发展史&quot;&gt;&lt;/a&gt;HTT
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://github.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://github.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>浏览器兼容问题总结</title>
    <link href="http://github.com/2021/02/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://github.com/2021/02/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器兼容问题的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="安卓4-4操作系统下webviewH5页面访问空白？"><a href="#安卓4-4操作系统下webviewH5页面访问空白？" class="headerlink" title="安卓4.4操作系统下webviewH5页面访问空白？"></a>安卓4.4操作系统下webviewH5页面访问空白？</h2><p>原因：该webview浏览器内核版本太低，JavaScript解析器无法解析es5，es6新语法<br>解决步骤：利用babel polyfill对不兼容的语法进行处理</p><h2 id="样式的问题"><a href="#样式的问题" class="headerlink" title="样式的问题"></a>样式的问题</h2><p>问题：金额的前缀不显示，即￥这个标识显示不出来<br>原因： 低版本浏览器对utf-8字符￥不识别<br>解决方案：用html实体编号替代羊角，代码: <code>&lt;sub lang=&quot;en&quot;&gt;&amp;#165;&lt;/sub&gt;</code></p><h2 id="边框不显示"><a href="#边框不显示" class="headerlink" title="边框不显示"></a>边框不显示</h2><p>原因：为了方便编码，配置了px转义成rem的插件,vue.config.js中配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">css: &#123; <span class="comment">// 解决项目中自动添加浏览器厂商前缀等 和自动转换项目中px 到 rem单位</span></span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">        postcss: &#123;</span><br><span class="line">            plugins: [</span><br><span class="line">                <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>), <span class="built_in">require</span>(<span class="string">&#x27;postcss-px2rem&#x27;</span>)(&#123;</span><br><span class="line">                    remUnit: <span class="number">75</span></span><br><span class="line">                &#125;)</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该webpack编译插件致使 边框单位小于1px，浏览器无法渲染小于1px的像素（不同浏览器表现形式不太一样）</p><p>解决方案：从原来的2px改到3px，该解决方法还存在弊端，最好的方法是配置一下该插件对1px-2px不进行转换rem</p><h2 id="商品图片不显示"><a href="#商品图片不显示" class="headerlink" title="商品图片不显示"></a>商品图片不显示</h2><p>原因：之前使用100vw来撑开banner，vw不兼容低版本浏览器，导致banner高度为0</p><p>解决方法：js动态获取屏幕宽度，重新设置banner高度</p><h2 id="常遇到的关于浏览器的宽高问题："><a href="#常遇到的关于浏览器的宽高问题：" class="headerlink" title="常遇到的关于浏览器的宽高问题："></a>常遇到的关于浏览器的宽高问题：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var winW&#x3D;document.body.clientWidth||document.docuemntElement.clientWidth;</span><br><span class="line">&#x2F;&#x2F;网页可见区域宽</span><br><span class="line">var winH&#x3D;document.body.clientHeight||document.docuemntElement.clientHeight;&#x2F;&#x2F;网页可见区域宽</span><br></pre></td></tr></table></figure><p>//以上为不包括边框的宽高，如果是offsetWidth或者offsetHeight的话包括边框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var winWW&#x3D;document.body.scrollWidth||document.docuemntElement.scrollWidth;</span><br><span class="line">&#x2F;&#x2F;整个网页的宽</span><br><span class="line">var winHH&#x3D;document.body.scrollHeight||document.docuemntElement.scrollHeight;&#x2F;&#x2F;整个网页的高</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var scrollHeight&#x3D;document.body.scrollTop||document.docuemntElement.scrollTop;&#x2F;&#x2F;网页被卷去的高</span><br><span class="line">var scrollLeft&#x3D;document.body.scrollLeft||document.docuemntElement.scrollLeft;&#x2F;&#x2F;网页左卷的距离</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var screenH&#x3D;window.screen.height;&#x2F;&#x2F;屏幕分辨率的高</span><br><span class="line">var screenW&#x3D;window.screen.width;&#x2F;&#x2F;屏幕分辨率的宽</span><br><span class="line">var screenX&#x3D;window.screenLeft;&#x2F;&#x2F;浏览器窗口相对于屏幕的x坐标（除了FireFox）</span><br><span class="line">var screenXX&#x3D;window.screenX;&#x2F;&#x2F;FireFox相对于屏幕的X坐标</span><br><span class="line">var screenY&#x3D;window.screenTop;&#x2F;&#x2F;浏览器窗口相对于屏幕的y坐标（除了FireFox）</span><br><span class="line">var screenYY&#x3D;window.screenY;&#x2F;&#x2F;FireFox相对于屏幕的y坐标</span><br></pre></td></tr></table></figure><h2 id="event事件问题："><a href="#event事件问题：" class="headerlink" title="event事件问题："></a>event事件问题：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">document.onclick&#x3D;function(ev)&#123;&#x2F;&#x2F;谷歌火狐的写法，IE9以上支持，往下不支持；</span><br><span class="line">var e&#x3D;ev;</span><br><span class="line">console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">document.onclick&#x3D;function()&#123;&#x2F;&#x2F;谷歌和IE支持，火狐不支持；</span><br><span class="line">var e&#x3D;event;</span><br><span class="line">console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">document.onclick&#x3D;function(ev)&#123;&#x2F;&#x2F;兼容写法；</span><br><span class="line">    var e&#x3D;ev||window.event;</span><br><span class="line">    var mouseX&#x3D;e.clientX;&#x2F;&#x2F;鼠标X轴的坐标</span><br><span class="line">    var mouseY&#x3D;e.clientY;&#x2F;&#x2F;鼠标Y轴的坐标</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="DOM节点相关的问题，我直接封装了函数，以便随时可以拿来使用："><a href="#DOM节点相关的问题，我直接封装了函数，以便随时可以拿来使用：" class="headerlink" title="DOM节点相关的问题，我直接封装了函数，以便随时可以拿来使用："></a>DOM节点相关的问题，我直接封装了函数，以便随时可以拿来使用：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function nextnode(obj)&#123;&#x2F;&#x2F;获取下一个兄弟节点</span><br><span class="line">    if (obj.nextElementSibling) &#123;</span><br><span class="line">      return obj.nextElementSibling;</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">      return obj.nextSibling;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  function prenode(obj)&#123;&#x2F;&#x2F;获取上一个兄弟节点</span><br><span class="line">    if (obj.previousElementSibling) &#123;</span><br><span class="line">      return obj.previousElementSibling;</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">      return obj.previousSibling;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  function firstnode(obj)&#123;&#x2F;&#x2F;获取第一个子节点</span><br><span class="line">    if (obj.firstElementChild) &#123;</span><br><span class="line">      return obj.firstElementChild;&#x2F;&#x2F;非IE678支持</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">      return obj.firstChild;&#x2F;&#x2F;IE678支持</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  function lastnode(obj)&#123;&#x2F;&#x2F;获取最后一个子节点</span><br><span class="line">    if (obj.lastElementChild) &#123;</span><br><span class="line">      return obj.lastElementChild;&#x2F;&#x2F;非IE678支持</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">      return obj.lastChild;&#x2F;&#x2F;IE678支持</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="document-getElementsByClassName问题："><a href="#document-getElementsByClassName问题：" class="headerlink" title="document.getElementsByClassName问题："></a>document.getElementsByClassName问题：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过类名获取元素</span><br><span class="line">  document.getElementsByClassName(&#39;&#39;);&#x2F;&#x2F;IE 6 7 8不支持；</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F;这里可以定义一个函数来解决兼容问题，当然别在这给我提jQuery...</span><br><span class="line">  &#x2F;&#x2F;第一个为全局获取类名，第二个为局部获取类名</span><br><span class="line">  function byClass1(oClass)&#123;&#x2F;&#x2F;全局获取，oClass为你想要查找的类名，没有“.”</span><br><span class="line">    var tags&#x3D;document.all?document.all:document.getElementsByTagName(&#39;*&#39;);</span><br><span class="line">    var arr&#x3D;[];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; tags.length; i++) &#123;</span><br><span class="line">      var reg&#x3D;new RegExp(&#39;\\b&#39;+oClass+&#39;\\b&#39;,&#39;g&#39;);</span><br><span class="line">      if (reg.test(tags[i].className)) &#123;</span><br><span class="line">        arr.push(tags[i]);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr;&#x2F;&#x2F;注意返回的也是数组，包含你传入的class所有元素；</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function byClass2(parentID,oClass)&#123;&#x2F;&#x2F;局部获取类名，parentID为你传入的父级ID</span><br><span class="line">    var parent&#x3D;document.getElementById(parentID);</span><br><span class="line">    var tags&#x3D;parent.all?parent.all:parent.getElementsByTagName(&#39;*&#39;);</span><br><span class="line">    var arr&#x3D;[];</span><br><span class="line">    for (var i &#x3D; 0; i &lt; tags.length; i++) &#123;</span><br><span class="line">    var reg&#x3D;new RegExp(&#39;\\b&#39;+oClass+&#39;\\b&#39;,&#39;g&#39;);</span><br><span class="line">      if (reg.test(tags[i].className)) &#123;</span><br><span class="line">        arr.push(tags[i]);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr;&#x2F;&#x2F;注意返回的也是数组，包含你传入的class所有元素；</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="元素到浏览器边缘的距离："><a href="#元素到浏览器边缘的距离：" class="headerlink" title="元素到浏览器边缘的距离："></a>元素到浏览器边缘的距离：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在这里加个元素到浏览器边缘的距离，很实用</span><br><span class="line">  function offsetTL(obj)&#123;&#x2F;&#x2F;获取元素内容距离浏览器边框的距离（含边框）</span><br><span class="line">    var ofL&#x3D;0,ofT&#x3D;0;</span><br><span class="line">    while(obj)&#123;</span><br><span class="line">      ofL+&#x3D;obj.offsetLeft+obj.clientLeft;</span><br><span class="line">      ofT+&#x3D;obj.offsetTop+obj.clientTop;</span><br><span class="line">      obj&#x3D;obj.offsetParent;</span><br><span class="line">    &#125;</span><br><span class="line">    return&#123;left:ofL,top:ofT&#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器兼容问题的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;安卓4-4操作系统下webviewH5页面访问空白？&quot;&gt;&lt;a href=&quot;#安卓4-4操作系统下webviewH5页面访问空白？&quot; class
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript之基础篇</title>
    <link href="http://github.com/2021/02/01/TypeScript%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://github.com/2021/02/01/TypeScript%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对TS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>let isDone: boolean = false;</code></p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: number = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: number = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="keyword">let</span> binaryLiteral: number = <span class="number">0b1010</span>;</span><br><span class="line"><span class="keyword">let</span> octalLiteral: number = <span class="number">0o744</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: string = <span class="string">&quot;bob&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 方式1: 可以在元素类型后面接上 []，表示由此类型元素组成的一个数组</span></span><br><span class="line"><span class="keyword">let</span> list: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 方式2: 使用数组泛型，Array&lt;元素类型&gt;：</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [string, number];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>当访问一个越界的元素，会使用联合类型替代</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure><h3 id="枚举（Enum）"><a href="#枚举（Enum）" class="headerlink" title="枚举（Enum）"></a>枚举（Enum）</h3><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。<br>1.数字枚举</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  NORTH,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dir: Direction = Direction.NORTH;</span><br></pre></td></tr></table></figure><p>复制代码默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。上面的枚举示例代码经过编译后会生成以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;NORTH&quot;</span>] = <span class="number">0</span>)] = <span class="string">&quot;NORTH&quot;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;SOUTH&quot;</span>] = <span class="number">1</span>)] = <span class="string">&quot;SOUTH&quot;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;EAST&quot;</span>] = <span class="number">2</span>)] = <span class="string">&quot;EAST&quot;</span>;</span><br><span class="line">  Direction[(Direction[<span class="string">&quot;WEST&quot;</span>] = <span class="number">3</span>)] = <span class="string">&quot;WEST&quot;</span>;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> dir = Direction.NORTH;</span><br></pre></td></tr></table></figure><p>当然我们也可以设置 NORTH 的初始值，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  NORTH = <span class="number">3</span>,</span><br><span class="line">  SOUTH,</span><br><span class="line">  EAST,</span><br><span class="line">  WEST,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: any = <span class="number">4</span>;</span><br><span class="line">notSure.ifItExists(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.toFixed(); <span class="comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br></pre></td></tr></table></figure><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void。<br><br>声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p>undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和  void相似，它们的本身的类型用处不是很大</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。<br><br>当你指定了 –strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自。</p><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>never 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。<br><br>never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。<br>使用 object 类型，就可以更好的表示像 Object.create 这样的API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | null</span>): <span class="title">void</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">&#123; prop: <span class="number">0</span> &#125;</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">null</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="number">42</span></span>); // <span class="title">Error</span></span></span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。<br>类型断言有两种形式。 其一是“尖括号”语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (<span class="xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>someValue).length;</span></span><br></pre></td></tr></table></figure><p>另一个为 as 语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: any = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: number = (someValue <span class="keyword">as</span> string).length;</span><br></pre></td></tr></table></figure><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。</p><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>联合类型使用 | 分隔每个类型。</p><p>这里的 let myFavoriteNumber: string | number 的含义是，允许 myFavoriteNumber 的类型是 string 或者 number，但是不能是其他类型。</p><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>TypeScript 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson &#123;</span><br><span class="line">  id: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IWorker &#123;</span><br><span class="line">  companyId: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IStaff = IPerson &amp; IWorker;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> staff: IStaff = &#123;</span><br><span class="line">  id: <span class="string">&#x27;E1006&#x27;</span>,</span><br><span class="line">  age: <span class="number">33</span>,</span><br><span class="line">  companyId: <span class="string">&#x27;EFT&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(staff)</span><br></pre></td></tr></table></figure><p>在上面示例中，我们首先为 <code>IPerson</code> 和 <code>IWorker</code> 类型定义了不同的成员，然后通过 <code>&amp; </code>运算符定义了 <code>IStaff </code> 交叉类型，所以该类型同时拥有<code>IPerson</code>和 <code>IWorker </code>这两种类型的成员。</p><h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(<code>interface</code>)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person &#x3D; &#123;</span><br><span class="line">    name: &#39;Tom&#39;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接口一般首字母大写。有的编程语言中会建议接口的名称加上 I 前缀。</p><p>定义的变量比接口少了一些属性是不允许的,多一些属性也是不允许的,赋值的时候，变量的形状必须和接口的形状保持一致。</p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但仍然不允许添加未定义的属性：</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly 来指定只读属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">    readonly y: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过赋值一个对象字面量来构造一个 Point 。 赋值后， x 和 y 再也不能被改变了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1: Point = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line">p1.x = <span class="number">5</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>TypeScript 具有 ReadonlyArray<T> 类型，它与 Array<T> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;number&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，可以看到就算把整个 ReadonlyArray 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> number[];</span><br></pre></td></tr></table></figure><h3 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h3><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    gender: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>[propName: string]</code> 定义了任意属性取<code>string</code>类型的值。</p><p>需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><h3 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myAdd has the full function type</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="comment">// The parameters `x` and `y` have the type number</span></span><br><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">baseValue: number, increment: number</span>) =&gt;</span> number = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, lastName: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">&quot;Bob&quot;</span>);                  <span class="comment">// error, too few parameters</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>, <span class="string">&quot;Sr.&quot;</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>);         <span class="comment">// ah, just right</span></span><br></pre></td></tr></table></figure><p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在 TypeScript 里我们可以在参数名旁使用 ? 实现可选参数的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, lastName?: string</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>在 TypeScript 里，你可以把所有参数收集到一个变量里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, ...restOfName: string[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">&quot;Joseph&quot;</span>, <span class="string">&quot;Samuel&quot;</span>, <span class="string">&quot;Lucas&quot;</span>, <span class="string">&quot;MacKinzie&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="TypeScript-泛型"><a href="#TypeScript-泛型" class="headerlink" title="TypeScript 泛型"></a>TypeScript 泛型</h3><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。<br><br>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。<br><br>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。<br><br>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">  (arg: T): T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  zeroValue: T;</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;number&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="泛型变量"><a href="#泛型变量" class="headerlink" title="泛型变量"></a>泛型变量</h3><p>对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：</p><ul><li>T（Type）：表示一个 TypeScript 类型</li><li>K（Key）：表示对象中的键类型</li><li>V（Value）：表示对象中的值类型</li><li>E（Element）：表示元素类型</li></ul><h3 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h3><p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。</p><ol><li>typeof<br>在 TypeScript 中，typeof 操作符可以用来获取一个变量声明或对象的类型。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sem: Person = &#123; <span class="attr">name</span>: <span class="string">&#x27;semlinker&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line">type Sem= <span class="keyword">typeof</span> sem; <span class="comment">// -&gt; Person</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">x: number</span>): <span class="title">Array</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Func = <span class="keyword">typeof</span> toArray; <span class="comment">// -&gt; (x: number) =&gt; number[]</span></span><br></pre></td></tr></table></figure></li><li>keyof</li></ol><p>keyof 操作符可以用来一个对象中的所有 key 值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type K1 = keyof Person; <span class="comment">// &quot;name&quot; | &quot;age&quot;</span></span><br><span class="line">type K2 = keyof Person[]; <span class="comment">// &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot; </span></span><br><span class="line">type K3 = keyof &#123; [x: string]: Person &#125;;  <span class="comment">// string | number</span></span><br></pre></td></tr></table></figure><ol start="3"><li>in</li></ol><p>in 用来遍历枚举类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Keys = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span> | <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line">type Obj =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: any</span><br><span class="line">&#125; <span class="comment">// -&gt; &#123; a: any, b: any, c: any &#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>infer</li></ol><p>在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type ReturnType&lt;T&gt; &#x3D; T extends (</span><br><span class="line">  ...args: any[]</span><br><span class="line">) &#x3D;&gt; infer R ? R : any;</span><br></pre></td></tr></table></figure><p>以上代码中 <code>infer R</code> 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。<br>5. extends</p><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ILengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error, number doesn&#x27;t have a .length property</span></span><br></pre></td></tr></table></figure><p>这时我们需要传入符合约束类型的值，必须包含必须的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(&#123;<span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><ol start="6"><li>Partial</li></ol><p><code>Partial&lt;T&gt;</code> 的作用就是将某个类型里的属性全部变为可选项 <code>?</code>。<br>定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts</span><br><span class="line"> * Make all properties in T optional</span><br><span class="line"> *&#x2F;</span><br><span class="line">type Partial&lt;T&gt; &#x3D; &#123;</span><br><span class="line">  [P in keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在以上代码中，首先通过 <code>keyof T</code> 拿到 <code>T</code> 的所有属性名，然后使用 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后通过 <code>T[P]</code> 取得相应的属性值。中间的 <code>?</code> 号，用于将所有属性变为可选。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Todo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  description: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTodo</span>(<span class="params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo1 = &#123;</span><br><span class="line">  title: <span class="string">&quot;organize desk&quot;</span>,</span><br><span class="line">  description: <span class="string">&quot;clear clutter&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo2 = updateTodo(todo1, &#123;</span><br><span class="line">  description: <span class="string">&quot;throw out trash&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的 <code>updateTodo</code> 方法中，我们利用 <code>Partial&lt;T&gt;</code> 工具类型，定义 <code>fieldsToUpdate</code> 的类型为 <code>Partial&lt;Todo&gt;</code>，<br>即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   title?: string | <span class="literal">undefined</span>;</span><br><span class="line">   description?: string | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://juejin.cn/post/6844903842635579405">【面试篇】寒冬求职之你必须要懂的Web安全</a></p></li><li><p><a href="https://zoumiaojiang.com/article/common-web-security/#xss">常见 Web 安全攻防总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对TS的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;基础类型&quot;&gt;&lt;a href=&quot;#基础类型&quot; class=&quot;headerlink&quot; title=&quot;基础类型&quot;&gt;&lt;/a&gt;基础类型&lt;/h2&gt;&lt;h3 id=&quot;布
      
    
    </summary>
    
    
      <category term="TypeScript" scheme="http://github.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://github.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>JS之DOM事件流</title>
    <link href="http://github.com/2021/01/31/JS%E4%B9%8BDOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <id>http://github.com/2021/01/31/JS%E4%B9%8BDOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2021-01-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><blockquote><p>事件流描述的是从页面中接收事件的顺序</p></blockquote><p>DOM2级事件流包括下面几个阶段。</p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><h2 id="事件冒泡与事件捕获"><a href="#事件冒泡与事件捕获" class="headerlink" title="事件冒泡与事件捕获"></a>事件冒泡与事件捕获</h2><p>事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;outer&quot;</span>&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;inner&quot;</span>&gt;Click me!&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？为了解决这个问题微软和网景提出了两种几乎完全相反的概念。</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>微软(IE)提出了名为事件冒泡(event bubbling)的事件流。</p><p>事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。</p><p>因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是:</p><p>p -&gt; div -&gt; body -&gt; html -&gt; document</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>网景提出另一种事件流名为事件捕获(event capturing)。</p><p>与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。</p><p>上面的例子在事件捕获的概念下发生click事件的顺序应该是:</p><p>document -&gt; html -&gt; body -&gt; div -&gt; p</p><h3 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h3><blockquote><p>W3C 对这两种方案进行了统一：将 DOM 事件分为两个阶段，事件捕获和事件冒泡阶段</p></blockquote><p>当一个元素被点击，首先是事件捕获阶段，window 最先接收事件，然后一层一层往下捕获，最后由具体元素接收；之后再由具体元素再一层一层往上冒泡，到 window 接收事件。</p><h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h3><blockquote><p>E浏览器对addEventListener兼容性并不算太好，只有IE9以上可以使用。</p></blockquote><p><code>DOM2级事件</code>中规定的事件流同时支持了事件捕获阶段和事件冒泡阶段，而作为开发者，我们可以选择事件处理函数在哪一个阶段被调用。</p><p><code>addEventListener</code>方法用来为一个特定的元素绑定一个事件处理函数，是<code>JavaScript</code>中的常用方法。</p><blockquote><p><code>element.addEventListener(event, function, useCapture)</code></p></blockquote><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">event</td><td align="left">必须。字符串，指定事件名。<br>注意: 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。<br>提示： 所有 HTML DOM 事件，</td></tr><tr><td align="left">function</td><td align="left">必须。指定要事件触发时执行的函数。<br>当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。<br>例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。</td></tr><tr><td align="left">useCapture</td><td align="left">可选。布尔值，指定事件是否在捕获或冒泡阶段执行。<br>可能值:<br>true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）<br>false(默认值)。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）</td></tr></tbody></table><h3 id="如何让事件先冒泡后捕获"><a href="#如何让事件先冒泡后捕获" class="headerlink" title="如何让事件先冒泡后捕获"></a>如何让事件先冒泡后捕获</h3><p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。</p><h2 id="事件委托-代理"><a href="#事件委托-代理" class="headerlink" title="事件委托(代理)"></a>事件委托(代理)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</p><h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2><ol><li>给子级加 <code>event.stopPropagation( )</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#div1&quot;</span>).mousedown(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=event||<span class="built_in">window</span>.event;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>在事件处理函数中返回 <code>false</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#div1&quot;</span>).mousedown(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=e||<span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>但是这两种方式是有区别的。</li></ol><ul><li><code>return false</code> 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。</li><li><code>event.stopPropagation()</code>则只阻止事件往上冒泡，不阻止事件本身。</li></ul><p>3.  <code>event.target==event.currentTarget</code>，让触发事件的元素等于绑定事件的元素，也可以阻止事件冒泡；</p><h2 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h2><ul><li>（1）event.preventDefault( )</li><li>（2）return false</li></ul><h2 id="并不是所有的事件都有冒泡"><a href="#并不是所有的事件都有冒泡" class="headerlink" title="并不是所有的事件都有冒泡"></a>并不是所有的事件都有冒泡</h2><p>例如：</p><ul><li><code>onblur</code></li><li><code>onfocus</code></li><li><code>onmouseenter</code></li><li><code>onmouseleave</code></li></ul><h2 id="onmouseover-和-onmouseenter-区别"><a href="#onmouseover-和-onmouseenter-区别" class="headerlink" title="onmouseover 和 onmouseenter 区别"></a>onmouseover 和 onmouseenter 区别</h2><ul><li><p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</p></li><li><p>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</p></li></ul><p>这两者都是移入的时候触发，但是 onmouseover 会触发多次，而 onmouseenter 只在进去的时候才触发。</p><h2 id="JS-位置"><a href="#JS-位置" class="headerlink" title="JS 位置"></a>JS 位置</h2><ul><li><code>clientHeight</code>：表示可视区域的高度，不包含 <code>border</code> 和滚动条</li><li><code>offsetHeight</code>：表示可视区域的高度，包含了 <code>border</code> 和滚动条</li><li><code>scrollHeight</code>：表示了所有区域的高度，包含了因为滚动被隐藏的部分</li><li><code>clientTop</code>：表示边框 border 的厚度，在未指定的情况下一般为0</li><li><code>scrollTop</code>：滚动后被隐藏的高度，获取对象相对于由 <code>offsetParent </code>属性指定的父坐标（CSS 定位的元素或 body 元素）距离顶端的高度。</li></ul><h2 id="js拖拽功能的实现"><a href="#js拖拽功能的实现" class="headerlink" title="js拖拽功能的实现"></a>js拖拽功能的实现</h2><ol><li>通过 mousedown、mousemove、mouseup 方法实现</li></ol><ul><li><p>首先是三个事件，分别是mousedown，mousemove，mouseup,当鼠标点击按下的时候，需要一个tag标识此时已经按下，可以执行mousemove里面的具体方法。</p></li><li><p>clientX，clientY标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用offsetX和offsetY来表示元素的元素的初始坐标，<br><br>移动的举例应该是：<br><br>鼠标移动时候的坐标-鼠标按下去时候的坐标。<br><br>也就是说定位信息为：<br><br>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft.<br></p></li></ul><ol start="2"><li>可以通过html5的拖放（Drag 和 drop）来实现</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903834075021326#heading-0">你真的理解事件冒泡和事件捕获吗</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对原生JS的知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h2&gt;&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="原生JS" scheme="http://github.com/categories/%E5%8E%9F%E7%94%9FJS/"/>
    
    
      <category term="原生JS" scheme="http://github.com/tags/%E5%8E%9F%E7%94%9FJS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之从重绘和重排</title>
    <link href="http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/"/>
    <id>http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92/</id>
    <published>2021-01-29T16:00:00.000Z</published>
    <updated>2021-01-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><blockquote><p>回流必将引起重绘，重绘不一定会引起回流</p></blockquote><h2 id="浏览器的渲染"><a href="#浏览器的渲染" class="headerlink" title="浏览器的渲染"></a>浏览器的渲染</h2><ol><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display:将像素发送给GPU，展示在页面上。</li></ol><h2 id="回流-Reflow-重绘"><a href="#回流-Reflow-重绘" class="headerlink" title="回流 (Reflow)(重绘)"></a>回流 (Reflow)(重绘)</h2><p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p><h3 id="会导致回流的操作："><a href="#会导致回流的操作：" class="headerlink" title="会导致回流的操作："></a>会导致回流的操作：</h3><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除可见的DOM元素</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法</li></ul><h3 id="一些常用且会导致回流的属性和方法："><a href="#一些常用且会导致回流的属性和方法：" class="headerlink" title="一些常用且会导致回流的属性和方法："></a>一些常用且会导致回流的属性和方法：</h3><ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>scrollIntoView()、scrollIntoViewIfNeeded()</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li><li>scrollTo()</li></ul><h2 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘 (Repaint)"></a>重绘 (Repaint)</h2><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><h3 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h3><p>回流比重绘的代价要更高。</p><p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</p><p>现代浏览器会对频繁的回流或重绘操作进行优化：</p><p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p><p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p><ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>width、height</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li></ul><p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p><h3 id="如何触发重绘？"><a href="#如何触发重绘？" class="headerlink" title="如何触发重绘？"></a>如何触发重绘？</h3><ul><li>修改背景色、颜色（background、color）</li><li>设置可见度（visibility）</li><li>设置背景图（background-image）</li></ul><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><p>CSS</p><ul><li>避免使用table布局。</li><li>尽可能在DOM树的最末端改变class。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到position属性为absolute或fixed的元素上。</li><li>避免使用CSS表达式（例如：calc()）。</li></ul><p>JavaScript</p><ul><li>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li><li>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li><li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><h2 id="减少重绘和回流的细节："><a href="#减少重绘和回流的细节：" class="headerlink" title="减少重绘和回流的细节："></a>减少重绘和回流的细节：</h2><ol><li>使用 translate 替代 top</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>尽量算出结果再去重绘把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame  Load 和 DOMContentLoaded 区别。Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000017329980">你真的了解回流和重绘吗</a></li><li><a href="https://juejin.cn/post/6844903569087266823">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></li><li><a href="https://juejin.cn/post/6844903569087266823">回流与重绘：CSS性能让JavaScript变慢？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;回流必将引起重绘，重绘不一定会引起回流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;浏览器的渲染&quot;&gt;&lt;a href=&quot;#浏览器
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之从输入 URL 到页面呈现</title>
    <link href="http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0/"/>
    <id>http://github.com/2021/01/30/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0/</id>
    <published>2021-01-29T16:00:00.000Z</published>
    <updated>2021-01-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改（浏览器的工作原理）</p><h2 id="整体过程"><a href="#整体过程" class="headerlink" title="整体过程"></a>整体过程</h2><p>在用户输入 URL，按下回车之后，走过的步骤：</p><ul><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器响应</li><li>浏览器解析渲染页面</li></ul><h2 id="具体阶段"><a href="#具体阶段" class="headerlink" title="具体阶段"></a>具体阶段</h2><ul><li>用户输入阶段</li><li>发起URL请求阶段</li><li>准备渲染进程阶段</li><li>提交文档阶段</li><li>页面渲染阶段</li></ul><h2 id="用户输入阶段"><a href="#用户输入阶段" class="headerlink" title="用户输入阶段"></a>用户输入阶段</h2><ul><li>合成 URL：用户输入 URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容 + 默认搜索引擎合成新的 URL；如果用户输入的内容符合 URL 规则，浏览器就会根据 URL 协议，在这段内容上加上协议合成合法的 URL；</li><li>加载：用户输入完内容，按下回车键，浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得；</li></ul><h2 id="发起URL请求阶段"><a href="#发起URL请求阶段" class="headerlink" title="发起URL请求阶段"></a>发起URL请求阶段</h2><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/30/XovFHrwqVeN37ds.png"></p><h3 id="开始阶段"><a href="#开始阶段" class="headerlink" title="开始阶段"></a>开始阶段</h3><ol><li><p>构建请求：浏览器进程首先会构建请求行信息，然后通过进程间通信（IPC）将 URL 请求发送给网络进程；</p></li><li><p>查找缓存：网络进程获取到 URL，先去本地缓存中查找是否有缓存资源，如果有则拦截请求，直接将缓存资源返回给浏览器进程；否则，进入网络请求阶段；</p></li></ol><h3 id="网络请求阶段-从服务器获取资源"><a href="#网络请求阶段-从服务器获取资源" class="headerlink" title="网络请求阶段(从服务器获取资源)"></a>网络请求阶段(从服务器获取资源)</h3><ol><li><p><code>DNS</code> 解析：网络进程请求首先会从 <code>DNS</code> 数据缓存服务中查找是否缓存过当前域名信息，有则直接返回；否则，会进行 DNS 解析返回域名对应的 IP 和端口号，如果没有指定端口号，<code>http</code> 默认<code> 80</code> 端口，<code>https</code> 默认 <code>443</code>。如果是 <code>https</code> 请求，还需要建立 <code>TLS</code> 连接；</p></li><li><p>等待 <code>TCP</code> 队列：<code>Chrome</code> 有个机制，同一个域名同时最多只能建立 <code>6</code> 个 <code>TCP</code> 连接，如果在同一个域名下同时有 <code>10 </code>个请求发生，那么其中 <code>4</code> 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于<code>6</code>个，会直接建立 <code>TCP</code> 连接；</p></li><li><p>建立 <code>TCP</code> 连接：<code>TCP</code> 三次握手与服务器建立连接，然后进行数据的传输，最后；</p></li><li><p>发送 <code>HTTP</code> 请求：浏览器首先会向服务器发送请求行，它包含了请求方法、请求 <code>URI</code> 和 <code>HTTP</code> 协议的版本；另外还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核，请求域名、<code>Cookie</code> 等；如果需要传递参数，则还需要发送请求体；</p></li><li><p>服务器处理请求：服务器首先返回响应行，包括协议版本和状态码，比如状态码 <code>200</code> 表示继续处理该请求；（如果是 <code>301</code>，则表示重定向，将会在响应头的 <code>Locaiton</code> 字段中加上重定向的地址信息，接下来浏览器获取这个地址，将会重新导航。）服务器也会向浏览器发送响应头，包含了一些信息，比如服务器生成返回数据的时间、返回的数据类型（<code>JSON</code>、<code>HTML</code>、<code>流媒体</code>等类型），以及服务器要在客户端保存的 <code>Cookie</code> 等；继续发送响应体的数据；(服务器处理请求完毕后，会返回 HTTP 报文)</p></li><li><p>断开 <code>TCP</code> 连接：数据传输完成，正常情况下 <code>TCP</code> 将四次挥手断开连接。但是如果浏览器或者服务器在<code>HTTP</code>头部加上 <code>Connection: keep-alive</code>，<code>TCP</code> 就会一直保持连接。保持 <code>TCP</code> 连接可以省下下次需要建立连接的时间，提示资源加载速度；</p></li></ol><h2 id="准备渲染进程阶段"><a href="#准备渲染进程阶段" class="headerlink" title="准备渲染进程阶段"></a>准备渲染进程阶段</h2><blockquote><p>将获取到的数据包进行解析</p></blockquote><ol><li><p>网络进程将获取到的数据包进行解析，根据响应头中的 <code>Content-type</code> 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是 <code>text/html</code> 类型，就通知浏览器进程获取到的是 <code>HTML</code>，应该准备渲染进程了；</p></li><li><p>正常情况下每个浏览器的 <code>tab</code> 会对应一个渲染进程，但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程，否则就会创建一个新的渲染进程；</p></li></ol><h2 id="提交文档阶段"><a href="#提交文档阶段" class="headerlink" title="提交文档阶段"></a>提交文档阶段</h2><ol><li><p>渲染进程准备好后，浏览器会发出 <code>&quot;提交文档&quot;</code> 的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的 <code>&quot;管道&quot;</code>，文档数据传输完成后，渲染进程会返回<code>&quot;确认提交&quot;</code>的消息给浏览器进程；</p></li><li><p>浏览器收到 <code>&quot;确认提交&quot;</code> 的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 <code>web</code> 页面，此时的 <code>web</code> 页面是空白页；</p></li></ol><h2 id="页面渲染阶段"><a href="#页面渲染阶段" class="headerlink" title="页面渲染阶段"></a>页面渲染阶段</h2><ol><li><p>文档一旦提交，渲染进程将开始页面解析和子资源加载；渲染阶段比较复杂，所以将分为多个子阶段，按照渲染的时间顺序可以分为：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成；</p></li><li><p>构建 DOM 树：HTML 经过解析器后输出一个以 document 为顶层节点的树状结构的 DOM；</p></li><li><p>样式计算：这里有 3 个步骤：</p><ul><li>将 3 个来源（<code>&lt;link&gt;</code> 标签引入的外部样式、<code>&lt;style&gt;</code> 标签里定义的样式、以及元素的 <code>style</code> 属性上的样式）的 <code>CSS</code> 转化成浏览器能够理解的结构 <code>styleSheets</code>；</li><li>转换样式表中的属性值，使其标准化；比如 <code>font-weight: bold</code>; 会转成 <code>font-weight: 700</code>;， <code>color: blue</code>; 会转成 <code>color: rgb(0, 0, 255)</code>; 等；</li><li>依据 <code>CSS</code> 的继承和层叠规则计算出 <code>DOM</code> 树中每个节点的具体样式；</li></ul></li><li><p>布局阶段：<code>DOM</code> 树中依然存在许多不可见的元素（比如 <code>head</code>），这些元素对于布局是丝毫没用的，所以又会生成一棵只包含可见元素的布局树；然后再根据布局树的每个节点计算出其具体位置和尺寸大小；</p></li><li><p>分层：页面中有很多复杂的效果，如一些复杂的 <code>3D</code> 变换、页面滚动，或者使用 <code>z-index</code> 做 <code>z</code> 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树；关于层叠上下文的知识，具体可以参考这里彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、<code>z-index</code>；</p></li><li><p>绘制：为每个图层生成绘制列表，并将其提交到合成线程；</p></li><li><p>光栅化：通常一个页面很大，而视口很局限，所以合成线程会按照视口附近的图块来优先生成位图，并在光栅化线程池中将图块转换成位图；</p></li><li><p>合成：一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令 <code>DrawQuad</code>，然后将该命令提交给浏览器进程；之后浏览器将开始生成显示页面。</p></li></ol><h2 id="渲染过程（此为面试回答）"><a href="#渲染过程（此为面试回答）" class="headerlink" title="渲染过程（此为面试回答）"></a>渲染过程（此为面试回答）</h2><h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><ul><li>解析 <code>HTML</code>，生成 <code>DOM</code> 树</li><li>解析 <code>CSS</code>，生成 <code>CSS</code> 规则树（<code>CSS Rule Tree</code>）</li><li>将 <code>DOM Tree</code> 和 <code>CSS Rule Tree</code> 相结合，生成 渲染树（<code>Render Tree</code>）</li><li>从根节点开始，计算每一个元素的大小、位置，给出每个节点所应该出现的屏幕精确坐标，(计算每个节点的位置)从而得到基于渲染树的 布局渲染树（<code>Layout of the render tree</code>）。</li><li>遍历渲染树，将每个节点用 <code>UI</code> 渲染引擎来绘制，从而将整棵树绘制到页面上，这个步骤叫 绘制渲染树（<code>Painting the render tree</code>）(调用 GPU 绘制，合成图层，显示在屏幕上)</li></ul><h3 id="在解析渲染过程中，可能会产生-回流-和-重绘："><a href="#在解析渲染过程中，可能会产生-回流-和-重绘：" class="headerlink" title="在解析渲染过程中，可能会产生 回流 和 重绘："></a>在解析渲染过程中，可能会产生 回流 和 重绘：</h3><ul><li><p>重绘(repaint)：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此损耗较少。</p></li><li><p>回流(reflow)：又叫重排（layout）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。</p></li></ul><h3 id="渲染过程碰到-JS-文件"><a href="#渲染过程碰到-JS-文件" class="headerlink" title="渲染过程碰到 JS 文件"></a>渲染过程碰到 JS 文件</h3><blockquote><p>JavaScript 的加载、解析和执行会阻塞 DOM 的构建。</p></blockquote><p>在构建 <code>DOM</code> 的时候，<code>HTML</code> 解析器如果碰到 <code>JavaScript</code>，那么就会停止构建 <code>DOM</code>，将控制权交给 <code>JavaScript</code> 引擎，等 <code>JavaScript</code> 运行完毕，浏览器再从中断的地方恢复 <code>DOM</code> 构建。</p><p>也就是说：首屏渲染越快，就越不应该在首屏的时候加载 JS 文件，这也就是建议将 script 标签放到 body 标签底部，或者给 script 标签添加 defer/async 属性的原因。</p><h3 id="为什么操作-DOM-慢"><a href="#为什么操作-DOM-慢" class="headerlink" title="为什么操作 DOM 慢"></a>为什么操作 DOM 慢</h3><ol><li>涉及 JS 引擎和渲染引擎两个线程间的通信，损耗性能。</li><li>操作 DOM 可能会重复回流，加剧性能损耗。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6909258409250553869">「面试常问」从输入 URL 到显示发生了什么（ 99 分答案）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改（浏览器的工作原理）&lt;/p&gt;
&lt;h2 id=&quot;整体过程&quot;&gt;&lt;a href=&quot;#整体过程&quot; class=&quot;headerlink&quot; title=&quot;整体过程&quot;&gt;&lt;/a&gt;整体过程&lt;/h
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之本地存储</title>
    <link href="http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <id>http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</id>
    <published>2021-01-27T16:00:00.000Z</published>
    <updated>2021-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="HTTP无状态"><a href="#HTTP无状态" class="headerlink" title="HTTP无状态"></a>HTTP无状态</h2><blockquote><p>HTTP无状态协议，是指协议对于交互性场景没有记忆能力。</p></blockquote><p><code>HTTP</code> 是无状态的，即它不会记住用户的操作，服务器单纯从网络连接上无从知道客户身份, 这让我们在记住用户状态等场景被限制</p><p>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。</p><p>比如服务器不知道某个用户是否已登录过了。因为愚蠢的服务器不知道客户端是否已登录过了,所以每次都要在交互场景(会话)中请求中带上上一次的请求信息，如账号、密码。明明只需要在<code>/login</code>接口中，才需要对比数据库中的账号密码和客户端传的是否一致来确定合法性。这下在添加购物车中也需要再一次的进行同样的重复且没有必要的操作，即降低了响应速度，又对用户不友好（因为每次都需要填账号，密码）。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><code>Cookie</code> 最开始被设计出来其实并不是来做本地存储的，而是为了弥补 <code>HTTP</code> 在状态管理上的不足。</p><p><code>Cookie</code> 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。</p><p>向同一个域名下发送请求，都会携带相同的 <code>Cookie</code>，服务器拿到 <code>Cookie</code> 进行解析，便能拿到客户端的状态。</p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol><li><p>A: 首先，客户端会发送一个<code>http</code>请求到服务器端。</p></li><li><p>B: 服务器端接受客户端请求后，发送一个<code>http</code>响应到客户端，这个响应头，其中就包含<code>Set-Cookie</code>头部。</p></li><li><p>C: 在客户端发起的第二次请求（注意：如果服务器需要我们带上<code>Cookie</code>，我们就需要在B步骤上面拿到这个<code>Cookie</code>然后作为请求头一起发起第二次请求），提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了<code>cookies</code>。尽管，用户可能在和应用程序交互的过程中突然禁用<code>cookies</code>的使用，但是，这个情况基本是不太可能发生的，所以可以不加以考虑，这在实践中也被证明是对的。</p></li></ol><h3 id="Cookie的不可跨域名性"><a href="#Cookie的不可跨域名性" class="headerlink" title="Cookie的不可跨域名性"></a>Cookie的不可跨域名性</h3><p><code>Cookie</code>具有不可跨域名性。根据<code>Cookie</code>规范，浏览器访问<code>Google</code>只会携带<code>Google</code>的<code>Cookie</code>，而不会携带<code>Baidu</code>的<code>Cookie</code>。<code>Google</code>也只能操作<code>Google</code>的<code>Cookie</code>，而不能操作<code>Baidu</code>的<code>Cookie</code>。</p><p><code>Cookie</code>在客户端是由浏览器来管理的。浏览器能够保证<code>Google</code>只会操作<code>Google</code>的<code>Cookie</code>而不会操作<code>Baidu</code>的<code>Cookie</code>，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站<code>Cookie</code>的依据是域名。<code>Google</code>与<code>Baidu</code>的域名不一样，因此<code>Google</code>不能操作<code>Baidu</code>的<code>Cookie</code>。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>cookie, 如果不设置过期时间，cookie保存在内存中，生命周期随浏览器的关闭而结束，如果设置了过期时间，cookie保存在硬盘中，关闭浏览器，cookie数据直到过期时间而消失；cookie是服务器发给客户端的特殊信息，cookie是以文本的形式保存在客户端，每次请求都会带上它；</p><h3 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h3><ul><li>容量缺陷。体积上线 4kb，只能存储少量信息。用户禁用cookie,就会使其功能受限</li><li>性能缺陷。Cookie 请求每次都会携带上完整的 Cookie，随着请求数增多，造成性能浪费。</li><li>安全缺陷。以纯文本的形式在浏览器和服务器中传递，容易被非法截获和篡改。</li></ul><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><h3 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h3><p><code>Local Storge</code> 相对 <code>Cookie</code> 而言，它也是针对同一个域名。<br>同一个域名下，会存储相同的一段 <code>Local Storage</code>。</p><h4 id="设置与取值"><a href="#设置与取值" class="headerlink" title="设置与取值"></a>设置与取值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置：</span></span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jsliang&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;jsliang&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&quot;info&quot;</span>, <span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值：</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> info = <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;info&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="相比-Cookie-优势"><a href="#相比-Cookie-优势" class="headerlink" title="相比 Cookie 优势"></a>相比 Cookie 优势</h4><ol><li>容量。体积上线 <code>5M</code>，大于 <code>Cookie</code> 的 <code>4kb</code>。</li><li>只存在客户端。不参与和服务端的通讯，避免 <code>Cookie</code> 的性能缺陷和安全缺陷。</li><li>接口封装。有 <code>setItem</code> 和 <code>getItem</code> 两个<code>API</code>接口。</li></ol><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ol><li>以 <code>Base64</code> 方式存储官方 <code>Logo</code> 等图片。</li></ol><h3 id="Session-Storage"><a href="#Session-Storage" class="headerlink" title="Session Storage"></a>Session Storage</h3><p>基本上和 <code>Local Stoarge</code> 一致。</p><h4 id="相比Local-Storage："><a href="#相比Local-Storage：" class="headerlink" title="相比Local Storage："></a>相比Local Storage：</h4><p>会话级别的存储。不同于 <code>Local Storage</code> 的持续化存储，<code>Session Storage</code> 当页面关闭的时候就不复存在了。</p><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><ol><li><p>对表单信息做维护。用户刷新页面不丢失。</p></li><li><p>存储本次浏览记录。看过的页面不怕找不到。</p><h3 id="localStorage和sessionStorage："><a href="#localStorage和sessionStorage：" class="headerlink" title="localStorage和sessionStorage："></a>localStorage和sessionStorage：</h3></li><li><p>生命周期：localStorage的生命周期是永久的，关闭页面也不会消失，除非是主动删除；sessionStorage的生命周期是仅在当前会话下有效</p></li><li><p>存储大小：localStorage和sessionStorage的存储数据一般都是5mb;</p></li><li><p>存储内容类型：都只能存储字符串类型；</p></li><li><p>获取方式：localStorage: window.localStorage; sessionStorage: window.sessionStorage;</p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexedDB 是运行在浏览器中的 非关系型数据库。</p></li></ol><p>因为本质上是数据库，所以一般来说容量是没有上线的。</p><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token只能被保存在客户端的cookie或localstorage中，因为用户的状态在服务端的内存中是不能存储的，所以这是一种无状态的认证机制；</p><h3 id="为什么需要token"><a href="#为什么需要token" class="headerlink" title="为什么需要token"></a>为什么需要token</h3><p>众所周知，HTTP 是无状态协议，即它对于交互性场景没有记忆能力。</p><p>但是，如果碰到某些场景，就有点无奈了：</p><ul><li>输入账号密码进行登录</li><li>将商品加入购物车</li><li>点击支付，发现用户要重新登录</li></ul><p>我们可以通过 token 来维持用户的登录态</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><blockquote><p>用户 id + 过期时间 + SecretKey</p></blockquote><p><code>&quot;用户 id&quot; + &quot;过期时间&quot; + SHA1(&quot;用户 id&quot; + &quot;用户口令&quot; + &quot;过期时间&quot; + &quot;SecretKey&quot;)</code></p><p>这样，当浏览器发送请求给服务器，token 会通过 cookie 等形式将上面实例内容传输给服务器。</p><p>服务器拿到数据后，根据用户 id 查找用户口令，并进一步计算是否已过期，从而判断用户是否需要重新登录。</p><p>需要重新登录则跳转到登录页面，不需要重新登录则进行支付流程。</p><h4 id="token认证流程"><a href="#token认证流程" class="headerlink" title="token认证流程"></a>token认证流程</h4><ol><li>用户登录校验，校验成功后就返回<code>Token</code>给客户端;</li><li>客户端收到数据后就保存在客户端;</li><li>客户端每次访问<code>api</code>就携带<code>Token</code>到服务端 ;</li><li>服务端采用<code>filter</code>过滤器校验，校验成功后返回请求数据，校验失败则返回校验码；<h4 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h4></li></ol><p>A：当用户首次登录成功（注册也是一种可以适用的场景）之后, 服务器端就会生成一个token值，这个值，会在服务器保存token值(保存在数据库中)，再将这个token值返回给客户端。</p><p>B：客户端拿到token值之后,进行本地保存（SP存储是大家能够比较支持和易于理解操作的存储）。</p><p>C：当客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个token值附带到参数中发送给服务器。</p><p>D：服务器接收到客户端的请求之后,会取出token值与保存在本地(数据库)中的token值做对比:</p><ul><li>对比一：如果两个 token 值相同， 说明用户登录成功过!当前用户处于登录状态！</li><li>对比二：如果没有这个 token 值, 则说明没有登录成功。</li><li>对比三：如果 token 值不同: 说明原来的登录信息已经失效,让用户重新登录。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ul><ul><li><a href="https://blog.csdn.net/qq_36632174/article/details/102402203">cookie、Session、Token、sessionStorage、localStorage简介</a></li><li><a href="https://blog.csdn.net/yinge0508/article/details/95761173">session,cookie,sessionStorage,localStorage,token的区别？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;HTTP无状态&quot;&gt;&lt;a href=&quot;#HTTP无状态&quot; class=&quot;headerlink&quot; title=&quot;HTTP无状态&quot;&gt;&lt;/a&gt;HTTP无状态&lt;
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器之跨域</title>
    <link href="http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E8%B7%A8%E5%9F%9F/"/>
    <id>http://github.com/2021/01/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B9%8B%E8%B7%A8%E5%9F%9F/</id>
    <published>2021-01-27T16:00:00.000Z</published>
    <updated>2021-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><blockquote><p>所谓 源，可以指 URL。</p></blockquote><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>简单来看某个 URL 组成；</p><p><code>https://lonelyzou.github.io/longin</code></p><ul><li>名称    举例</li><li>协议    <code>http</code>、<code>https</code></li><li>域名    <code>lonelyzou.github.io</code></li><li>端口    80、443</li><li>其中，如果 URL 上未标明端口，那么 http 默认是 80 端口，https 默认是 443 端口。</li></ul><p>而所谓的同源策略，是指这 3 个（协议、域名、端口）一致的情况下，才属于同源。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>对于下面的 URL，我们判断下哪些属于同源哪些属于不同源：</p><ul><li><a href="https://github.com/LiangJunrong/document-library">https://github.com/LiangJunrong/document-library</a><table><thead><tr><th align="left">URL</th><th align="left">是否同源</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left"><a href="http://github.com/">http://github.com</a></td><td align="left">否</td><td align="left">协议不同</td></tr><tr><td align="left"><a href="https://github2.com/">https://github2.com</a></td><td align="left">否</td><td align="left">域名不同</td></tr><tr><td align="left"><a href="https://github.com:80/LiangJunrong">https://github.com:80/LiangJunrong</a></td><td align="left">否</td><td align="left">https 默认端口为 443</td></tr><tr><td align="left"><a href="https://money.github.com/">https://money.github.com</a></td><td align="left">是</td><td align="left">多级域名和主域名一致</td></tr></tbody></table></li></ul><p>在上面，如果两个页面对应的地址不同源，那么浏览器就会判定跨域，从而导致下面问题：</p><ul><li>Ajax 请求不能发送</li><li>无法获取 DOM 元素并进行操作</li><li>无法读取 Cookie、LocalStorage 和 IndexDB<blockquote><p>有些请求是不受到跨域限制。例如：WebSocket，script、img、iframe、video、audio标签的src属性等。</p></blockquote><h3 id="出于怎样的考虑，浏览器才要设置跨域？"><a href="#出于怎样的考虑，浏览器才要设置跨域？" class="headerlink" title="出于怎样的考虑，浏览器才要设置跨域？"></a>出于怎样的考虑，浏览器才要设置跨域？</h3></li></ul><ol><li><p>首先，跨域只存在于浏览器端，因为我们知道浏览器的形态是很开放的，所以我们需要对它有所限制。</p></li><li><p>其次，同源策略主要是为了保证用户信息的安全，可分为两种：Ajax 同源策略和 DOM 同源策略。</p></li><li><p>Ajax 同源策略主要是使得不同源的页面不能获取 Cookie 且不能发起 Ajax 请求，这样在一定层度上防止了 CSRF 攻击。</p></li><li><p>DOM 同源策略也一样，它限制了不同源页面不能获取 DOM，这样可以防止一些恶意网站在自己的网站中利用 iframe 嵌入正规的网站并迷惑用户，以此来达到窃取用户信息。</p></li></ol><h3 id="实际开发场景为什么会出现跨域："><a href="#实际开发场景为什么会出现跨域：" class="headerlink" title="实际开发场景为什么会出现跨域："></a>实际开发场景为什么会出现跨域：</h3><ul><li>前后端部署的机子，不属于同一台云服务器。</li><li>同一台云服务器，但是你在 <a href="https://github.com/">https://github.com</a> 请求的是 <a href="https://github2.com/">https://github2.com</a> 上的资源。</li></ul><h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><ol><li>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</li><li>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。</li><li>这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？</li></ol><p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p><h2 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h2><h3 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1.jsonp"></a>1.jsonp</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 <code>JSON </code>数据。<code>JSONP</code>请求一定需要对方的服务器做支持才可以。</p><h4 id="JSONP和AJAX对比"><a href="#JSONP和AJAX对比" class="headerlink" title="JSONP和AJAX对比"></a><code>JSONP</code>和<code>AJAX</code>对比</h4><p><code>JSONP</code>和<code>AJAX</code>相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但<code>AJAX</code>属于同源策略，<code>JSONP</code>属于非同源策略（跨域请求)</p><h4 id="JSONP优缺点"><a href="#JSONP优缺点" class="headerlink" title="JSONP优缺点"></a>JSONP优缺点</h4><ul><li>优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。</li><li>缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</li></ul><h3 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2.CORS"></a>2.CORS</h3><h4 id="CORS-跨域的原理。"><a href="#CORS-跨域的原理。" class="headerlink" title="CORS 跨域的原理。"></a>CORS 跨域的原理。</h4><p>跨域资源共享（CORS）是一种机制，是 W3C 标准。它允许浏览器向跨源服务器，发出 XMLHttpRequest 或 Fetch 请求。并且整个 CORS 通信过程都是浏览器自动完成的，不需要用户参与。</p><p>而使用这种跨域资源共享的前提是，浏览器必须支持这个功能，并且服务器端也必须同意这种 “跨域” 请求。因此实现 CORS 的关键是服务器需要服务器。</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。</p><p>该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><h4 id="浏览器支持情况"><a href="#浏览器支持情况" class="headerlink" title="浏览器支持情况"></a>浏览器支持情况</h4><p>当你使用 IE&lt;=9, Opera&lt;12, or Firefox&lt;3.5 或者更加老的浏览器，这个时候请使用 JSONP</p><h4 id="CORS方法优点-amp-缺点："><a href="#CORS方法优点-amp-缺点：" class="headerlink" title="CORS方法优点&amp;缺点："></a>CORS方法优点&amp;缺点：</h4><p>优点</p><ul><li>简单，几乎不需要什么开发量，只需要简单配置相应的请求与响应头信息即可。</li><li>支持各种类型的请求（get, post, put等等）。</li></ul><p>缺点</p><ul><li>需要对跨域的服务接口进行一定的改造。如果该服务因为某些原因无法改造，则无法实现。但这种改造还是相对较小的。</li><li>不兼容一些“古董”浏览器。</li></ul><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。</p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>不会触发 CORS 预检请求。这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：</p><ol><li>情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)</li></ol><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><ol start="2"><li>情况二: 人为设置以下集合外的请求头</li></ol><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code> （需要注意额外的限制）</li><li><code>DPR</code></li><li><code>Downlink</code></li><li><code>Save-Data</code></li><li><code>Viewport-Width</code></li><li><code>Width</code></li></ul><ol start="3"><li>情况三：<code>Content-Type</code>的值仅限于下列三者之一：(例如 <code>application/json </code>为非简单请求)</li></ol><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><ol start="4"><li><p>情况四:<br>请求中的任意<code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；<code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。</p></li><li><p>情况五:<br>请求中没有使用 ReadableStream 对象。</p></li></ol><h3 id="3-postMessage"><a href="#3-postMessage" class="headerlink" title="3.postMessage"></a>3.postMessage</h3><blockquote><p>postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一。</p></blockquote><p>它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的 iframe 消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>postMessage() 方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><blockquote><p><code>otherWindow.postMessage(message, targetOrigin, [transfer])</code>;</p></blockquote><ul><li>message: 将要发送到其他 window的数据。</li><li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><h4 id="案列"><a href="#案列" class="headerlink" title="案列"></a>案列</h4><p>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递<code>“我爱你”</code>,然后后者传回<code>&quot;我不爱你&quot;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.html</span><br><span class="line">  &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;b.html&quot; frameborder&#x3D;&quot;0&quot; id&#x3D;&quot;frame&quot; onload&#x3D;&quot;load()&quot;&gt;&lt;&#x2F;iframe&gt; &#x2F;&#x2F;等它加载完触发一个事件</span><br><span class="line">  &#x2F;&#x2F;内嵌在http:&#x2F;&#x2F;localhost:3000&#x2F;a.html</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      function load() &#123;</span><br><span class="line">        let frame &#x3D; document.getElementById(&#39;frame&#39;)</span><br><span class="line">        frame.contentWindow.postMessage(&#39;我爱你&#39;, &#39;http:&#x2F;&#x2F;localhost:4000&#39;) &#x2F;&#x2F;发送数据</span><br><span class="line">        window.onmessage &#x3D; function(e) &#123; &#x2F;&#x2F;接受返回数据</span><br><span class="line">          console.log(e.data) &#x2F;&#x2F;我不爱你</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; b.html</span><br><span class="line">  window.onmessage &#x3D; function(e) &#123;</span><br><span class="line">    console.log(e.data) &#x2F;&#x2F;我爱你</span><br><span class="line">    e.source.postMessage(&#39;我不爱你&#39;, e.origin)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4.WebSocket"></a>4.WebSocket</h3><p>WebSocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。</p><p>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。</p><p>简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。</p><p>这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>前端部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  </span><br><span class="line">  <span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:8080&quot;</span>);socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">   socket.send(<span class="string">&quot;秋风的笔记&quot;</span>);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(e.data);  </span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>后端部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&quot;ws&quot;</span>);<span class="keyword">const</span> server = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);server.on(<span class="string">&quot;connection&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;  </span><br><span class="line">  socket.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;    </span><br><span class="line">    socket.send(data);  </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-Node-正向代理"><a href="#5-Node-正向代理" class="headerlink" title="5.Node 正向代理"></a>5.Node 正向代理</h3><blockquote><p>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</p></blockquote><p>代理服务器实现步骤：</p><ul><li>接受客户端请求 。</li><li>将请求 转发给服务器。</li><li>拿到服务器 响应 数据。</li><li>将 响应 转发给客户端。</li></ul><h4 id="cli-工具中的代理"><a href="#cli-工具中的代理" class="headerlink" title="cli 工具中的代理"></a>cli 工具中的代理</h4><ol><li>Webpack (4.x)<br>在webpack中可以配置proxy来快速获得接口代理的能力。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">  entry: &#123;    <span class="attr">index</span>: <span class="string">&quot;./index.js&quot;</span>  &#125;,  </span><br><span class="line">  output: &#123;    </span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,    </span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>)  </span><br><span class="line">  &#125;,  </span><br><span class="line">  devServer: &#123;    </span><br><span class="line">    port: <span class="number">8000</span>,    </span><br><span class="line">    proxy: &#123;      </span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;        </span><br><span class="line">        target: <span class="string">&quot;http://localhost:8080&quot;</span>      </span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  plugins: [    </span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;     </span><br><span class="line">       filename: <span class="string">&quot;index.html&quot;</span>,      </span><br><span class="line">      template: <span class="string">&quot;webpack.html&quot;</span>    </span><br><span class="line">    &#125;)  </span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>修改前端接口请求方式，改为不带域名。（因为现在是同域请求了）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;getlist&quot;</span>&gt;获取列表&lt;button&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;login&quot;</span>&gt;登录&lt;/button&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;  </span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;  </span><br><span class="line">getlist.onclick = <span class="function">() =&gt;</span> &#123;    </span><br><span class="line">  axios.get(<span class="string">&quot;/api/corslist&quot;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;      </span><br><span class="line">    <span class="built_in">console</span>.log(res.data);    </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;;  </span><br><span class="line">login.onclick = <span class="function">() =&gt;</span> &#123;    axios.post(<span class="string">&quot;/api/login&quot;</span>);  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>Vue-cli 2.x<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/index.js</span></span><br><span class="line">...proxyTable: &#123;  <span class="string">&#x27;/api&#x27;</span>: &#123;     <span class="attr">target</span>: <span class="string">&#x27;http://localhost:8080&#x27;</span>,  &#125;&#125;,</span><br><span class="line">..</span><br></pre></td></tr></table></figure></li><li>Vue-cli 3.x<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js 如果没有就新建</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">  devServer: &#123;    </span><br><span class="line">    port: <span class="number">8000</span>,    </span><br><span class="line">    proxy: &#123;      </span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;        </span><br><span class="line">        target: <span class="string">&quot;http://localhost:8080&quot;</span>      </span><br><span class="line">      &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li>Parcel (2.x)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .proxyrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;http://localhost:8080&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="charles"><a href="#charles" class="headerlink" title="charles"></a>charles</h4>这是一个测试、开发的神器。<a href="https://juejin.cn/post/6844903665304600589">介绍与使用</a></li></ol><p>利用 charles 进行跨域，本质就是请求的拦截与代理。</p><p>在 tools/map remote 中设置代理</p><h3 id="6-Nginx-反向代理"><a href="#6-Nginx-反向代理" class="headerlink" title="6.Nginx 反向代理"></a>6.Nginx 反向代理</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。<br>只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>先下载nginx，然后将nginx目录下的nginx.conf修改如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass   http:&#x2F;&#x2F;www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http:&#x2F;&#x2F;www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过命令行nginx -s reload启动nginx</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 向前台写cookie</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>   <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="7-window-name-iframe"><a href="#7-window-name-iframe" class="headerlink" title="7.window.name + iframe"></a>7.window.name + iframe</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。<br>其中<code>a.html</code>和<code>b.html</code>是同域的，都是<code>http://localhost:3000;而c.html是http://localhost:4000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html(http://localhost:3000/b.html)</span></span><br><span class="line"> &lt;iframe src=<span class="string">&quot;http://localhost:4000/c.html&quot;</span> frameborder=<span class="string">&quot;0&quot;</span> onload=<span class="string">&quot;load()&quot;</span> id=<span class="string">&quot;iframe&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="keyword">let</span> first = <span class="literal">true</span></span><br><span class="line">   <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(first)&#123;</span><br><span class="line">     <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">       <span class="keyword">let</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">       iframe.src = <span class="string">&#x27;http://localhost:3000/b.html&#x27;</span>;</span><br><span class="line">       first = <span class="literal">false</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span><br><span class="line">       <span class="built_in">console</span>.log(iframe.contentWindow.name);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>b.html为中间代理页，与a.html同域，内容为空。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.html(http://localhost:4000/c.html)</span></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="built_in">window</span>.name = <span class="string">&#x27;我不爱你&#x27;</span></span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="8-location-hash-iframe"><a href="#8-location-hash-iframe" class="headerlink" title="8. location.hash +  iframe"></a>8. location.hash +  iframe</h3><p>实现原理： <code>a.html</code>欲与<code>c.html</code>跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用<code>iframe</code>的<code>location.hash</code>传值，相同域之间直接js访问来通信。<br>具体实现步骤：一开始<code>a.html</code>给<code>c.html</code>传一个<code>hash</code>值，然后<code>c.html</code>收到<code>hash</code>值后，再把<code>hash</code>值传递给<code>b.html</code>，最后<code>b.html</code>将结果放到<code>a.html</code>的<code>hash</code>值中。<br>同样的，<code>a.html</code>和<code>b.html</code>是同域的，都是<code>http://localhost:3000</code>;而<code>c.html</code>是<code>http://localhost:4000</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html</span></span><br><span class="line"> &lt;iframe src=<span class="string">&quot;http://localhost:4000/c.html#iloveyou&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//检测hash的变化</span></span><br><span class="line">     <span class="built_in">console</span>.log(location.hash);</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.html</span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.parent.parent.location.hash = location.hash </span><br><span class="line">    <span class="comment">//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span></span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.html</span></span><br><span class="line"> <span class="built_in">console</span>.log(location.hash);</span><br><span class="line">  <span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">  iframe.src = <span class="string">&#x27;http://localhost:3000/b.html#idontloveyou&#x27;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(iframe);</span><br></pre></td></tr></table></figure><h3 id="9-document-domain-iframe"><a href="#9-document-domain-iframe" class="headerlink" title="9.document.domain + iframe"></a>9.document.domain + iframe</h3><p>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。<br>只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。<br>实现原理：两个页面都通过js强制设置<code>document.domain</code>为基础主域，就实现了同域。<br>我们看个例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中<code>a</code>的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line"> helloa</span><br><span class="line">  &lt;iframe src=<span class="string">&quot;http://b.zf1.cn:3000/b.html&quot;</span> frameborder=<span class="string">&quot;0&quot;</span> onload=<span class="string">&quot;load()&quot;</span> id=<span class="string">&quot;frame&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="built_in">document</span>.domain = <span class="string">&#x27;zf1.cn&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(frame.contentWindow.a);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.html</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">   hellob</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">     <span class="built_in">document</span>.domain = <span class="string">&#x27;zf1.cn&#x27;</span></span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h2 id="正向代理与反向代理比较"><a href="#正向代理与反向代理比较" class="headerlink" title="正向代理与反向代理比较"></a>正向代理与反向代理比较</h2><p>从用途上来讲：</p><ul><li>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。</li><li>反向代理的典型用途是为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。</li></ul><p>从安全性来讲：</p><ul><li>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。</li><li>反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</li></ul><p>从使用方来看：</p><ul><li>正向代理是浏览器端进行配置的，与服务器端无关，甚至可以对服务端隐藏。</li><li>反向代理是服务器端配置的，对浏览器端是透明的。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ul><ol><li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li><li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li><li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li><li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903767226351623">九种跨域方式实现原理（完整版）</a></li><li><a href="https://juejin.cn/post/6844904148022870023#heading-0">面试题：nginx有配置过吗?反向代理知道吗?</a></li><li><a href="https://juejin.cn/post/6844904126246027278#heading-0">10种跨域解决方案（附终极大招）</a></li><li><a href="https://segmentfault.com/a/1190000010719058">前端开发如何独立解决跨域问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;笔者在对浏览器的一些知识做的系统梳理总结，目前仅供笔者复习知识用，若涉及版权问题，请联系我进行修改&lt;/p&gt;
&lt;h2 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://github.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://github.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
</feed>
